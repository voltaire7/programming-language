[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
    print a
    print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
    eprint msg
    exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functional and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

(define (fib n)
    (if (or (= n 0) (= n 1))
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functional caracteristics.]

[Converted jai code]
atom [render] do [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
    print [Hello, World!]

    if true
        print [yes]
        print [no]

    loop print [loops forever]
    for 0 10 print format [prints 10 time. this is [i]]
    while condition [you know.]

    [<3]
]

[Procedural vs functional]
atom [main] do [
    add [x] 1 2
    eq [y] x 3
    if y print [truth] print [falsehood]
]
atom [main] do [
    if eq 3 add 1 2
        print [truth]
        print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
    format x [Hello [y], my name is [z]]
    print x
]
atom [complex x y z] do [
    atom x format [Hello [y], my name is [z]]
    print x
]

[Holy fuck! Procedural actually beats functional... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
    : [x] 1 1
    tail [y] fib:x
    zipWith [y] [+] fib:x fib:y
    : [x] x y
]
atom [fib out init] do [
    : out init out
    tail [t] out
    zipWith [z] [+] out t
    : [out] out z
    fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
    print [do stuff...]
    > bool a b
    if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
    atom [temp] x
    atom x y
    atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
    atom [low] 0
    len [high] items
    sub [high] high 1
    <= [cond] low high
    atom [continue?] true
    while cond do [
        add [mid] low high
        div [mid] mid 2

        cmp [c] mid target
        equal? c do [atom result mid atom [continue?] false]
        less? c do [atom [low] mid add [low] low 1]
        more? c do [atom [high] mid sub [high] high 1]

        <= [cond] low high
        && [cond] cond continue?
    ]
]

atom [binary-search target items] do [
    atom [low] 0
    atom [high] sub len items 1
    atom [continue?] true
    while && <= low high continue? do [
        atom [mid] div add low high 2

        atom [c] cmp mid target
        equal? c do [mid atom [continue?] false]
        less? c atom [low] add mid 1
        more? c atom [high] sub mid 1
    ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
    proj-rect [pr] proj-x proj-y
    unpack-color [pc] PROJ-COLOR
    fill-rect pr pc

    unpack-color [bc] BAR-COLOR
    fill-rect bar-rect bc

    for targets-pool do [
        target-rect [tr] it
        unpack-color [tc] TARGET-COLOR
        if !it.dead fill-rect tr tc
    ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
    add [x] x y
    print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functional...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
    add [x] x y
    print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
    add [x] x y
    print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[vs]

atom [test] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functional way for the bros:]
atom [test x y]
    print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functional translate on the lower level?]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functional, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
    print [still true]
    break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
    sub n 1
    == n 0
    false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
    proc
    loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
    cmp [result] it to
    = error [[it] and [to] cannot be the same values; please try another combination.]
    > for-
    < for+
]
atom [for-] do [
    proc
    sub [it] 1
    cmp it to
    != for it to proc
]
atom [for+] do [
    proc
    add [it] 1
    cmp it to
    != for it to proc
]
atom [for-each items proc] do [
    get-len [len] items
    for 0 len proc
]
atom [while proc] do [
    atom [while?] true
    atom [label] while?
    while-arg
]
atom [while-arg] do [
    proc
    if label while-arg []
]

[But functional may actually come out of it as well...]
atom [+ x y] do [
    add [x] x y
    x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
    add [x] x y
    x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
    proc
    next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
    proc
    next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
    x
    add [x] x y
]
+ + 1 2 3
[Should I consider functional again?]

[Wait, no. Shit gets fucked up.]
atom [x] + 1 2 atom [y] 3 do [
    x
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    + 1 2
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        x
        add [x] x y
    ]
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        1
        add [x] x y
    ]
    add [x] x y
]
[Maybe if I made [x] and [y] local to the procedure?]

atom [add-all x y] do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
]
add-all 1 2 3 []
atom [x] 1 atom [y] 2 do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
] 3 []
atom [x] 1 atom [y] 2 add-all x 3 []
[Hm. Does it really work like that?]

[More functional]
let [x y] 1 2
atom [x] 1 atom [y] 2

[Should be equivalent?]
atom [func x y] []
atom [func] do [let [x y]]

[Maybe it's that simple?]
atom [atom name value] push-key name value atoms
[But any more than, and we're implementing stuff.]

[Functional again]
atom [+ x y] do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
+ + 1 2 + 3 4
atom [x] + 1 2 atom [y] + 3 4 do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        1 2
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        3 4
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
[Is it impossible? Well whatever. I can tell already: the hoops you have to jump through to get this
behavior is insane. I will probably still try to make this work, but the procedural way is far
better. You know, left-to-right and infix is just more elegant.]

chain 1 + 2 + 3 + 4 as [test]
print _ [outputs 10]
print test [outputs 10]
[I mean look at this! It's fucking beautiful!]

[Rust syntax]
atom [let name] []
atom [= value] atom [name] value
atom [;] atom [name] []
let [test_val] = 2 ;
[Well, "Rust" syntax.]

[Delete]
atom [delete name] atom name []

[I don't think this language should have something like function overloading.]

[Maybe I could have a [type] [Single] that can only be called once, and once done, it will be
removed from the list of variables?]

[If each variable has the following values:]

struct [atom] [
    name value before after
]

[where [name] is of course the symbol of the [atom], then [value] is the what it returns, or the
pointer to the value in memory. What if there was [before] and [after], where [before] is code that
gets executed before the value is called, while [after] is code executed after it's called. So like,
in [before] we could have a macro that sets up the arguments of the procedure, then adds the [value]
after the declarations? And in [after], I could have some RAII clean up? I think I'm unto something,
but the idea needs polishing.]

[Btw, if I do [before] and [after], I could probably do this:]
type [+] [
    before atom [x] prev 1
    after atom [y] next 1
]
atom [+] add [_] x y
1 + 2 print _
[I'm not sure where I'm going with this, frankly.]

[Maybe the entire program is actually a list of tokens that can change itself.]
1 2 3 print get 1 program
[outputs 2?]

[Or maybe...]
atom [+] add #-1 #1
1 + 2
[where #n is a relative value? But how do [add] work then?]

[I really need to start working on the implementation. There's only so much I can do with only
theory, and so little technical knowledge.]

[I know that, eventually, everything becomes [hex []], and then gets executed. But how does it do
it? *Sigh*]

[I feel like python will be more useful for learning how to write this programming language than
Rust or C...]

[Is this programming language becoming too complicated, like LISP nowadays?]

[I should stick with the S Expressions. Adding anything else is bloat.]

[Btw, the model where we do [add #-1 #1] is interesting but stupid, because what is [add] defined
as? There is still a lesson here though. Just need to find out which.]

[Maybe I shouldn't have a hex procedure? Maybe numbers simply get hexecuted (?) when 32 bits have be
gathered? Maybe numbers are just functions that reduce to themselves in binary format?]

[I think I should just use hexadecimal for all number types. Like what, is anyone going to use my
programming language expect me? And little endian too. Of course that would mean I need to get used
to hexadecimal, and convert it off the top of my head, but otherwise, I should try it and see how it
works.]

[Incidentally, in regards to trying out things, I think the 3 space indent is bad. I tried it for
some C code, and while it isn't as noticeable for small procedures, for larger ones, 3 spaces just
feels wrong. Not to mention, 4 spaces is byte aligned.]

[I think I might replace every instance of [atom] with [macro], because that's what they are. But I
don't know. [atom] sounds real nice.]

[If I write]
mov x0 [str]
[should x0 now have the utf-8 value of [str]? I feel like yes... But that would mean that mov isn't
a parameterless macro... Though.]

[This blows. I found out that the way an instruction is encoded is not necessarily byte aligned, an
so I will find it difficult to write the most basic macro...]

[And now chatGPT tells me that not every instruction is 32 bits. This is going to be so difficult.]

[Oh hey there, I didn't see you. So after giving RISC-V's specification a look I saw that unlike
arm64, the opcode is the smallest value, and the destination register is the thing that follows. So
I think I'm going to try and run the programming language on a RISC-V platform. This is of course
far harder than it sounds, but no harm in trying.]

[The idea about abandonning [hex []] is no longer realistic. To begin with, opcodes are not byte
aligned, whether on arm64 or RISC-V. So I'll instead have something call [bin []].]

[Damn, I don't think I could even do something like [[mov] -> 000000] because, we do do know that
[x1] will be a fixed size, but not the number that follows.]

[I am a little conflicted now: in [foo] could just be a function pointer, and you call the pointer
by putting parentheses after it. This is elegant, and I like it. Question is, how do I replicate the
behavior? Do I just quote it? But then, how is it different from a normal string? How do I, for
example, [printf] a function pointer? Damn, this is tough.]

[Ok this is something that might give LISP edge: by typing [func], you get the function pointer, by
typing [(func arg1 arg2)], call the function. But man, this sucks, because I build this whole idea
over the premise that the LISP model is imperfect. I can cede just yet...]

[I figured it out, if every value in LISP returns a pointer by default, then you would have to call
variables as well (even more parentheses; heck no!). And in C, you constanly reference and
dereference a variable, which is the equivalent of quoting and unquoting, but with a different
syntax. Not to mention you don't really have symbols. In which case, I still need to figure out the
tug of war between symbols, pointers and values.]

[Iteration may actually be better than recursion... I mean, in assembly you have branch and branch
with link; so while you usually do recursion, it's not really the same.]

[More details about eager vs lazy.]
chain 1 + 2 + 3 + 4 as [val]
macro [val] do [chain 1 + 2 + 3 + 4]
[The first one is eager because the program takes those additions and executes them left-to-right;
the second one is lazy because [macro] gets executed, but not the arguments, since they are absorbed
into the procedure call.]

[I've been getting pretty decent at the CLI, but doing so, I question having to put [] around every
thing that isn't a function or procedure call. Maybe I should follow LISP in this?]

[Another reason why I shouldn't do [import] and instead just reference a file like a script is that
I want the compiler to be single pass, but doing it otherwise would be complicated.]

[Okay, so big problem for procedural:]
atom [add x y z] todo
[How do I define it?]
atom [add x y z]
    atom x + y z
[Like this? Do you see the problem? Thing is, I'm trying to merge [add] and store instructions into
the same thing, but they are not the same thing. The solution could be as follows:]
atom [+ x] do [
    add x0 _ x1
    store x0 [_]
]
[where everything returns to [_]. Only the instructions themselves will keep use the old format, the
rest will behave much like functional, but still left-to-right.]

[But then again...]
atom [+ x] atom [_] add _ x

[It's important I get this right, because if I don't, the programming language may be dog shit.]

[Maybe everything that hasn't been defined yet evaluates to itself, quoted. So that's how I could do
numbers.]

[I might want to create a proper proper LISP first using my low level model, just to get the hand of
it.]

[Perhaps...]
atom [recursive-proc x y] do [
    todo x y
    goto [recursive-proc]
]
[that way, there is no need to redefine [x] and [y] since they are already defined.]

[[before] and [after] may be too much. An [env] should only have [symbol], [value] and [size].]

[Do I really need dependent types? Is there no better way to check for correctness?]
atom [val x] do [
    < x 0 true? error [cannot be negative]
    todo
]
val -1
[The linter should be smart enough to tell that this will always throw, and warn you of it. No need
for types; they are too complicated anyway.]

[I am all the more motivated to create a LISP, because of this:]
(define func (lambda (a) (display a)))
[Because it's eager loaded, lambda executes, creates a procedure, and returns the pointer to it.]
(func "Hello, World!")
(func func) [outputs something like 0x20D1A5BC]
[Holy fuck, is this elegant...]

[Maybe]
atom [func] lambda [a] print a
func at [func]
[outputs something like 0x20D1A5BC]
func do [func] [Hello, World!]

[In LISP, you have special notation for quoting, but everything else is call by value or call a
procedure. In my language, lists are quoted by default, and if a procedure has args, they are called
by default, when not quoted. But that was the funcionnal one. What about procedural?]

atom [func] lambda [a] print a
[Does not work because [lambda] is lazy. And procedures shouldn't be able to returns things.]
lambda [a] print a as [func]
[I think this works, but should I?]

[Once again, functional is making a comeback.]
[Also, I really need to figure out how to lazy [print]...]

[Okay, lazy vs eager eval really fucks me up, because you have to mix them up, right?]
atom [test] do [
    other-func lambda [x] x
    print _
]
[Does lambda create a new procedure everytime [test] is called?]

atom [func] lambda [x y] todo
[[lambda] is eager, but todo is not? What is the logic behind that?]
lambda [x y] todo as [func]
[More ugly but makes more sense. Maybe I already found the answer; and I'm just being stupid:]
lambda [x] x
atom [test] do [
    other-func _
    print _
]
[I guess it is still better than LISP, since I doesn't have some arbitrary procedures that lazy
instead of the eager default.]

[I should drop the eager function as arguments, or whatever. Doesn't make sense with new model:]
atom [func x y z] do [
    print x
    print y
    print z
]
func [add] 1 2
[becomes]
do [add] 1 2
[wait no... I have to rework [do []] if I do that...]

[I should consider it seriously still... The biggest problem is [atom] and it's implementation.]
[Maybe [list] will make a comeback? Nevermind again. There is simply no way of doing this without
having non-quoted lists.]

[Ok, let's think. Because I think I am unto something.]
[Still a comment/string]
(define [name] 5)
(print name) [outputs [pointer] so bad]
(print (name)) [outputs [value] so good]

[Ok, now without parentheses, or less.]
[Comment]
define [name] 5
print name [outputs [value] so good]
print ptr-to name [outputs [pointer] so good]
[problem is: should it be eager or lazy]

[cannot be eager]
define [func x y] do []

[this can]
define [func] lambda [x y] [print x print y]
func 1 2
[becomes]
let [x y] 1 2 do [print x print y]
[but should I?]

[what about]
define [func x y] ()
[yeah, I've got nothing. I thought I was unto something last night; something to do with parentheses
to be used for eager loading, but I don't remember what.]

[wait no, the lisp example works because the [value] of [name] is a pointer to a pointer!]
[damn, I went through this train of thought a while ago...]

[In any case...]
atom [atom symbol return] do [
    ch symbol len > 1
    then do [
        car symbol as [name]
        cdr symbol as [params]
        atom name lambda params return
    ]
    else append env symbol return
]
[but it has to be lazy, otherwise [then do []] will get evaluated.]
[god this shit is confusing]

[maybe...]
atom [then x] if _ x []
atom [else x] if _ [] x

[it should be lazy, but then I can't do [lambda]...]

[optionnal []?]
define name 3
atom [define x y] do [
    quoted? x atom x y
    else atom quote x y
]
[something like that?]

[it would be a bad practice though, but would make the all variables are quoted if undefined work.]

[Hmm, if I do this...]
atom [items] [ 1 2 3 ]
[This would be a 5 [strings] or [u8] pointers, and the atom macro would see that the first pointer
points to a value representing a array oppening, and then do the magic.]

[Man... What the first macro takes the rest of the programming language as parameters? I think I had
this idea before, but I would love to see this work!]
+ 1 2 - 3 4
[[+] takes the first two values, then the rest; since it knows it only need two values, it simply
executes [eval] or something like that, then [eval] executes the rest accordingly. If it's a
[string], it calls eval on the next value; so on.]

[Again, infix syntax, but not really.]
atom [| x y] x _ y
quote name | atom [John Doe]
[Basically piping, but dummer. Equivalent:]
quote name atom _ [John Doe]
[This is not valid...]
atom quote name [John Doe]
[Since there are only side-effects.]
[Also, I guess [x] is the first argument, while [y] is the rest of the application?]

[Okay, listen.]
atom [proc1] do [
    get args 1 as arg1
    print arg1
]
[because [args] is the rest of the application. So you can just index into it like some ordinary
array. I love this!]
[In fact, I can probably still do this:]
atom [proc1 x y z] do []
[equivalent]
atom [proc1] do [
    get args 0 as x
    get args 1 as y
    get args 2 as z
]
[Like bro, this is more elegant than anything I've come up with before!]

[Holy fuck.]
print [test]
print [test again]
[Usually, when you call a procedure, the things get put in the stack, but because the procedure
you're calling is the one calling the next procedure, you fix most problems with recursion just like
that!]

calculate bottom top = sum $ filter (\x -> mod x 2 == 0) [bottom..top]
[suppose...]
atom [calculate bottom top] do [filter []]

[I don't really like this]
1 + 1 print _
1 + 1 dbg
[I probably won't keep debug, idk]

[Functional won't die]
atom [print x] do [
    quote? x
        then write x
        else do [
            x args
            print _
        ]
]
[so]
print + 1 2 [outputs 3]

[the beauty of this language is that anything is permissible]
[the ugliness of this language is that anything is permissible]

atom [+ x y] do [
    num? x else do [x args as x]
    num? y else do [x args as y]
    + x y
]
print + * 1 2 - 3 4

[I don't think I have to check for variables though?]
atom [name] [Joe]
print name
[Damn, I don't know!]

[btw, just remembered that I still don't know how to do [atom [] do []], at least not elegantly.]

[in [bc] you can do [sqrt(2)] and the result is [1], but with [sqrt(2.0000000000)] and the result is
[1.4142135623]; very interesting.]

[The reason why [+ + 1 2 + 3 4] will never be possible is because in [+ a b], [a] and [b] will have
to be argumentless functions that always return the same thing, which is obviously not procedural.]

[Then again... Yeah, functional will never die. Anyway, can't way to finally put this project into
motion.]

[*Sigh*... Maybe I should add types... Otherwise, it becomes such a pain in the ass.]
1.2 + 5 print _
[How is [+] supposed to know if 1.2 is a float without specifying it...? [+float] maybe?
[float-add]?]

[Maybe I will have types, but they are not user declared?]

atom [func x] fn [
    print x
]
[[fn] is eager, compiles the quoted code and returns pointer to it?]
atom [val1] [func]
[[val1] = symbol to function.]
do val1 1 [outputs [1]]
atom [val2] func 2 [outputs [2]]
[[val2] = [] because [func] got evaluated, and returned nothing?]

fn [x] [print x] as [func]
[more standard lambda?]

[still, I could make it so [atom] always evaluates the value, it's just that if it's a variable,
then the variables value will get assigned to [_]?]

[maybe I could consider this:]
atom var [this is a string]
atom [var] [print [this is code]]
[...but I already decided not to do this. If I do, the floodgates will open...]

[btw, [let]]
let [
    a 2
    b 5
] []
atom [let x y] fn [
    count x as x-len
    for 0 x-len [
        get x it as [x0]
        += [it] 1 get x it as [x1]
        atom x0 x1
    ]
    do y
    x-len / 2 pop _
]
[maybe a way to do scoping?]
[nvm, can't define global variables this way.]
[wait, not [pop 3] but reverse of [for]?]

[right, almost forgot, if [fn] or whatever compile completely, we would need to compile the program
supposing that we can stand long load times, since once the procedures have been assigned, and
therefore compiled, they will run like it's a binary. food for thought.]

[Perhaps this is the only overloading I need?]
2 + 2 [integer addition]
2.0 + 2.0 [floating point addition]
[you would need to keep track of what value is what type yourself. The programming language doesn't
do it for you.]
2 + 2.0 [float added to int; fucks shit up]
[also, I guess imaginary and complex numbers are kind of the same as integers, so you just need to
keep track of that yourself as well.]
[there's also this]
2u64 + 2 [but maybe not? since temporary storage is like fixed size, but then again, it's also just
a pointer... idk]
[anyway, I should first try to avoid metadata like the plague, and see what happens.]

func 1 2 as [val e]
[multiple assignement?]

1 > 0
    then print [is bigger]
    else print [is smaller]
[^ this may be impossible, since [get args 1]]
atom [then x] [
    [insert branching logic]
        x args
]
[since args is just a pointer, and the [x] in the assignement move the pointer right, you can just
do this.]
[still, it might be useful to have something like this:]
1 > 0 ?
    print [is bigger]
    print [is smaller]
[to prevent else from executing. idk.]
[wait, shit. I remember now why I had to quote [x]: how do I know the args of [print] shouldn't be
executed?]
1 > 0
    then [print [is bigger]]
    else [print [is smaller]]

[btw, this may be possible:]
atom [func x] [
    do-shit x
    x args
]
1 func [+] 2 print _
[nice.]

[I'm still debating variable and procedure assignement.]
proc [x y] [x + y print _] as [add-show]
[^ this works, but it's ugly.]
atom [func x y] + x y
[doesn't work because of lazy vs eager.]

[i think this is the best:]
atom a 2                            [value of 2]
atom str [this is a string]         [pointer to string]
atom func' func                     [same pointer]
atom [hello x y] [print [hello, world]] [compile procedure, [hello] now has the pointer to it.]

[but that opens so many doors, and closes a few.]
atom [+= val n] [
    n + val as val
]
[or maybe it doesn't close doors?]

[i should really consider this]
let [a 1 b 2]
[idk in what form though.]

[Wait a second...]
atom [func x y] fn [print [thing]]
[this may be possible if [fn] moves [args] to the right.]
[not very useful, though, since [fn] can't return anything...]

[still can't do this though]
0 then print x
[[print] needs to be evaled to move [args]]

[Sometimes, it's just ugly. I don't think I should go to such lengths just to avoid
[proc [] [] as [f]]]
[Death to syntaxic sugar!]
[Also, quoting non-evaulated strings is just better. No suprise there.]

[I could do this, though it's ugly.]
0 then 1 print x
[where]
proc [skip f] [
    [branching logic]
        f args
    += args skip
] as [then]
[could be worse]

[Remember to implement flipjump in the language.]

[I guess it's also a bit like vertical align: it's ugly but objectively better...]

[maybe I could have [proc] and [item]?]

[I doubt I could compile a procedure using the C interpreter, but I could probably do a scuffed
variant, one that write C code to a file, compiles it and then executes the binary.]

[I should have donut shaped code that prints donut as a demo.]

[My [env] stack should have standard CRUD operations, plus upsert.]

[I should make [bin-exec] as small as possible, i.e. ignore all the characters other than 0 and 1.]

[I realized something.]
2 print _ [outputs 2]
item [a] 2
a + 2 print _ [panic at a, because it is treating [a] as a procedure pointer.]
ch a + 2 print _ [outputs 4]
[guess [ch] makes a comeback.]
[btw, would've been classy is it was called [return] instead of [ch], but it's too long, and it
doesn't make sense in a lot of situations.]

[I should consider making numbers not special. So the simplicity is taken to the extreme. Like
functional, it needs testing.]

[Also, experiment with tabs for vertical align.]

[Should do tetris in C, then in this language.]

[I should mention, this language is procedural, yet it is still takes inspiration from lambda
calculus.]

[Don't forget to experiment with spaced variable names. I doubt I will actually use it in
production, but I want to see what it would look like.]

[btw, the way procedure calls are done, allows infinite recursion.]

[When I finally figure out how vim works, I will make Control+S wall.]

[Maybe [return] could assign the [_] of the outside scope!]

[Damn, procedure definition may be easier than I anticipated!]

[Should have procedures to manually push or pop a env.]

[1.0 will only release at the end of my life, after I will have thoroughly tested the language.]

[Recursion doesn't really work.]
proc [] [
    func
] as [func]
[How is it supposed to know that it's called [func]?]

[Probably will have to use [goto]]
proc [] [
    label [start]
    do-stuff
    goto start
] as [func]

proc [label] [
    item [start] position
]
proc [start] [
    item [position] start
] as goto
[I heard that [goto] is, like, literally Hitler, but this is the cleanest way to do recursion,
without doing recursion.]
[We're getting further and further away from functional programming...]

[I'm curious, just how different will the implementation turn out to be?]

[Wait, couldn't I just use [goto]? no need for procedures and all that – yeah, this language is
getting worse by the second.]

[If you want to redefine [eval] and use the new one, you can only do so by calling it on a [Quote].]
proc [code] [
    [do-things]
] as [eval]
eval [print [Hello, World!]]
[or]
read-file [main.txt] eval _
[You know what? The procedure notation is growing on me. I don't know how to feel.]

[Oh shit, I might have to manually [free] strings like in C, if I really don't want metadata...]

[Maybe I should use [mark] instead of [label]?]

proc [e] [
    print [%s\n] e
    exit 1
] as [error]
[where [e] is a pointer to a string. It has a unique id and error message!]
item [index-out-of-bounds] [Index %i is larger than the maximum %i\n]
throw index-out-of-bounds
[wait no]
proc [e] [
    item [err] e
] as [throw]
[It should do something like assigning to the super env. Like [return] but for errors, and instead
of using [_], we use [err] or [e].]

[Holy!]
item [code] [
    print [hello\n]
]
do code
[This looks good!]

[Recursive printing?]
item [x] [%\n]
print [%s] x 5
[prints [5\n]]

[I think I should really make separate procedures for [insert] and [update]...]

[Damn, I'm seriously considering adding metadata...]
1 + 1 print _ [Can't even do that!]
[Adding metadata would be exceedingly simple: just another field in [Entry].]
[... Yeah, I going to do it – Or at least try it, the same way I tried upsert.]
[maybe [let] for upsert, and [set] for update? Also, I could make it so both are insert in there is
no existing variable in either self or super?]
[No, there would be two upsert, but they behave differently: one first checks if a variable exists
anywhere, the other calls upsert immediately.]

[Perhaps I'm giving myself too much of a headache?]
item-in 1 [a] 42
[^ this assigns one layer higher.]

[what if [meta] is just a string to for code to be executed?]

[I shouldn't forget to implement library like numpy, sciki-learn, tensorflow, pyplot, pandas,
matplotlib, lodash; maybe some minimal js frameworks like htmx or alpine.js; i don't know. Anything
that seems pertinent. Oh and also things like SDL2 and/or raylib]

[I don't think I will do this:]
item [name] [World]
print [Hello, [name]!\n]
[Too much nesting.]
print [Hello, %!\n] name
[better]

[maybe a procedure [do-here] that doesn't push another environment?]

[Do I really need a [meta]? The only reason you might want it is because floats are weird, that and
nicer syntax. If you really cave in and add them, a lot of other doors open, which should remain
closed...]
1 + 1 print [%i] _
[^ this is equivalent to the earlier code; and it's what I do in C. This isn't Hitler or anything.]
[My goal is to make the compiler as small as possible, while still having the performance of C, and
the capabilities of Scheme. I should hold myself to higher standards.]
[This will be really awkward when I do decide to add metadata...]

[I need a [format] procedure for [print]. And I need to malloc and copy a string. I can't print
character by character, since when I encounter an error, it will have printed until the error.
Still, I makes it harder when you don't know the final size of it. Maybe malloc every time I
encounter a %?]

[I will probably put something like as an example, but I want to put it here because of how nice it
look.]
proc [x y] [
    print [Hello, World!\n]
] as [proc]

proc [name] [
    print [Hello, %!\n] name
] as [greet]
greet [World]

print greet [
    will output:
    [parse copy-token item [name] _ print [Hello, %!\n] name]
    and maybe:
    [iter [k] keys [parse copy-token item k _] free keys print [Hello, %!\n] name]
    also [do-here] to evaluate iter block without creating a new environment – or maybe I should
    instead do [item-in]?
]
[How many programming languages can you do that in? I mean the [item k _]; in C you could create a
hashmap, but I this language this is the default. I like.]

[[parse] and [copy-token] and the like should only be usable in a higher scope. Otherwise, things
get really messy. Further experimentation is needed.]

[Maybe I can have two different [do]?]
item [do] [stuff...]
do []
[^ need to do this to see changes.]
item 1 [do] [stuff as well...]
[the change is immediately noticeable, since the rest of the code is executed using this [do].]

[As scuffed as procedures are now, I can't make them in another way without adding metadata, but
adding metadata is worthless since I eventually plan to compile these things.]

[The more I think about, the more difficult compiled symbolic programming sounds. I suppose that why
it hasn't been done yet, in the straightforward I'm trying to do it, I mean. Or has it. Probably
some LISP dialect.]

[Fuck it. I want to simulate compiled procedures. I don't want to write [do] everytime, so I will
use metadata, but only for this specific case; and then, I will naturally remove it once I can
compile them. The only other alternative to using [do] is to write C files, compile them and run
them from the CLI – something I want to absolutely avoid.]

[I don't just want to make the interpreter as small as possible; I want to follow the unix
philosophy in general.]

[Damn, I make a lot of typos.]

[Wait...]
for 0 10 print [%i\n] it
[this could work because [for] remembers the start of [print]; once [print] finished executing,
[for] continues executing, and returns the pointer back to the start of [print].]
[I should really consider it, so I can avoid nesting as much as possible.]

[For using the REPL of this programming language like a shell, I would need a way to import binaries
and call them.]
load-bin [/usr/bin/]
bc [-e sqrt(121)]
[this should print 11]
[although, I might need quotation like in the shell]
bc [-e 'sqrt(121)']
[maybe I can also load individual binaries or entire folder accordingly]

[Do I say S-Statements instead of S-Expressions?]

[Just found out about realloc. Should use it to concatenate strings.]

[Shit, how do I malloc?]
item str [hello]
item-at 0 str [H]
print str [outputs Hello]
[Maybe it's no that difficult?]

[Man, being able to define procedures opens so many doors!]

[I can make a [format] procedure with the new concat function.]

[I should be [get] and [set]]
item [str] [Hello]
get 1 str print [%c\n] _ [outputs 'e']
set 1 str [E] print str [outputs 'HEllo']

[Should I have a special syntax for characters?]
[or maybe]
item [char] [x]
[if the value is a single character long, it just interprets it as a char? No need for malloc?]

[Still, I would have to be mindful when implementing string manipulation.]

[Wait a second...]
proc [] [
    + 1 repeat _ [parse 2] do
] as [?]
5 == 5 ? [] []
[^ an interesting way to implement if statements.]

[Numbers have to be treated specially, otherwise...]
item [a] 1 [throws error, undefined symbol]

[Should I make it so that [return] pops the scope?]
proc [i list len] [
    for [n] list [
        ch n == i ? [return 3 n] [++ len]
    ]
]
[Maybe something similar for [continue]? Like, it's equivalent to [goto 0], or something?]
[Perhaps break as well, but it returns nothing?]

[I'm starting to think that i need special notation for char.]
item [c] 'c'
[^ the string [c] is equal to the char 'c']
[I could make it so a string of length 1 becomes a character automatically, but right now, I don't
know.]
char [a] item [a] _
[^ maybe?]

[Just realized that my language simulates function currying.]

[For [do-here], I don't need anything special; just don't create a new [env], change the [start] and
[end] positions.]
proc [x y] [
    do-here func x y
] as [func]
func 1 2
[First call creates a new [env] because of [do], second+ calls do not.]

[Btw, [type?] is impossible.]

[Everything I say here will probably change once I actually compile the procedures, but whatever.]

[There no point to [then]/[else]]
1 ? [print 1] []
1 then [print 1]
[^ same length]
[I would have to rename [then] to something shorter.]

[Wait, [del] instead of [delete]]

[Create new scope should always be opt-in. So there should be a [do []] inside of all procedures.]

[I will probably have to figure out how to make procedures reference eachother.]

[Perhaps it should just be in [proc] that things are compiled, but everywhere. Like, every statement
is compiled first, then executed. [proc] just makes it so that every statement in the block is
compiled ahead-of-time.]

[Maybe I could take this to my advantage?]
for [][][] [
    print [Hello\n]
]
[you know, how quotes don't check if there're a space at the end?]

[What if the procedure needs the inputs as strings or to invalidate inputs depending on type? Then
you you the arguments to be assigned strings, and the procedures calls inside will manipulate those
string into the desired data.]

[I might need a macro key word that goes does process the parameters.]

syscall 4 [] [is good idea because:]
proc [] [
    syscall 4
] as [write]
write [1 [Hello, World!] 14]

[With my design, even when compiled, [1 + 2 + 3] is too instruction heavy.]
1 + 2 + 3
[is equivalent to ]
[atoi on '1', load into register x0]
[atoi on '2', load into register x1]
add x0, x0, x1
[logic for computing hash]
str x0, [memory location]
[repeat for '3']
[lots of unnecessary steps...]

[Wait]
proc [fd buf n] [
    syscall 4 [fd buf n]
] as [write]
item [str] [Hello, World!\n]
strlen str
write 1 str _
[[write] should not take a variable number of arguments.]

[Yeah, I'm not doing [+=]. Too confusing.]
+= x 2
[or]
+= [x] 2
[? Both are valid and invalid. I don't like it.]
[Well, in any case, it should be easy to define, if you insist on having it.]

[I wasn't initially interested in [defer], but after seeing an example of how [free] could have a
lot of repetition, I reconsidered it. I should try it, at least.]

[Man, I really dug myself in a hole with 64 bit unions. Now I have not way of doing [strcpy], or
whatever.]

[I guess this is a solution.]
load 1 str
stor 1 str 'c'

[I guess, it's also a [goto] vs [defer] thing. Though, people will absolutely hate [goto],
no doubt.]

[It should be the interpreter itself that assigns [_] at the end of a procedure call. The procedure
itself should not concern itself with that.]

[I should figure out how to stuff on the stack... for procedure calls and such.]

[[free] should keep track of what was freed and what wasn't. Avoid double free, basically. I mean,
[free] isn't actually a syscall, apparently. Let's take advantage of that.]
[Then again, it's also an overhead...]

[I can use the [ret] instruction to calculate the size of a procedure!]

[I suppose procedures should concern themselves with processing the tokens into data, and instead
just look at the stack?]

[I should build the disassembler in parallel to the assembler, as the code is basically the
reverse.]

[[proc-len]... hehe.]

[I could just use the args to define the header of a procedure?]
[Then, I just need to trim the header and stuff. I don't know.]

[So what if I shoot myself in the foot? I still have the other one!]

[I could probably create a capture type of mecanism with a different lookup that doesn't search
lower levels.]
[Captures to make code more pure.]

[I found a way to implement [goto] elegantly (said no one)]

[The language is like water: it can take whatever shape you want it to. And because it can take
whatever shape you want it to, you only need to change the behavior of the LSP to contain to shape
of the language. That way it can behave as if it had types, without actually having types.]

[Or not? I don't know. I will have to see when I get to implementing plugins.]

[I could maybe call the capture procedure [with]? maybe [using]? though the second doesn't sound
right.]

[I just realized how insanely difficult these error messages are going to be...]

[Yeah, I'll probably to postpone the implementation of proper errors, since when procedures actually
compile, it will probably change anyway.]

[Anyway, I had an idea: procedures should have a head, body and foot. When you chain calls in a
newly defined procedure, these things get removed. I don't know how I will implement errors with
that, but whatever. I'm going to resist metadata until it's no longer feasible.]

[This would be so much easier if I could just add metadata...]

[Right, iteresting idea as well:]
"\x1b[58;2;255;0;0m\x1b[60mcurly\x1b[0mnormal"
[instead of making my code read. But idk, couldn't make it work with printf.]

[[proc] should be a wrapping, a macro? a wrapping over something, that does define the head and foot
of a procedure, just by default, using some sort of algorithm.]

[So [proc] should be able to detect but ahead-of-time? Or the LSP? Because otherwise, everything is
runtime...]

[Maybe I should rename [quote] to [text] and [symbol] to [name]? but what about numbers?]

[prelude, interlude and epilogue? nah, I don't have to be so fancy. I'm not a haskeller.]

[My [goto]s are actually quite lame, aren't they?]

[Another reason for [meta]:]
item [a] [test]
item [b] [test]
a == b
[this works because the language knows the type and can decide whether to call it or push it on the
stack.]

[Also]
a b 1 1.4142135623
[these value should know be in the hashmap, with the key [_], they should be in the stack, back to
back. Though, I don't know how the procedure knows to access the stack. Oh wait!]
ldr x0, [sp]
[for latest? it has to be in asm otherwise you'll waste time searching the hashmap.]

[hmm]
let [a] = 5
[[let] pushes [a] in the stack, [=] upserts in the hashmap.]

[if the head of a procedure is a single instruction, it will be easy to trim. Something like [bl] to
a procedure called [push] that takes a number as arguments, and scans said number of arguments in
the source code.]

[shouldn't forget to add [proc-len] and [debug-proc].]

[at this point, why not just make it stack-oriented?]
1 2 3 4 + + + 10 == [true]
a b c d + + + [also works]

[i should really do asm instructions proc; they are stripped of the register saving instruction whem compiled]
mov x0 #5 [moves number 5 to register x0; saves register info on the stack for later use]
init-asm [saves all registers on the stack?]
quit-asm [pop all registers on the stack?]
proc [] [
    mov x0 #42
    mov x16 #1
    svc #0
] as [test-exit]
test-exit [works as intented, but no need to save registers.]

[also, inline proc that inlines stuff]
proc [] [
    inline test-exit
]
debug-proc _ [print the instructions of [test-exit] since there is no [bl]]
[still, that means that some procedures within [proc] get executed?]

[another reason to avoid meta: it encourages stack oriented programming... or is that a plus? the
stack *is* fast.]

[inline asm should be as easy as possible]

[creating a programming language is such a skill issue. meanwhile computing can write code in
binary. pathetic.]

[I need a raw [item-in] that is unaffected by [layer-offset].]

[Ah shit, it's because [repeat] does create a new scope – that's why!]

[I've been thinking a lot about loops (as you do), and isn't [goto] the simplest way of doing it? I
mean, damn. It makes me gag having to say (write) this, but recursion doesn't make that much sense
for this programming language. This... Yeah, I don't know where I'm going with this. I need to
implement the assembly first, then decide.]

[[proc] is basically a mini-compiler.]

[You know... I could actually do [str == [a string]] – and I mean why not right?]

[Maybe I should do [struct], just not the typed kind.]
struct [Car] [
    [make]
    [model]
    [year]
    [engine size]
    [price]
    [color]
    [is-electric]
]
Car::new [test-car] [
    [Tesla]
    [Model S]
    [2024]
    0.0
    79999.99
    [Red]
    1
]
print test-car.make  [outputs [Tesla]]
print test-car.model [outputs [Model S]]

[I guess [struct] defines the [Car::new] procedure? And [Car::new] does:]
item [test-car.make test-car.model ...] [Tesla] [Model S]

[And then, we have this]
test-car.delete
[which deletes all the fields. I also remembers to free the strings? I don't know.]

[or maybe]
struct [test-car] [
    [make]        [Tesla]
    [model]       [Model S]
    [year]        [2024]
    [engine size] 0.0
    [price]       79999.99
    [color]       [Red]
    [is-electric] 1
]
[which does the same as the above code]

[hmm]
struct [Vector3] [[x][y][z]]
Vector3 [test] [1 2 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[or]
struct [test] [[x] 1 [y] 2 [z] 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[...]
struct [Vector3] [[x][y][y]] Vector3 [test] [1 2 3]
struct [test] [[x] 1 [y] 2 [z] 3]
[the second one is clearly more terse, but that's only because this example only does it once.]

[I could do both, like:]
struct [] []
object [] []

[Alright. I'm going with this. It looks too sexy not to.]

[Oh, and I'm dropping the [::new]. Don't know why it was there. I felt right, I guess. Rust muscle
memory?]

[Also, if I am very much following the prototype-based route. No OOP here pls.]
[then again, is there any point in doing something like [Person.clone]?]
[and can I nest structure?]

struct [Vector2] [[x] [y]]
struct [Vector3] [[inner] [y]]
Vector2 [test1] [1 2]
Vector3 [test2] [
    test1
    3
]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]

[...]
struct [Vector2] [[x] [y]]
struct [Vector3] [[y]]

proc [name args] [
    get 0 args as [x]
    get 1 args as [y]
    get 2 args as [z]
    strcat name [.inner]
    Vector2-in 1 _ [x y]
    Vector3-in 1 name [z]
] as [Vector3]

Vector3 [test] [1 2 3]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]
[this is hella scuffed... doesn't even have [.delete]]

[well, I'll figure it out eventually.]

_.err?

[I guess I could also have this:]
test.meta
[which is a list of the fields?]
[and you know]
delete-struct [test]
[which iterates over [test.meta]]

[bitwise instruction disassembler?]
00100010 & 00000110 == 00000110 ? [[is mov instruction]] []
[(rough example)]

[I guess I should do the REPL in C then.]

[Maybe the max line width should be 99?]

[I need to do string manipulation before I can do the REPL. Otherwise, I will be too scuffed.]

[Damn, that's right. I can't rename [.intValue] to [.int] because C is a pain in the ass sometimes]

[Even if a procedure ends in an infinite loop, or jumps to another procedure to finish, I should
still have a [ret] instruction at the end. Otherwise, there is no way of calculating the length of
a procedure.]

[I should try implementing this thing (😂) eventually. I think it's called UTF-8?]

[Alright. So I thought about this stupid shit for a while now, and this [ioctl] thing is now really
what I want. Instead of banging my head against a wall, I'll just disable canonical mode...]
[Shit, I just found out that disabling canonical mode requires me to use [ioctl]. Well that's
embarrassing. I should probably remove this piece of text... Later. Too lazy right now.]

[I should have to do this]
1 == 1 as [b1] 2 == b && b1 ? [] []
[[b1] should have been pushed on the stack, and the result of [2 == b] as well. [&&] would have
popped them.]

[I should add the ability to memoize procedures.]

[I should, I should, I should... I should stop saying 'I should'.]

[I should write a vim like text editor, where in normal mode, the cursor hovering over a symbol
executes said proc. And when the procedure get executed, there is a cool effect with colors showing
that the code is being executed.]

[Instead of [item-in], I could do [=+]]
=    [pi] 3.14159
=+ 1 [pi] 3.14159
[whatever.]

[wait, could [_] be the stack pointer?]
[when you lookup a value, you should really be getting a pointer to it. you know [table + hash]]
[wait no.]

[Okay, so I took a shower, and thought a little: I want procedures to be compiled. If I keep
implementing features the interpreted way, it will become harder and harder to migrate; and
honestly, runtime procedure compilation is one of the main features of this language. I have to get
to it.]

[I think I'm going insane. I don't how symbol can override the outer value... And why printf not
print until a newline is shown??]

[Maybe for the editor thing, the cursor also move along. When finished, it's in position for you do
enter another command.]

[I'm adding features as I need them.]

[Jupyter notebooks?]

[Just as there is a [push arg-count], there's also a [pop size] that pops the stack for a value of
a defined size, and assigns it to [_].]

[Damn, I don't know how to add things to the stack with all these function calls...]
[I need to think.]

[This may be a long shot, but I thing I need to rewrite the whole thing in assembly... Wait no, I
can just use -S!]

[Okay... I have to spend a long time trying to understand and trim the assembly code.]

[Dear lord... This is so hard. The more I think about it, the more difficult it seems to be...]

[You know what? One problem at a time. I'll start by figuring out how to read a file and then print
it.]

[I won't be getting very far without knowing how define malloc and free...]

[I'm going to do assembly in the new directory I created, but I will also do the interpreted
version. Instead of using the actually stack, though, I will create my own. If I don't do that...
My progress may lag too hard...]

[A lot of procedure have optionnal arguments?]
compile main
compile: [executable-type mach-o] main
[or]
item [args] [executable-type mach-o]
compile: args main

[heh.]
1u64  [x16]
42u64 [x0]
4 + syscall _
[skip [push n]]

[I guess I don't really need a distinction between [i64] and [u64]?]

[Shit, I was talking about push n and stuff, but how do I do this??]
syscall 1 [0]
[I guess I just put the pointer on the stack, and inside the [syscall] procedure, I'm extracting
the info... But that had to be at runtime. Otherwise it will be too slow.]

[[syscall] should be a macro for inline asm.]
mov x0,  0
mov x16, 1
svc 0
[^ too short for a procedure call.]

[I have to actually think about numbers.]
FFF:x
1011_0010:b
0o777:o
543:d

2134:1
2134:2
2134:4
2134:8

.2134:4
2134.4:8
[Okay. I think that's good.]

[also]
255:1 == -1:1

[it kind of looks like a ratio... anyway, I like how it throws the syntax of other languages like
rust on their head:]
let n: u8 = 42;
item [n] 42:1

[Maybe I should also allow this:]
item '[' [...]
[I don't know... exactly how I'll implement this, but it sounds like a fun idea.]
[I can even do this!]
item ' ' [...]
[Muahahahaha!]

[[defer] should execute in the opposite order.]
[Maybe have a fraction struct?]
[I need [parse] to be more reliable.]

[I could do this:]
item [env.next] [print "New code\n"]
[So when EOF is reached, the app continues.]

ch [filetype mach-o]
compile: _ [print "Hello, World!\n"]

[I feel like I can just do arbitrary precision.]
item [x] 198412847120581251251209851281204981240912840192812057250129851029812308123409128
[can't I just divide this into multiple longs?]

[I should use i32 for default int, and f64 for default float, like rust.]
[I need to make my code libc independant...]

return 5 _

[Is there a way to make a syscall macro in C?]

proc [vector] [
    Vector3.y vector
    print "y = %i\n" _
]
[or maybe I just can't pass an struct to a proc?]
[or maybe i don't need structs, just arrays?]
[array programming?]

[btw]
print [Hello, World!\n]
print "Hello, World!\n"

item '"' [...]

get-at x 4 vec1

[The stack is increasingly more difficult without [meta].]
[These vrariable length types are impossible to work with...]
[I either do meta or things i push on the stack are the same length.]
[Maybe low level should be more stack oriented, while high level uses the hashmap?]

[Also, easy way to convert from one base to another.]
print "%i\n" FFF:x

[I should learn learn "vfprintf" and "strtox"]

[Inline asm should only be doable in a "do" block, or similar, like in a procedure.]
do [
    mov x0,  0
    mov x16, 1
    svc 0
]
[^ this works because the block is first compiled, then executed as binary.]
[while this doesn't:]
mov x0,  0
mov x16, 1
svc 0
[because the registers are messed around with before each procedure call.]

[sure, you could ldp every register before the call, and stp after, but that's such ugly solution
to the problem... just use a do proc at the top level. In a procedure, you don't need since
everything is compiled first.]

[Actually, stack-oriented programming may not be possible...]
1 == ret as [b1] 2 == ret && b1 ? [] []
[for this to work, it would need to not take any arguments...]
1 == ret 2 == ret && ? [] []

[The logical way to approach this, would be to convert the symbol to the pointers or values in the
hashtable.]
[But then I would be using the heap an awful lot...]
[That's probably it, for now. I need to focus on compiling, anything.]

[You know, everything was smooth sailing until I tried to compile. I made so much progress...]

[I wonder if you could implement significant whitespace using this:]
item ' ' [...]
[Just to be unnecessarily evil.]

[also]
proc [str1 str2] [
    print str1
    print str2
    print str1
    print str2
]
_ [Hello, ] [World!\n]
[it would be easy to malloc these strings, but they will on be used in this procedure...]
[wait...]
_ str1 str2
[so they should be pointers??]

[The ideal would be to neither put them on the stack, nor malloc them. I mean, they are already
loaded in memory: "token[start]"!]
[In other words, I should change print to not be null terminator dependant. At least for string
literals.]

[Then again... (I keep going back and forth) I guess I could also insert the string within the
procedure... Because, I mean, what if you have a procedure that returns a procedure? And the scope
of the procedure call gets popped? I need to make my procedures as portable as possible! And in any
case, I plan to make every part of my binary either executable/readable or writable/readable. Or
not? Maybe I should have the minimum? Whatever, later.]

[Okay, but about this?]
_ [Hello, ] [World!\n]
[where are the strings?]
[how should I always write a fixed number?]
[the [write] syscall doesn't check for the null terminator anyway. and I will need to length then.]
[In that case, I only need to push the pointer to the start of the quote on the stack?]

[Maybe I should data after [ret]?]
[If i don't put the string after [ret], i will have to [b]...]
[But how will I now to compile the data as well when compiling to an executable file?]
[Decisions, decisions.]

[Wait, if I malloc something, then mmap it, then free it, will it still be mmap-ed?..]

[Maybe I could push stuff on the stack, and then when I compile, I put the stack in a readonly
section?]

[Holy shit!]
label [n]
[is equivalent to]
adr x0, 0
[... I think.]
str x0, [x29]
add x29, 8
br x0
[hmm, needs testing]

[I shouldn't forget the idea that procedures never return, instead they call eval on the next
statement.]

[Really like this syntax.]
0 ~ print [%i\n] _

item ' ' end++
[I'm so funny aren't I?]

[prepend on item names?]
module [hello]
item [x] [Hello, World!\n]
[for other module]
hello.x
[this is really just string concatenations:]
module-name ++ "." ++ item-name
[something like that]

[Some instruction parse the arguments, then put on the instructions on the stack, others parse
arguments, evaluate them, then put the result on the stack. The former are procedures, the latter
are macros.]
[There really shouldn't be any syntactic difference between the two...]

[hmm]
1 == ret 2 == ret pop && _ ? [] []

[runtime compilation (lol)]

[The LSP throws an error when you're about to call a non-executable part of memory. The program
still runs though.]
[Do you bootstrap the LSP as well?]

do [
    proc [] [
        print "hello"
    ]
    defer [free _]
    _
]
[but you can't do that, because you're using mmap for this...]
[i should try implementing it anyway. some way or another.]

[Need macro push and pop]
push(int, value);
pop(int);

[I don't think I need [adrp] for c. I can trim it. Or maybe it's already trimed?]
[I should test [adrp] with inline in c.]
[[adrp] will be such a pain in the to deal with...]
[like how many bits is printf %x ptr?]

[The interpreter should avoid [malloc] as much as possible.]
[I'm still amazed I'm writing a lisp without really knowing lisp.]
[...]

[I could just chain procedures and never assign the first one, in the top scope, for lambdas; [as]
within second proc.]
[Maybe the next push pushes to _, but before that pushes whatever _ had to the stack?]
[I'm thinking I really need to consider a size value attached to a variable...]
[Maybe I don't need ''.]
item [c] [Q]
[what if [c] is a pointer where token[start] == 'Q'?]
[maybe i don't need to malloc a new scope (it would make error messages so much easier if yes]

[In the asm interpreter, I could just store globals in the stack and access them whenever I want,
but for the C interpreter, I need a weird workaround.]
item [str] [Hello, World!]
do [
    ch str & 0xFFF
    movz x1 [_ 0]
    ch str >> 12 & 0xFFF
    movk x1 [_ 1]
    ch str >> 24 & 0xFFF
    movk x1 [_ 2]
]
[something like this?]
[but I need to change the notation...]

[hmm]
mov x0 3
bl PUSH
[is equivalent to]
mov x0, arg1
mov x1, arg2
mov x2, arg3
[?]
[so]
mov x0 3
bl PUSH
svc 0
[is all you need?]

[okay, what is the notation?]
mov [1] [3]
[move x3 into x1?]
mov [0] 77
[move #77 into x0?]
mov [0] [77 1]
[move #77 << #16 into x0]
mov r v
[move value with possible shift pointed to by symbol [v] into register pointed to by symbol [r]]
mov r [v s]
[move value [v] with shift [s] into register [r], each pointed to by symbol]
[i guess this works]

[i still have no idea how I will do arguments...]

[I could also do]
item [x0] [0]
item [x1] [1]
[you know, to make it more like actual asm]

[wait]
mov [0] [[1] 1]
[i guess that works]

[I think I'm giving myself too much of a headache. A lot of these are aliases. movz will never move
from one register to another.]
[In other words, I can just use integers as inputs.]

[There's a variable called this.]
print this [prints the entire code of the first file.]
item [this] [] [does nothing]
item-in 1 [this] [] [breaks the program, because the source code got deleted]

[oops, just remembered there is w0 and x0.]
[maybe]
movz 0:4 2
[?]

[wtf, why do you need w0? you're moving a halfword??]

[Maybe I should always use exponential sizes?]
1:0 [char ]
1:1 [short]
1:2 [int  ]
1:3 [long ]
[2 ^ x * 8 = number of bits]

[i shouldn't forget about this]
printf("%.5s\n", str);

proc! [] []
[instead of]
macro [] []
[? well, it's the same length so whatever.]

[There should probably be a register reserved for the [token] value.]

[Also, nvm for "", I need to be better than this.]
print "Hello, World!\n"
[...]

[wait a second]
[a] = 2
[I can do this because the quote is ignored, and [=] can backtrack... but do I want to? probably
not.]

[Okay.]
proc [text len] [
    write 1 text len
]
proc [fd buf nbytes] [
    movr 9 0

    ldr 0 9   [fd]
    sub 9 9 8
    ldr 1 9   [buf]
    sub 9 9 8
    ldr 2 9   [nbytes]

    movz 0 fd
    movz 1 text
    movz 2 len
    movz 16 4
    svc 0
]
[or [ldr] with offset. idk]

[Do you like driving without a seatbelt? Do you like being a menace to society? Well this is the
language for you! No rules. The only limit is your imagination, and your ability to avoid law
enforcement...]

[maybe I should have a stack for executables?]

[pop]
0 < val 65535 > val . && _
0 val < 65535 val > &&
[it's either [^] or [.] or whatever else]

proc [] [
    0xf9400508
]

[need a [debug-stack] procedure.]

[I can actually implement dependent types... I mean, I just learned zig has them with comptime
right? Like damn.]

[Then again, maybe I want more than that? Because some search algorithms need sorted list as input,
but what, I need to check whether the list is sorted everytime? If it's a runtime check, it becomes
expensive real quick... Since there is no way to attach the fact that list is ordered onto a
symbol, I can't prove that a procedure will always work. Not without types.]

[Also, I really like the fact that you can write proofs with dependent types. It's so fucking
cool!]

[Then again... 'Ordered' could just be a wrapping over a List. You can't pass a List instead of an
Ordered argument, but you can pass an Ordered to a List... I guess List is the wrapping here.]

[Honestly, I will probably implement [meta]. Doing [get-at pos size from] is too long. But again,
I'm going to try to make as far without it as possible. I need to see what it looks like.]

[Alright, suppose I do have to implement types:]
item [x] 12
typeof x print [%s\n] _ [outputs [Number]]
type [Number] [u8 u16 u32 u64 i8 i16 i32 i64]

[but how do you express fixed size lists?]
array [x] [1 2 3]
typeof x print [%s] x [outputs [Array Number 3]]

[So I guess]
x == [
    [value] [1 2 3]
    [type] [Array Number 3]
]
[[type] doesn't have to be a string. It can be pointers to strings, and depending (lol) on the
pointer, the size of [type] can vary. But how do I know which types take in arguments?]

[wait]
type [Array inner-type length] [Array inner-type length]
[it seems redundant, though.]

[but then you have to say everytime a procedure uses IO and stuff...]
[and what happened to this]
u32 [x] 11

[A big reason to have types, that it makes operating on fractions so much easier.]

[Need to think about this.]
[So, in [proc], the procedures have something like [reduce] called on them, and the instructions
are pushed on the stack without being evaluated. On the top-level, they are pushed as well, but
popped and evaluated afterwards. Okay. But what instructions are pushed on the stack? If you define
[write] for example, the instructions that are pushed on the instructions pushed on the stack are
the instructions  for taking arguments, and then pushing instruction again with thoses arguments
hardcoded to push on the stack as well. So when [write] has taken arguments, you now have a
procedure that pushes the same thing on the stack everytime, and you can evaluate thoses
instructions or insert them inside another procedure. Because you can insert them inside another
procedure, you can't just push the data at the end of the procedure (after ret). You need to
hardcode it as mov instructions or mix code with data, do a ldr offset from pc where you put some
data, then jump the data with a branch instruction... This is going to be hard to implement. Not
just for [write] but for everything.]

[Okay. I wrote a lot.]

[You know, it's a little funny to think about safety in a language that, a its core, is more unsafe
than [strcpy].]

[If I do something like Elm, I will probably remove h1, h2, etc. And just have text... Then again,
accessibility and all that...]

[Depending on the types, a procedure can have a different number arguments?]
[Types should really be string, a least at first.]

[Functional programming is, to my dismay, seeming more and more appealing.]
&& < 0 val > 65535 val          [functional]
0 < val as [b] 65525 > val && b [current model]
0 < val 65535 > val . && _      [current with pop]
0 val < 65535 val > &&          [stack oriented]
[functional and stack oriented are the clear winners here]

[I understand that I want to make this programming low-level and such, but some things are
objectively better than others. Once I finish implementing a working procedural model, I will try
types, then funcitonnal, and compare the implementations.]

swap str + 1 str

[Another good reason to have types: errors are so much easier to do.]

[The language has to be built from the ground up with [x] feature, otherwise a plugin would be too
awkward.]

[Should I make it so that it only compile after the first use? That might solve the recursion
issue.]

[In functional, I could use [_] as a discard:]
_ write 1 [Hello, World!] 13
[write doesn't return anything this way.]

[Division by zero should equal zero, like in [Gleam]]

[Maybe I can do everything lazy, and where it only compiles when function is called?]
item [f] [print [Hello, World!\n]]
print [%s\n] f [outputs [print [Hello, World!\n]]]
[Of course, [item] does not malloc the string like before. It only get a pointer to the start of it
(token + start).]

item [f2] [f f]
print [%s\n] f2 [outputs [f f]]

[but]
f2 [will compile [f f] and therefore [print [Hello, World!\n]] as well]

[also, when printing a function, you won't just be getting the function body. you still need to do
the argument logic, and all that.]
[and let's not forget]
func [f x] x
[is equivalent to]
item [f] fn [x] x

[still, that means that everything starts of lazy?? this might not work, since we need intrinsics
to define the rest... damn, thought I figured it out for a second there!]
[maybe recursion will forever be off the table...]

(define [f x] [
    print [Hello, World!\n]
])
[maybe I should just give up and do it like this... seems cleaner at this point.]

(print [hey])

[wait, what about function with not arguments?]
(if (< 4 10)
    [f1]
    [(f2)]
)
[i suppose that works.]

(define [f x] [(
    print [Hello, World!\n]
)])
[lol, this is worse than lisp.]

[no, a thing I really like about my language is that I can [scan-token] and [copy-token] and
[parse] or none of the above, without any reservation about what actual arguments the caller gave
you. in lisp, you're pretty much forced to take the arguments within parentheses. it's a tradeoff
with its merits and demerits, but I prefer it.]

[Suppose I implement the functional style, variables should also be functions with no arguments,
that always push the same value on the stack.]
item [f] lambda [x] [print x]
func [f x] [print x]
[ah, that brings back memories. right, if I do this]
item [str] [Hello, World!\n]
[how do I know that it's a string or function?]
[and so one of the big reason to have functional style is thrown away just like that.]

[i guess i could be more lispy?]
define x 5
define [f] 5
print x [outputs 5]
print f [outputs 0xffffffff (pointer to function)]
[wait, how do you call?]
print (f) [outputs 5]
[hmm, so like the outer scope doesn't need a parentheses?]

print f [outputs 5]
print ptr [f] [outputs (pointer to 'f')]

[wait]
(define [f x] [
    print [Hello, World!\n]
])
(f 5) [outputs [Hello, World!\n]]
f [outputs [print [Hello, World!\n]]]
[but how would that work?]

[no]
(define str [Hello, World!\n])
(define [f x] [eval x])
(print str) [outputs [Hello, World!\n]]
(f [print str])
[I have no idea.]

[I don't even know why I'm exploring this shit... Man, it was so much easier when I was just interpreting.]

[Maybe I could invert it?]
define str [Hello, World!\n]
define [f x] [eval x]
print (str) [outputs [Hello, World!\n]]
f [print str]
[somehow, that's kind of nice?]
[although]
print $str [outputs [Hello, World!\n]]
[no reason to use parentheses when it's not a list]

[or]
define str [Hello, World!\n]
define [f x] [eval x]
print str [outputs [Hello, World!\n]]
f [print str]
print ptr [f]
[every symbol is a function]

[I like how I'm basically pushing the problem from one place to another.]

[parentheses will never be an option, because they will always be more verbose than procedural,
losing the motivation to go for a functional style.]

[The only serious alternative is]
print + 1 2
print ptr [+]
[against]
1 + 2 print _
print +
[I see. Procedural can be much shorter.]

[The really beautiful thing about procedural is how you don't need an AST; everything is just
text.]
[But also, how you can actually implement functional in procedural.]
[I feel like implementing procedural in functional would be a pain though.]

[maybe]
func [] []
proc [] []
[each parsing arguments in different ways?]
[but the inconsistency could drive you mad...]
[but it's similar to [macro] too?]
[...]

[no, [func] requires type metadata; [proc] does not.]
[or rather, the way variables work would have to change for the two, and the only way to make the
behavior consistent is to have metadata on variables.]

[In the long run, functional may be more useful. And I also, need types. The key thing is to still
use the procedural model, but parse stuff differently. I want [scan-token] and the gang.]

item [x] [hello]
item [x] fn [] []

[I guess [fn] does compile, but only partially, and it compile the instructions to compile the rest
of itself?]

[but then again...]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[one is longer, sure, but it makes more sense.]
[the other is simply not text based.]

[for god's sake! this is such an impossible problem!]

[another reason not to fully compile everytime, is faster runtime. otherwise, you would have to
compile every imports everytime you run the app. this makes it so you only compile the things you
actually use.]

[Is recursion even possible without types? How can you tell it's the end of an array?]

[I should create an actual lisp]
[Probably built on top of python this time. See how far I can get.]

[I should probably put the compilation on hold so that I can implement the rest of the language, so
that I can then objdump the assembly and have a better idea of what to do. Also, I need to avoid
using the standard library.]

[Just had an idea:]
rand-proc-call as [val err]
[so like, instead of having [rand-proc-call] define variables that could clash with the lower
scope, we just put the stuff on the stack, and [as] can assign multiple values from the stack.]

[I should try to do C structs without [struct].]

[I should try something like [do-set]:]
proc [] []
[here [_] is know a pointer to an executable part of memory that will call [do-set] on the start of
the procedure block, compile it and reassign [_] the compiled code.]

malloc Vector3
[[Vector3] is the size of the structure.]
[wait no]
malloc Vector3.size
Vector3 [1 2 3]

[Functional may make more sense.]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[like what? does procedure assign [_] as well? Was it not supposed to be in the stack?]
[no, this is small]
proc [x] [print x] as [_] _ [input]
[or]
proc [x] [print x] . _ [input]
[as always, very verbose.]
[still I need return values to be on the stack as that is so much easier to work with for multiple return.]
[or maybe]
proc [x] [print x] ; _ [input]
[I kind of like it?]

extract [_ err] sp
[similar to [as] but takes pointer?]

[when I do the documentation, I really need it to start with:]
exec 16 [very-long-hex]
[which of course prints [Hello, World!\n]]

[maybe meta is just a long, but that long can be anything, and the procedure decides?]
[[size], [meta] and [value]:
if [meta] is 0, then the symbol is an int, float, or whatever;
if != 0, then it's a pointer to something and meta is size of [something]]

[no, int for size and int for meta, to 64 bit total]

[i should implement a meta circular evaluator.]
[just to remind myself why I created this language,
fix in lisp: right-to-left, parentheses, abstraction, nesting]

[i need to list what types to implement, and features those types allow.]
[like every variable has metadata to improve errors, and a size for the value, and a nullable size
for referenced memory, with maybe whether or not that memory is executable?]

declare [val1] [int]
declare [val2] [Array int]
[i don't know.]

[the reason no one made this language is because of how unsafe it is...]
[i think i read somewhere that mmap allocates an intire page every time? in other words: it's
extremely inefficient...]

[There's a sort of shit to my language, that wasn't there when it was just interpreted.]
proc [] [
    1 + 1 ;
    print [%i\n] _
]
[how the fuck do I translate this to machine code, and how the fuck do I remove the need for
symbols? like what, I lookup a hashtable in compiled/optimized code? I need to be better than
this.]

[Maybe I should drop the hashtable? I mean, the only reason I use it is because chatGPT said it's
typical? But then [malloc] is bad. Also, I now have the stack and want to use it to put values in
it.]

[Also, I really need to learn the io programming language. I'm really thinking objects to the
language, because with types, it's just a waste not to have objects. And we can have stuff like
this:]
object [String] [
    [ptr] 0
    [len] 0
]
new String [str] [[Hello, World!\n] 14]
[... so awkward. need to think this through. Also, still not set in stone that I will use types and
objects. I will resist it till the end!]

[I can't continue programming until I figure this out:]
proc [] [] _
[vs]
proc [] [] ; _

[wait a second...]
proc [] [
    ch [hello\n]
    print _
]
[this isn't a hard problem? ... I just do as normal, but when it actually compiles, [print]
compiles, it doesn't compile with [_], but with the absolute value that of [_]. Am I for real? Is
it really that easy? Am I missing something?...]

[Also,]
proc [] [] _
proc [] [] as [val err]
[are both valid?]
[wait, no. [proc] needs to have a call that assign [_] at the end. like [return] or something.]

[I suppose [ch] does not compile, but is already compiled? That's why I don't have to worry about
it?]
[Still, that means that [push] needs to work differently...]

[If I do modal programming, I could do it where things are both pushed on the stack and on the
hashmap? I call the same procedure, but the procedure behave differently depending on the global
state.]

[Also, I feel like I can still do currying. Everytime I take an argument, I push something on the
stack, and stuff, except the thing that I pushed is a procedure that take the remaining arguments,
and then returns the actual body of the procedure.]

[Types, types, types!]
my-list to-iter
[make like rust iterables? [.next] I mean. And more importantly, lazy and infinite.]
0 -1 iter [is an infinite data structure?]
map [x] [x * x]

proc [] [type _ == [Vec 8] ? [logic] [Iter]] as [a-way-to-do-overloading]

[The two most basic types are Code and Data. All other types are derived?]

fork ? [] [
    print [Hello, Async!\n]
    exit 0
]

[Reference type]
item [str1] [hello]
item [str2] [hello]
str1 == str2 [true]

ref str1 as [str1]
ref str2 as [str2]
str1 != str2 [true]

[Everytype is by value by default?]
[Like, we have arbitrary sized integers, but with strings too. Strings are just very, very long
integers. So they should behave the same.]

[I should find a way to do a hashmap without malloc... Or just put everything on the stack?]
Variable :: {
    name : String
    type : String
    size : i32
    value: Any
}
[I don't know...]

struct [Variable] [
    name String
    type String
    size Number
    value Any
]
[Type could also just be [Structure]]
[I guess [item] should then push this on the stack?]
[Also, how do lookup in the outer scope? Also also, I guess I can't do [item-in] any more...]
[No, the first variable of a scope is basically just metadata about the outer scope.]
[Wait, I don't even need [item-in]! When the scope is gone, all my variables are still there! I
just write over them, or be clever and write them where they should've been to begin with!!]

[Okay. This is one of the most interesting ideas I've had in a while.]
[I don't even think it's that much slower than a hashmap, despite being linear and stuff.]

[But happens here?]
1 + 1 dbg
[is [name] equal to null?]

[Also, an [env] could just be another variable on the stack, except its size is the size of every
other variable combined?]

a = 2 [is possible because] push a [is equal to]
Variable [a] [Undefined] 0 []
[or something like that]
[and then, we simply reassign the value to 2.]

[also, when we lookup the stack, we go from the of the stack.]
[Damn! Just realized how easy looking up into multiple environments is with this model! Damn I'm smart!]
[Also, if there is a [stack] variable, it is in the bottom of the stack everytime.]
[Also also, shadowing.]

[Honestly, it's probably nowhere near as fast as a hashmap... thinking about it for real, the
bigger the application (and they get pretty big), the slower it will get, exponentially.]

[Still, unlike a hashmap, I can define variable length values – scrath that. In a hashmap, I can do
it as well.]
[Wait, what about pushing pointer to the procedure you will use a lot in the start of a scope...]
[No no no. Before that, isn't it the job of the programmer to ensure that the stack has no bloat
that make the linear search take forever?]
[Even before that! Procedures are compiled to begin with, so it should take that long?]
[... Or maybe I should have multiple stacks?]

4
[==]
Variable [_] [Number] 3 4

[[Mutable] and [Immutable] types?]

[Maybe [import] is a procedure that returns variables on the stack?]

[If the language become so stack centric, should everything be a function that return their value
to the stack? Even variables?]
[^ Functional refuses to die.]

i32 [name] 1
[is equivalent to]
Integer [name] 2 1
[where 2 is the size]

[don't forget]
malloc(typeof(Entry) + entry.size)
[or something like that.]

eval fn [] []
[maybe [_] is latest stack variable?]
[damn, don't even need [return]]

[since every variable has a type, you don't need to "call" a variable. but the syntax makes it look
like you do.]

[both item and as work for declaring a function]
let [f] fn [] []
fn [] [] as [f]

[discard]
let [] func-call

[[eval] is called on the arguments of a function...]
[I should give crafting interpreters another chance. The type system is a real pain in the bum.]

[overloading]
fn [arg1] [
    string? arg1 ? [stuff] [
        throw [Unsupported type: %] type arg1
    ]
] as [overload]
fn [arg1] [
    number? arg1 ? [stuff] [
        overload arg1
    ]
] as [overload]

[I don't even need [item-in]...]
[type [Struct Vector]?]
[objects and templates? or prototypes?]
[but a prototype is just another object...]

item [val] do [1 2] as [val2]
item [val] do [1 2] next [val]

[maybe every variable should have a padding, to allow for arbitrary sized values?]
[you can call clone on any object?]

[damn, i can do] var . proto . type
value size [where [size] is just another overloaded function that check the type of the value in the stack?]

[this just doesn't work]
a == b || b == c

sqrt 9 [returns special type? like an [Or] type that means the value can be any of the list]

[has to be + a b for constexpr]
let [VALUE] + + 1 2 + 3 4

[interesting: using this model, there is no mutation from inner to out block...]
[or not? how do I do globals?]
[maybe I should let and set like other programming languages?]

[oh shit i can do static methods...]
Object [
    [name] [test-object]
    [func] fn [] [
        print [This works!\n]
    ]
]

[eveything is not a function, but everything behaves like one, syntaxically]
[everything is a "function", including types]
[I should do [functions.c]]

[Maybe there shouldn't be a distinction between code and data... You're gonna have to call a
function anyway, to push the data on the stack and stuff...]
[memcpy and stuff.]
[everything behaving like a function but not really being one could be the best way to implement
lambda calculus on a computer...]

[I may be giving up on [proc] too quickly. I feel typeless is pretty much dead now, tough.]
[Still it is a fact that procedural made me agonize over a few things. – Honestly, I should be more
open to experiment with shit, even if it's not going to bear any fruit.]

let [ret] func-call
ret match
    [Some a] [print a]
    [None  ] [throw [Failed to unwrap monad.]]

length list
clone vec

[Initially, I wanted functional. I should try it. If it doesn't work, then too bad.]

let [C] import [libc]
let [main] fn [] [
    let [a b] i32 3 i32 4
    let [result] C.add a b
    print [% + % = %\n] a b result
]

let [true ] fn [x y] [x]
let [false] fn [x y] [y]

[I should have a function that takes piece of code and debugs it step-by-step]
debug [
    print [Hello, World!\n]
]
[Similar to a GDB or LLDB breakpoint, it halt the execution of your code to enter a TUI debugger
for the requested piece of code.]

let [func] []
do [
    set [func] fn [] []
    defer [munmap ptr-to [func]]

    [fine]
    func
]
[will segfault]
func

[do I really need fexpr?]
[I mean, I just need to pass in a string to a normal function. No... Every function is an fexpr
(or macro) by default; they just choose to always evaluate the arguments. And you can still use
[macro], but it's like really deep in the language, and not idiomatic, I guess.]

let [c] char [🤓]
             [  ]

let [a] 123
let a = 123;

let [a] i32 123
let a: i32 = 123;

let [io] import [System/IO]
io.print [Hello, ]
use import [System/IO]
print [World!\n]
use [
    import [System/String]
    import [System/Syscall]
]
import [System/String] as [text]
print text.reverse [Hello, World!\n]

[I should probably make it so that everything in the language follow this form:]
let [symbol] [something]
[like this]
let [number] 4
let [string] [Hello, World!\n]
let [function] fn [] [
    print string
]
let [person] Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
let [person2] clone person
let [person2.name] [Jane Doe]

[also, I just had a brilliant idea for objects:]
let [sys] import [System]
[is problematic because [import] returns an object, and how is [sys.something] defined then? Well,
[let] manages that. It checks if the value of the assignement is some sort of object, and if yes,
does seperate assignements for all the fields. Clever, right? Right??]

[wait a second.]
let [] import [System/IO]
.print [Hello, World!\n]
[right?]
[no, it shouldn't work like that...]

[Maybe take the zig route?]
let [std] import [std]
let [print] std.debug.print

[Still, I wanted [import] to work a bit like [load]]
let [lib] load [lib.txt]
let [sys] import [System/]
[or something like that]

let [Vector3] fn [x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [vector] Vector3 1 2 3
println vector.x

[I should try to implement dependent types, since this language already blurs the lines between
compile-time and runtime. Also, it's a good way to learn.]

[By the way, this language probably won't have any tuples, since those are basically just
structures.]
let [tpl] tuple [1 [Hello, World!\n] 1/3 Vector3 1 2 3]
let [tpl] Object [
    [0] 1
    [1] [Hello, World!\n]
    [2] 1/3
    [3] Vector3 1 2 3
]
println tpl.1 [outputs [Hello, World!\n]]
[then again... they are objects, but [tuple] could just be a shorthand (macro or function) to avoid
naming things inside the object]

[Also, enums]
let [] enum [
    [Monday]
    [Tuesday]
    [Wednesday]
]
println .Monday [outputs 0]
[I guess this is similar to a tuple. That is to say that it's just some macro for shorter object
initialization.]

[People talking about arbitrary compile-time execution; I talk about arbitrary runtime compilation.]

let [func] fn [] []
let [func] ptr-to [func]
let [func] val-of [func]
func [works]

print type-of Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
[will output:]
[Object [
    [name] [String 10]
    [date-of-birth] [Date]
]]
[or something like that]

[I should do Elm style, that also compile to html/css/javascript]

let [n] 10
let [test-fn] fn [n] [
    while -- [n] [
        println n
        n
    ]
]
let [factorial] fn [n] [
    as [arg1 arg2]
    while != arg1 n [
        * arg1 arg2 as [arg1 arg2]
    ]
]
test-fn n
factorial n

[hmm.]
[maybe everything should be an S-expression...]
let [test] ? condition [
    do-something
] [do-nothing]
[yeah, this code is impossible with the old model.]

let [condition] or = 1 2 ≠ 2 2

[Maybe I should just use a VM. The only difference is that the vm is for arm64 assembly?]
[Man, I wouldn't have this headache if the OS just allowed me to make things for writable and
executable.]

ls | sort-by [size] | reverse
[is there a way to implement this?]
[maybe I should reconsider the very first approach]
reverse sort-by ls [size]
ls push [size] sort-by reverse
[no, if I wanted multiple return values, I can't]
let [value1 value2]
    reverse sort-by ls [size]
    where ls [> size 1kb]

[maybe it's just a macro?]
ls | sort-by [size] | reverse
[is equivalent to]
ls ; sort-by _ [size] ; reverse _

[Maybe there is a stack type and a heap type?]

[Pattern matching?]
if let [value] dup func-call [
    debug value
]
[[dup] for duplicate... or should I overload [clone]?]

[[mut] instead of [set]?]
[because [set] was paired with [get] for array assignment and retrieval.]
[or [set] could just be overloaded.]

2.0
let [number] print [number: ]
println number [outputs [number: 2.0]]

[I guess floats should have a precision field so it actually prints [2.0] and not [2.000000]]

clone value
length value

[I forgot: modal programming!]
ls | reverse
[[ls] pushes an array of characters onto the stack. [|] changes the mode to [Piped]. [reverse]
looks at the mode first before executing.]
[Then again, maybe every type can become piped?]

let [_] last-stack-item
[special type?]

[[=] vs [==]]
[value vs reference]
let [str1] [test]
let [str2] [test]
println =  str1 str2 [outputs [false]]
println == str1 str2 [outputs [true]]

printl [vs] println [?]

[Oh mother fucking shit!]
compile opt [
    [filename] [Terminal]
    [filetype] [ELF]
] [main]
[^ an [Options] type!]

[I will probably still have a [return] function.]
let [print-unsigned] fn [number] [
    if < number 0 [
        return Error [Number too small.]
    ] []
    printl number
    return []
]
let [e] print-unsigned -1
if != e [] [
    throw e
] []

0 ~ print [%i\n] _
0 ~ print [%\n] _
print [%\n] ~ 0
print ~ 0

if condition [
    func-call 1
] [
    func-call 2
]

print 1 \n
let [\n] fn [] [
    print [\n]
]

print [\%] [outputs [%]]

[zig is great, yeah, but I feel like I want this language to take more after jai]
let [items] Array [
    ptr-to [print]
    ptr-to [let]
    ptr-to [\n]
    ptr-to [ptr-to]
    ptr-to [Object]
]
for items [print it \n]

[hmmm, [[]] made sense before, when I had [item-in] for return values, but now, not so much.]
let a 2
let str [Hello]
let [push-str] [[ world]]

[become more lispy by the second. wait till I add this revolutionnary feature called
((("parentheses")))]

[lispy formatting]
let [render] [
    fill-rect proj-rect proj-x proj-y
              unpack-color PROJ-COLOR
    fill-rect bar-rect
              unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
           fill-rect target-rect it
                     unpack-color TARGET-COLOR] []]
]

[this might be better; more consistent with the [for] loop's format]
let [render] [
    fill-rect proj-rect proj-x proj-y
        unpack-color PROJ-COLOR
    fill-rect bar-rect
        unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
            fill-rect target-rect it
                unpack-color TARGET-COLOR
        ] []
    ]
]

[or all in one line; but hard to read]
let [render] [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool [if ! it.dead [fill-rect target-rect it unpack-color TARGET-COLOR] []]
]

[I suppose lispy formatting will eventually grow on me, like vertical alignement, but right it's
either the second format or all in one line. For all in one line, I could just assign to a variable
if it gets too long. I believe this is the pythonic way of doing this.]

[Also, I don't have to worry about readability like before, since with the new type system, syntax
highlighting will be much better, probably.]

let [func] [
    func1 func2 func4
                func5
          func3 func6
                func7
]

let [func] [
    func1 func2 func4
            func5
        func3 func6
            func7
]
[yeah... the second one is hella ambiguous.]
[as ugly as it looks, the first one is objectively better.]

[no, if I multi-line a function call, I do it the C way.]
func-call
    func-call
    variable
    func-call

func-call(
    func-call(),
    variable,
    func-call(),
);

[The formatting problems only occur when I push the first argument on the same as the function
call. If I don't do that, then all is good.]

[[dup] vs [clone]]
[dup: pushes a copy of the value attached directly to the symbol; like numbers, floats, and
pointers.]
[clone: clone value being referenced by symbol; like Arrays, Objects, Strings, and things pointed
to by pointers.]

[another reason to do it like this]
let a 2
++ a

[what about reassigning [let] and [++]?]
[I suppose I just have to not use them for the reassignment? Like how [let] and [++] where
initially assigned?]

[It's basically recursion vs easy overloading...]
[But the minmax algorithm is a pain in the ass without recursion...]

[The same way a function gets called when [do] is called with it as an argument, should an [Object]
expand to just the fields?]
fn [x] [print x \n] [Hello, World!] [outputs [Hello, World!\n]]
Object [func fn [] [print [Hello, Again!\n]]]
func [outputs [Hello, Again!\n]]

[Wait, this may be a way to do multiple assignment?]
Object [
    [var1] 1
    [var2] 2
    [var3] 3
    [var4] 4
]
print var2 [outputs [2]]
[Interesting. I should consider it seriously.]
[Granted, you can no longer do this:]
fn [] [] as [func]
[But so what? You're not supposed to anyway.]

import [System/IO]
print [Hello, World!\n]
let [io] import [System/IO]
io.print [Hello, Again!\n]

[holy fuck, I don't even have to use [use]!]
let [func obj] [
    print obj.var-within-obj
    obj
    print val-within-obj
]

[Damn, nevermind. There's a discrepancy between returning an object and exposing it's fields.]
let [func obj] [
    print obj.var-within-obj
    use obj
    print val-within-obj
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[There also another problem...]
let [arguments] [
    1 2 3
]
Vector3 1 2 3
[vs]
Vector3 arguments
[vs]
Vector3 arguments [] []

[that is to say, should a function know how many arguments an argument actually is?]

[maybe it's not that bad? it's a question of [use] vs [return]...]

[imports]
use import [System/IO]
import [System/IO]

[Object initialization]
let [Vector3 x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[multiple variable initialization]
use Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]
Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]

[and functions]
do fn [x] [print x] [hello]
fn [x] [print x] [world]

[I guess function returns are not exactly related to Objects returning...]

[oh shit. suppose functions do have meta data concerning argument count.]
let [func] print [Hello, World!\n]
let func print [Hello, World!\n]
[the first one is lazy, the second one is eager.]

[maybe I can use that to mix in eager and lazy in a function?]
let [func x] do [
    print x

    [this has to be function, since [x] is not known yet.]
    let [value] + x y

    [this is basically function composition.]
    print value
]
[it returns a string if I don't put [do]?]

[I should consider function metadata more seriously.]
for items print it
for: item items print item

[I guess macros, which is what all functions are built off, would need to figure out the function
metadata.]

let [fib n]
    if or = n 0 = n 1
       n
       + fib - n 1
         fib - n 2

let [fib]
    : : 1 1 zip-with [+] fib tail fib

[I guess I should do function overloading? But instead define types that are comprehensive enough?]

[need [println] if I want single line functions]
let [say-hello] println [Hello, World!]

[I don't know; I've been implementing features to get syntax I want, not for consistency...]

let [say-hello] println [Hello, World!]
let ptr ptr-to [func]
val-of [ptr] [outputs [Hello, World!\n]]

[Dude, haskell is insane: I looked up how to implement a [Vector3] object or similar in it, and was
extremely shocked! Gasp!]

data Vector3 = Vector3 { x :: Int, y :: Int, z :: Int }
    deriving (Show, Eq)

main = do
    let v = Vector3 1 2 3
    print $ x v

[this is fucking insane. I can't believe haskell implemented the stupid idea I had! And weirdly too! Since you can't overload [x]...]

[By the way, [import] opens a file, reads it, executes it... then what? how is it turned into an object?]
[I guess, maybe, it somehow convert the [env] into one?]

[Shockingly, typescript is the most similar to what I envision the final implementation could look
like... Well, not syntaxically of course. You know, the prototypeness, structured types and stuff.]

[Should the language require to specify mutable input?]
let [func mutable-input constant-input] do [
    set mutable-input constant-input
]
[something like that?]

[Should an array be an object?]
[I should have an [Object.Field] type]

[how do I insert the fields of an object in the initialization of another object?]
let Person Object [
    name []
    age  []
]

let Citizen Object [
    Id  []
    use Person
]

[but then, there is no way I could make the name field non quoted...]

[typescript's way of combining types with [&] is really nice and elegant! I should take notes.]

[Maybe I should make the stack have a variable length? Like, I [calloc] when pushing makes the
stack too big? Or maybe not? I mean, when variables have a symbol associated with them, they are by
default on the heap, in a hashmap... There limited cases where this is useful.]

[Also, I should the functional implementation with a very simple version of [let]. None of that
fancy syntaxic sugar please. Though I will implement it eventually, and see how good it is.]

[I'm just gonna use [use] too, at the start at least. Again, I will try a lot of things.]

[Is it possible to make the language fully functional in syntax, but it actually mutates a lot?]

[I'm going too far down the functional rabit hole...]
object [] as [Vector3]

proc [x y z] [
    object [
        [x] x
        [y] y
        [z] z
    ]
] as [Vector3]

[I'm feel like I should only symbolic programming, but quoted symbols are basically pointers...?]

let [Vector3 x y z]
    Object [
        x x
        y y
        z z
    ]

[functions have arguments in type, macros do not]
[function types is according to first use?]

let test-macro macro [print next-token]
[wait – no no no!]
let [test-macro] print next-token
[macros are just functions without arguments!]

[maybe true and false are macros?]

print type-of [Vector3] [Function 3]]
[for 3 arguments]

[wait]
for 3 printl it
[?]

[hmm.]
let [Vector3 x y z] todo
let Vector3 x y z = todo

[[Object] should be capitalized like [Vector3]]

[complex numbers]
let z + 3 4i
[or]
let z 3+4i

[I talk about inconsistency, but what about [[]]? How do you return a string?]
[I guess a string is basically an array?]

let [ret-str] do [
    String [Hello, World!\n]
]

let value Pattern [1 5 25 125 625]

[[Alias] type?]

[I should figure out how to infer function types without arguments. Like, you have macros, but the
macro behave exactly like a normal function, except it's written like a macro just because. And I
should still be able to infer the type (not the implementation though)]

[oh shit]
load-bin [/bin/]
mv [path1 path2]
type mv Function [String String []]
mv path1 path2
[maybe?]

[I think I will still do [let-in], otherwise, some macros can me a pain in the ass.]
[I could make it so the type of a function is infered from it's first use; that or pretyped.]
let [func1 arg] arg
func1 123
[or]
type func2 [Function String]
let [func2 arg] arg
print func2 [Hello, World!\n]

[Then again, no. It should be infered from usage. Like duck typing.]

[I was thinking that arrays could be objects, but why not the reverse?]
let "vector3" [1 2 3]
println get vector3

let ["func" "arg1" "arg2"] func arg1 arg2
[This is weird. I don't like it. Still, the Haskell way, of not really having object should be
explored.]

[maybe [+] is overloaded for objects?]
let [Person name age] Object [
    [name] name
    [age ] age
]
let [User name age] + Object [
    [id] random 0 ^ 2 64
] Person name age
print User [test-name] 123
[outputs:
    [
        [id  ] 123857120581204
        [name] [test-name]
        [age ] 123
    ]
]

* 100 - .5 random

[It makes me gag, but every value should be an object. Well, a tagged union to be exact?]
let [val] 123
debug val
[outputs
    [
        [type ] Integer 32
        [value] 123
    ]
]
print val.type [outputs [Integer 32]]
print val [outputs [123]]

let [obj] Object [
    [name] [test]
]
extend [obj] [age] 43
print obj
[outputs
    [
        [name] [test]
        [age ] 43
    ]
]

[maybe special syntax?]
:= variable field

[I should add named arguments...]
let [test] [
    let token next-token
    if == [-] * token
        match token [
            [-o] set output-name next-token
        ]
    let file next-token
]
test -o main main.txt

let [func arg] print arg
let [func] print eval next-token
let [func] print next-arg

[doc function]
doc [print] [
    prints formatted output to stdout.
    automatically call [to-string] on non-string inputs,
    and [format] on string inputs.
]
help [print]

[functions are colored but only for the linter? like, a symbol will be orange is if it is unsafe?]

[[;] for eval?]
print [Hello, World!\n] [Hello again.\n] ;
print [final hello\n]

[no, remember. a function that an infinite number of arguments. only, it call the functions passed
to it. and the next statement is just that, an argument passed to it, that never returns because it
also calls another function.]

[huh. so i guess you can just do this]
+ 1 2 3 4 5 6
[no, it doesn't work.]
+ + + 1 2 3 4

[LISP has parentheses, I have types.]

[A big reason for function compilation to be lazy, is inter-recursion. I'm pretty sure I saw it in
the 'C programming language book', but there are case where functions doing recursion one after
another makes sense.]

[maybe "" is pushed on the stack, [] is not? and that's the only difference?]

[I should let go of the old object system, and instead have prototypes and instances, where the
object itself is just a macro taking a symbol, and matching it with stuff.]
let [test-obj] do [
    let [token] next-token
    match token [
        value    5
        function do [
            printl [Hello, World!]
            do next-token
        ]
    ]
]
print test-obj value
test-obj function print [rest of the application]
[vs]
print test-obj.value
test-obj.function print [rest of the application]

[hmm]
my-list iter filter fn [item] == item id 132 collect
collect filter fn [item] == item id 132 iter my-list
[btw, this can't be done with [my-list.iter]. you need () function calls and actual [.] syntax.]

[while this is technically the same, it isn't. One requires function overloading, the other
doesn't, and can be done using macros and functions.]

[more importantly, the initial way I had planned to structures was to just take a slice of an array
using [get-at], but it sucked. Still, if I just have the same behavior, but with pre-built
functions attached to a macro object (yeah, just came up with this name). Still, doing mutation is
now kind of hard...]

[also, this model allows for prefix, postfix and infix functions in a more natural way.]

[no. how does [my-list iter] know whether to call the next token, or to just return an iterable?]
let my-iter-list my-list iter []
print my-iter-list filter fn [item] == item id 132 collect
[nah, prefix syntax is just simpler and better.]

my-list iter [filter fn [item] == item id 132 collect]
let my-list my-list iter []
my-list [filter fn [item] == item id 132 collect]
[maybe?]

[it's not that difficult when compiled, but when prototyped...]
let [test-func1] printl eval next-token
let [test-func2] test-func [Hello, World!]
[this should work, since macros and functions are equivalent... but it probably won't be that
simple.]
[I guess [test-func1] is a function taking no arguments, and that's it. But then, they aren't
equivalent...]
let [test-func text] printl text
let [test-func] printl eval next-token
[to make them equivalent, I need to check if [next-token] is called, or just use [] for nesting
everywhere...]

[Even if I don't actually compile, emulating the compile once, then execute every other time is not
that hard.]
[Or should I just start of with proper compilation?]

for range 0 10 printl it
for-in i range 0 10 printl i

fill 255
fill rgb 255 0 0
fill rgba 255 0 0 255
[since object are also functions/macros, this is possible]

do-version file [./main.txt]
do-version 2.5 code [
    printl [Hello, World!]
]
[[file] and [code] both just change the type of a thing.]
[or maybe it should be [cast File [./main.txt]]]
[or just [
    File [./main.txt]
]? That is to say, capitalized.]
[in any case, [do-version] is basically just a function that can execute any version of the
interpreter. perfect for backwards compatibility.]

let [test-func obj] printl obj.name
test-func object [
    name [John Smith]
    age  34
]
[should age also be passed to test-func? or is this equivalent to this:]
let [test-func name] printl name
test-func [John Smith]
[are objects just syntaxic sugar to avoid have 100 arguments to a function?]

let [func n]
    if == typeof n [Number]
        printl n
        overload func n
[basically explicit overloading. the overload function basically just calls the initial version of
the function (throws if it doesn't exist) and doesn't do recursion.]
[I either do OOP/Prototypes with [this], or overloading. There isn't really any reason to do both.
I guess I could, but prefix syntax for everything seems cleaner.]

[I should avoid putting methods in structures.]

let [f x] - 1 * 0.5 x

let value do [
    let val1 69
    let val2 420
    let val3 + << 69 3 420
    val3
]
printl value [outputs "69420"]

[i should have a function called [delete-computer]]


