[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
    print a
    print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
    eprint msg
    exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functional and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

(define (fib n)
    (if (or (= n 0) (= n 1))
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functional caracteristics.]

[Converted jai code]
atom [render] do [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
    print [Hello, World!]

    if true
        print [yes]
        print [no]

    loop print [loops forever]
    for 0 10 print format [prints 10 time. this is [i]]
    while condition [you know.]

    [<3]
]

[Procedural vs functional]
atom [main] do [
    add [x] 1 2
    eq [y] x 3
    if y print [truth] print [falsehood]
]
atom [main] do [
    if eq 3 add 1 2
        print [truth]
        print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
    format x [Hello [y], my name is [z]]
    print x
]
atom [complex x y z] do [
    atom x format [Hello [y], my name is [z]]
    print x
]

[Holy fuck! Procedural actually beats functional... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
    : [x] 1 1
    tail [y] fib:x
    zipWith [y] [+] fib:x fib:y
    : [x] x y
]
atom [fib out init] do [
    : out init out
    tail [t] out
    zipWith [z] [+] out t
    : [out] out z
    fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
    print [do stuff...]
    > bool a b
    if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
    atom [temp] x
    atom x y
    atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
    atom [low] 0
    len [high] items
    sub [high] high 1
    <= [cond] low high
    atom [continue?] true
    while cond do [
        add [mid] low high
        div [mid] mid 2

        cmp [c] mid target
        equal? c do [atom result mid atom [continue?] false]
        less? c do [atom [low] mid add [low] low 1]
        more? c do [atom [high] mid sub [high] high 1]

        <= [cond] low high
        && [cond] cond continue?
    ]
]

atom [binary-search target items] do [
    atom [low] 0
    atom [high] sub len items 1
    atom [continue?] true
    while && <= low high continue? do [
        atom [mid] div add low high 2

        atom [c] cmp mid target
        equal? c do [mid atom [continue?] false]
        less? c atom [low] add mid 1
        more? c atom [high] sub mid 1
    ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
    proj-rect [pr] proj-x proj-y
    unpack-color [pc] PROJ-COLOR
    fill-rect pr pc

    unpack-color [bc] BAR-COLOR
    fill-rect bar-rect bc

    for targets-pool do [
        target-rect [tr] it
        unpack-color [tc] TARGET-COLOR
        if !it.dead fill-rect tr tc
    ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
    add [x] x y
    print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functional...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
    add [x] x y
    print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
    add [x] x y
    print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[vs]

atom [test] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functional way for the bros:]
atom [test x y]
    print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functional translate on the lower level?]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functional, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
    print [still true]
    break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
    sub n 1
    == n 0
    false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
    proc
    loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
    cmp [result] it to
    = error [[it] and [to] cannot be the same values; please try another combination.]
    > for-
    < for+
]
atom [for-] do [
    proc
    sub [it] 1
    cmp it to
    != for it to proc
]
atom [for+] do [
    proc
    add [it] 1
    cmp it to
    != for it to proc
]
atom [for-each items proc] do [
    get-len [len] items
    for 0 len proc
]
atom [while proc] do [
    atom [while?] true
    atom [label] while?
    while-arg
]
atom [while-arg] do [
    proc
    if label while-arg []
]

[But functional may actually come out of it as well...]
atom [+ x y] do [
    add [x] x y
    x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
    add [x] x y
    x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
    proc
    next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
    proc
    next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
    x
    add [x] x y
]
+ + 1 2 3
[Should I consider functional again?]

[Wait, no. Shit gets fucked up.]
atom [x] + 1 2 atom [y] 3 do [
    x
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    + 1 2
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        x
        add [x] x y
    ]
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        1
        add [x] x y
    ]
    add [x] x y
]
[Maybe if I made [x] and [y] local to the procedure?]

atom [add-all x y] do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
]
add-all 1 2 3 []
atom [x] 1 atom [y] 2 do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
] 3 []
atom [x] 1 atom [y] 2 add-all x 3 []
[Hm. Does it really work like that?]

[More functional]
let [x y] 1 2
atom [x] 1 atom [y] 2

[Should be equivalent?]
atom [func x y] []
atom [func] do [let [x y]]

[Maybe it's that simple?]
atom [atom name value] push-key name value atoms
[But any more than, and we're implementing stuff.]

[Functional again]
atom [+ x y] do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
+ + 1 2 + 3 4
atom [x] + 1 2 atom [y] + 3 4 do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        1 2
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        3 4
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
[Is it impossible? Well whatever. I can tell already: the hoops you have to jump through to get this
behavior is insane. I will probably still try to make this work, but the procedural way is far
better. You know, left-to-right and infix is just more elegant.]

chain 1 + 2 + 3 + 4 as [test]
print _ [outputs 10]
print test [outputs 10]
[I mean look at this! It's fucking beautiful!]

[Rust syntax]
atom [let name] []
atom [= value] atom [name] value
atom [;] atom [name] []
let [test_val] = 2 ;
[Well, "Rust" syntax.]

[Delete]
atom [delete name] atom name []

[I don't think this language should have something like function overloading.]

[Maybe I could have a [type] [Single] that can only be called once, and once done, it will be
removed from the list of variables?]

[If each variable has the following values:]

struct [atom] [
    name value before after
]

[where [name] is of course the symbol of the [atom], then [value] is the what it returns, or the
pointer to the value in memory. What if there was [before] and [after], where [before] is code that
gets executed before the value is called, while [after] is code executed after it's called. So like,
in [before] we could have a macro that sets up the arguments of the procedure, then adds the [value]
after the declarations? And in [after], I could have some RAII clean up? I think I'm unto something,
but the idea needs polishing.]

[Btw, if I do [before] and [after], I could probably do this:]
type [+] [
    before atom [x] prev 1
    after atom [y] next 1
]
atom [+] add [_] x y
1 + 2 print _
[I'm not sure where I'm going with this, frankly.]

[Maybe the entire program is actually a list of tokens that can change itself.]
1 2 3 print get 1 program
[outputs 2?]

[Or maybe...]
atom [+] add #-1 #1
1 + 2
[where #n is a relative value? But how do [add] work then?]

[I really need to start working on the implementation. There's only so much I can do with only
theory, and so little technical knowledge.]

[I know that, eventually, everything becomes [hex []], and then gets executed. But how does it do
it? *Sigh*]

[I feel like python will be more useful for learning how to write this programming language than
Rust or C...]

[Is this programming language becoming too complicated, like LISP nowadays?]

[I should stick with the S Expressions. Adding anything else is bloat.]

[Btw, the model where we do [add #-1 #1] is interesting but stupid, because what is [add] defined
as? There is still a lesson here though. Just need to find out which.]

[Maybe I shouldn't have a hex procedure? Maybe numbers simply get hexecuted (?) when 32 bits have be
gathered? Maybe numbers are just functions that reduce to themselves in binary format?]

[I think I should just use hexadecimal for all number types. Like what, is anyone going to use my
programming language expect me? And little endian too. Of course that would mean I need to get used
to hexadecimal, and convert it off the top of my head, but otherwise, I should try it and see how it
works.]

[Incidentally, in regards to trying out things, I think the 3 space indent is bad. I tried it for
some C code, and while it isn't as noticeable for small procedures, for larger ones, 3 spaces just
feels wrong. Not to mention, 4 spaces is byte aligned.]

[I think I might replace every instance of [atom] with [macro], because that's what they are. But I
don't know. [atom] sounds real nice.]

[If I write]
mov x0 [str]
[should x0 now have the utf-8 value of [str]? I feel like yes... But that would mean that mov isn't
a parameterless macro... Though.]

[This blows. I found out that the way an instruction is encoded is not necessarily byte aligned, an
so I will find it difficult to write the most basic macro...]

[And now chatGPT tells me that not every instruction is 32 bits. This is going to be so difficult.]

[Oh hey there, I didn't see you. So after giving RISC-V's specification a look I saw that unlike
arm64, the opcode is the smallest value, and the destination register is the thing that follows. So
I think I'm going to try and run the programming language on a RISC-V platform. This is of course
far harder than it sounds, but no harm in trying.]

[The idea about abandonning [hex []] is no longer realistic. To begin with, opcodes are not byte
aligned, whether on arm64 or RISC-V. So I'll instead have something call [bin []].]

[Damn, I don't think I could even do something like [[mov] -> 000000] because, we do do know that
[x1] will be a fixed size, but not the number that follows.]

[I am a little conflicted now: in [foo] could just be a function pointer, and you call the pointer
by putting parentheses after it. This is elegant, and I like it. Question is, how do I replicate the
behavior? Do I just quote it? But then, how is it different from a normal string? How do I, for
example, [printf] a function pointer? Damn, this is tough.]

[Ok this is something that might give LISP edge: by typing [func], you get the function pointer, by
typing [(func arg1 arg2)], call the function. But man, this sucks, because I build this whole idea
over the premise that the LISP model is imperfect. I can cede just yet...]

[I figured it out, if every value in LISP returns a pointer by default, then you would have to call
variables as well (even more parentheses; heck no!). And in C, you constanly reference and
dereference a variable, which is the equivalent of quoting and unquoting, but with a different
syntax. Not to mention you don't really have symbols. In which case, I still need to figure out the
tug of war between symbols, pointers and values.]

[Iteration may actually be better than recursion... I mean, in assembly you have branch and branch
with link; so while you usually do recursion, it's not really the same.]

[More details about eager vs lazy.]
chain 1 + 2 + 3 + 4 as [val]
macro [val] do [chain 1 + 2 + 3 + 4]
[The first one is eager because the program takes those additions and executes them left-to-right;
the second one is lazy because [macro] gets executed, but not the arguments, since they are absorbed
into the procedure call.]

[I've been getting pretty decent at the CLI, but doing so, I question having to put [] around every
thing that isn't a function or procedure call. Maybe I should follow LISP in this?]

[Another reason why I shouldn't do [import] and instead just reference a file like a script is that
I want the compiler to be single pass, but doing it otherwise would be complicated.]

[Okay, so big problem for procedural:]
atom [add x y z] todo
[How do I define it?]
atom [add x y z]
    atom x + y z
[Like this? Do you see the problem? Thing is, I'm trying to merge [add] and store instructions into
the same thing, but they are not the same thing. The solution could be as follows:]
atom [+ x] do [
    add x0 _ x1
    store x0 [_]
]
[where everything returns to [_]. Only the instructions themselves will keep use the old format, the
rest will behave much like functional, but still left-to-right.]

[But then again...]
atom [+ x] atom [_] add _ x

[It's important I get this right, because if I don't, the programming language may be dog shit.]

[Maybe everything that hasn't been defined yet evaluates to itself, quoted. So that's how I could do
numbers.]

[I might want to create a proper proper LISP first using my low level model, just to get the hand of
it.]

[Perhaps...]
atom [recursive-proc x y] do [
    todo x y
    goto [recursive-proc]
]
[that way, there is no need to redefine [x] and [y] since they are already defined.]

[[before] and [after] may be too much. An [env] should only have [symbol], [value] and [size].]

[Do I really need dependent types? Is there no better way to check for correctness?]
atom [val x] do [
    < x 0 true? error [cannot be negative]
    todo
]
val -1
[The linter should be smart enough to tell that this will always throw, and warn you of it. No need
for types; they are too complicated anyway.]

[I am all the more motivated to create a LISP, because of this:]
(define func (lambda (a) (display a)))
[Because it's eager loaded, lambda executes, creates a procedure, and returns the pointer to it.]
(func "Hello, World!")
(func func) [outputs something like 0x20D1A5BC]
[Holy fuck, is this elegant...]

[Maybe]
atom [func] lambda [a] print a
func at [func]
[outputs something like 0x20D1A5BC]
func do [func] [Hello, World!]

[In LISP, you have special notation for quoting, but everything else is call by value or call a
procedure. In my language, lists are quoted by default, and if a procedure has args, they are called
by default, when not quoted. But that was the funcionnal one. What about procedural?]

atom [func] lambda [a] print a
[Does not work because [lambda] is lazy. And procedures shouldn't be able to returns things.]
lambda [a] print a as [func]
[I think this works, but should I?]

[Once again, functional is making a comeback.]
[Also, I really need to figure out how to lazy [print]...]

[Okay, lazy vs eager eval really fucks me up, because you have to mix them up, right?]
atom [test] do [
    other-func lambda [x] x
    print _
]
[Does lambda create a new procedure everytime [test] is called?]

atom [func] lambda [x y] todo
[[lambda] is eager, but todo is not? What is the logic behind that?]
lambda [x y] todo as [func]
[More ugly but makes more sense. Maybe I already found the answer; and I'm just being stupid:]
lambda [x] x
atom [test] do [
    other-func _
    print _
]
[I guess it is still better than LISP, since I doesn't have some arbitrary procedures that lazy
instead of the eager default.]

[I should drop the eager function as arguments, or whatever. Doesn't make sense with new model:]
atom [func x y z] do [
    print x
    print y
    print z
]
func [add] 1 2
[becomes]
do [add] 1 2
[wait no... I have to rework [do []] if I do that...]

[I should consider it seriously still... The biggest problem is [atom] and it's implementation.]
[Maybe [list] will make a comeback? Nevermind again. There is simply no way of doing this without
having non-quoted lists.]

[Ok, let's think. Because I think I am unto something.]
[Still a comment/string]
(define [name] 5)
(print name) [outputs [pointer] so bad]
(print (name)) [outputs [value] so good]

[Ok, now without parentheses, or less.]
[Comment]
define [name] 5
print name [outputs [value] so good]
print ptr-to name [outputs [pointer] so good]
[problem is: should it be eager or lazy]

[cannot be eager]
define [func x y] do []

[this can]
define [func] lambda [x y] [print x print y]
func 1 2
[becomes]
let [x y] 1 2 do [print x print y]
[but should I?]

[what about]
define [func x y] ()
[yeah, I've got nothing. I thought I was unto something last night; something to do with parentheses
to be used for eager loading, but I don't remember what.]

[wait no, the lisp example works because the [value] of [name] is a pointer to a pointer!]
[damn, I went through this train of thought a while ago...]

[In any case...]
atom [atom symbol return] do [
    ch symbol len > 1
    then do [
        car symbol as [name]
        cdr symbol as [params]
        atom name lambda params return
    ]
    else append env symbol return
]
[but it has to be lazy, otherwise [then do []] will get evaluated.]
[god this shit is confusing]

[maybe...]
atom [then x] if _ x []
atom [else x] if _ [] x

[it should be lazy, but then I can't do [lambda]...]

[optionnal []?]
define name 3
atom [define x y] do [
    quoted? x atom x y
    else atom quote x y
]
[something like that?]

[it would be a bad practice though, but would make the all variables are quoted if undefined work.]

[Hmm, if I do this...]
atom [items] [ 1 2 3 ]
[This would be a 5 [strings] or [u8] pointers, and the atom macro would see that the first pointer
points to a value representing a array oppening, and then do the magic.]

[Man... What the first macro takes the rest of the programming language as parameters? I think I had
this idea before, but I would love to see this work!]
+ 1 2 - 3 4
[[+] takes the first two values, then the rest; since it knows it only need two values, it simply
executes [eval] or something like that, then [eval] executes the rest accordingly. If it's a
[string], it calls eval on the next value; so on.]

[Again, infix syntax, but not really.]
atom [| x y] x _ y
quote name | atom [John Doe]
[Basically piping, but dummer. Equivalent:]
quote name atom _ [John Doe]
[This is not valid...]
atom quote name [John Doe]
[Since there are only side-effects.]
[Also, I guess [x] is the first argument, while [y] is the rest of the application?]

[Okay, listen.]
atom [proc1] do [
    get args 1 as arg1
    print arg1
]
[because [args] is the rest of the application. So you can just index into it like some ordinary
array. I love this!]
[In fact, I can probably still do this:]
atom [proc1 x y z] do []
[equivalent]
atom [proc1] do [
    get args 0 as x
    get args 1 as y
    get args 2 as z
]
[Like bro, this is more elegant than anything I've come up with before!]

[Holy fuck.]
print [test]
print [test again]
[Usually, when you call a procedure, the things get put in the stack, but because the procedure
you're calling is the one calling the next procedure, you fix most problems with recursion just like
that!]

calculate bottom top = sum $ filter (\x -> mod x 2 == 0) [bottom..top]
[suppose...]
atom [calculate bottom top] do [filter []]

[I don't really like this]
1 + 1 print _
1 + 1 dbg
[I probably won't keep debug, idk]

[Functional won't die]
atom [print x] do [
    quote? x
        then write x
        else do [
            x args
            print _
        ]
]
[so]
print + 1 2 [outputs 3]

[the beauty of this language is that anything is permissible]
[the ugliness of this language is that anything is permissible]

atom [+ x y] do [
    num? x else do [x args as x]
    num? y else do [x args as y]
    + x y
]
print + * 1 2 - 3 4

[I don't think I have to check for variables though?]
atom [name] [Joe]
print name
[Damn, I don't know!]

[btw, just remembered that I still don't know how to do [atom [] do []], at least not elegantly.]

[in [bc] you can do [sqrt(2)] and the result is [1], but with [sqrt(2.0000000000)] and the result is
[1.4142135623]; very interesting.]

[The reason why [+ + 1 2 + 3 4] will never be possible is because in [+ a b], [a] and [b] will have
to be argumentless functions that always return the same thing, which is obviously not procedural.]

[Then again... Yeah, functional will never die. Anyway, can't way to finally put this project into
motion.]

[*Sigh*... Maybe I should add types... Otherwise, it becomes such a pain in the ass.]
1.2 + 5 print _
[How is [+] supposed to know if 1.2 is a float without specifying it...? [+float] maybe?
[float-add]?]

[Maybe I will have types, but they are not user declared?]

atom [func x] fn [
    print x
]
[[fn] is eager, compiles the quoted code and returns pointer to it?]
atom [val1] [func]
[[val1] = symbol to function.]
do val1 1 [outputs [1]]
atom [val2] func 2 [outputs [2]]
[[val2] = [] because [func] got evaluated, and returned nothing?]

fn [x] [print x] as [func]
[more standard lambda?]

[still, I could make it so [atom] always evaluates the value, it's just that if it's a variable,
then the variables value will get assigned to [_]?]

[maybe I could consider this:]
atom var [this is a string]
atom [var] [print [this is code]]
[...but I already decided not to do this. If I do, the floodgates will open...]

[btw, [let]]
let [
    a 2
    b 5
] []
atom [let x y] fn [
    count x as x-len
    for 0 x-len [
        get x it as [x0]
        += [it] 1 get x it as [x1]
        atom x0 x1
    ]
    do y
    x-len / 2 pop _
]
[maybe a way to do scoping?]
[nvm, can't define global variables this way.]
[wait, not [pop 3] but reverse of [for]?]

[right, almost forgot, if [fn] or whatever compile completely, we would need to compile the program
supposing that we can stand long load times, since once the procedures have been assigned, and
therefore compiled, they will run like it's a binary. food for thought.]

[Perhaps this is the only overloading I need?]
2 + 2 [integer addition]
2.0 + 2.0 [floating point addition]
[you would need to keep track of what value is what type yourself. The programming language doesn't
do it for you.]
2 + 2.0 [float added to int; fucks shit up]
[also, I guess imaginary and complex numbers are kind of the same as integers, so you just need to
keep track of that yourself as well.]
[there's also this]
2u64 + 2 [but maybe not? since temporary storage is like fixed size, but then again, it's also just
a pointer... idk]
[anyway, I should first try to avoid metadata like the plague, and see what happens.]

func 1 2 as [val e]
[multiple assignement?]

1 > 0
    then print [is bigger]
    else print [is smaller]
[^ this may be impossible, since [get args 1]]
atom [then x] [
    [insert branching logic]
        x args
]
[since args is just a pointer, and the [x] in the assignement move the pointer right, you can just
do this.]
[still, it might be useful to have something like this:]
1 > 0 ?
    print [is bigger]
    print [is smaller]
[to prevent else from executing. idk.]
[wait, shit. I remember now why I had to quote [x]: how do I know the args of [print] shouldn't be
executed?]
1 > 0
    then [print [is bigger]]
    else [print [is smaller]]

[btw, this may be possible:]
atom [func x] [
    do-shit x
    x args
]
1 func [+] 2 print _
[nice.]

[I'm still debating variable and procedure assignement.]
proc [x y] [x + y print _] as [add-show]
[^ this works, but it's ugly.]
atom [func x y] + x y
[doesn't work because of lazy vs eager.]

[i think this is the best:]
atom a 2                            [value of 2]
atom str [this is a string]         [pointer to string]
atom func' func                     [same pointer]
atom [hello x y] [print [hello, world]] [compile procedure, [hello] now has the pointer to it.]

[but that opens so many doors, and closes a few.]
atom [+= val n] [
    n + val as val
]
[or maybe it doesn't close doors?]

[i should really consider this]
let [a 1 b 2]
[idk in what form though.]

[Wait a second...]
atom [func x y] fn [print [thing]]
[this may be possible if [fn] moves [args] to the right.]
[not very useful, though, since [fn] can't return anything...]

[still can't do this though]
0 then print x
[[print] needs to be evaled to move [args]]

[Sometimes, it's just ugly. I don't think I should go to such lengths just to avoid
[proc [] [] as [f]]]
[Death to syntaxic sugar!]
[Also, quoting non-evaluated strings is just better. No suprise there.]

[I could do this, though it's ugly.]
0 then 1 print x
[where]
proc [skip f] [
    [branching logic]
        f args
    += args skip
] as [then]
[could be worse]

[Remember to implement flipjump in the language.]

[I guess it's also a bit like vertical align: it's ugly but objectively better...]

[maybe I could have [proc] and [item]?]

[I doubt I could compile a procedure using the C interpreter, but I could probably do a scuffed
variant, one that write C code to a file, compiles it and then executes the binary.]

[I should have donut shaped code that prints donut as a demo.]

[My [env] stack should have standard CRUD operations, plus upsert.]

[I should make [bin-exec] as small as possible, i.e. ignore all the characters other than 0 and 1.]

[I realized something.]
2 print _ [outputs 2]
item [a] 2
a + 2 print _ [panic at a, because it is treating [a] as a procedure pointer.]
ch a + 2 print _ [outputs 4]
[guess [ch] makes a comeback.]
[btw, would've been classy is it was called [return] instead of [ch], but it's too long, and it
doesn't make sense in a lot of situations.]

[I should consider making numbers not special. So the simplicity is taken to the extreme. Like
functional, it needs testing.]

[Also, experiment with tabs for vertical align.]

[Should do tetris in C, then in this language.]

[I should mention, this language is procedural, yet it is still takes inspiration from lambda
calculus.]

[Don't forget to experiment with spaced variable names. I doubt I will actually use it in
production, but I want to see what it would look like.]

[btw, the way procedure calls are done, allows infinite recursion.]

[When I finally figure out how vim works, I will make Control+S wall.]

[Maybe [return] could assign the [_] of the outside scope!]

[Damn, procedure definition may be easier than I anticipated!]

[Should have procedures to manually push or pop a env.]

[1.0 will only release at the end of my life, after I will have thoroughly tested the language.]

[Recursion doesn't really work.]
proc [] [
    func
] as [func]
[How is it supposed to know that it's called [func]?]

[Probably will have to use [goto]]
proc [] [
    label [start]
    do-stuff
    goto start
] as [func]

proc [label] [
    item [start] position
]
proc [start] [
    item [position] start
] as goto
[I heard that [goto] is, like, literally Hitler, but this is the cleanest way to do recursion,
without doing recursion.]
[We're getting further and further away from functional programming...]

[I'm curious, just how different will the implementation turn out to be?]

[Wait, couldn't I just use [goto]? no need for procedures and all that – yeah, this language is
getting worse by the second.]

[If you want to redefine [eval] and use the new one, you can only do so by calling it on a [Quote].]
proc [code] [
    [do-things]
] as [eval]
eval [print [Hello, World!]]
[or]
read-file [main.txt] eval _
[You know what? The procedure notation is growing on me. I don't know how to feel.]

[Oh shit, I might have to manually [free] strings like in C, if I really don't want metadata...]

[Maybe I should use [mark] instead of [label]?]

proc [e] [
    print [%s\n] e
    exit 1
] as [error]
[where [e] is a pointer to a string. It has a unique id and error message!]
item [index-out-of-bounds] [Index %i is larger than the maximum %i\n]
throw index-out-of-bounds
[wait no]
proc [e] [
    item [err] e
] as [throw]
[It should do something like assigning to the super env. Like [return] but for errors, and instead
of using [_], we use [err] or [e].]

[Holy!]
item [code] [
    print [hello\n]
]
do code
[This looks good!]

[Recursive printing?]
item [x] [%\n]
print [%s] x 5
[prints [5\n]]

[I think I should really make separate procedures for [insert] and [update]...]

[Damn, I'm seriously considering adding metadata...]
1 + 1 print _ [Can't even do that!]
[Adding metadata would be exceedingly simple: just another field in [Entry].]
[... Yeah, I going to do it – Or at least try it, the same way I tried upsert.]
[maybe [let] for upsert, and [set] for update? Also, I could make it so both are insert in there is
no existing variable in either self or super?]
[No, there would be two upsert, but they behave differently: one first checks if a variable exists
anywhere, the other calls upsert immediately.]

[Perhaps I'm giving myself too much of a headache?]
item-in 1 [a] 42
[^ this assigns one layer higher.]

[what if [meta] is just a string to for code to be executed?]

[I shouldn't forget to implement library like numpy, sciki-learn, tensorflow, pyplot, pandas,
matplotlib, lodash; maybe some minimal js frameworks like htmx or alpine.js; i don't know. Anything
that seems pertinent. Oh and also things like SDL2 and/or raylib]

[I don't think I will do this:]
item [name] [World]
print [Hello, [name]!\n]
[Too much nesting.]
print [Hello, %!\n] name
[better]

[maybe a procedure [do-here] that doesn't push another environment?]

[Do I really need a [meta]? The only reason you might want it is because floats are weird, that and
nicer syntax. If you really cave in and add them, a lot of other doors open, which should remain
closed...]
1 + 1 print [%i] _
[^ this is equivalent to the earlier code; and it's what I do in C. This isn't Hitler or anything.]
[My goal is to make the compiler as small as possible, while still having the performance of C, and
the capabilities of Scheme. I should hold myself to higher standards.]
[This will be really awkward when I do decide to add metadata...]

[I need a [format] procedure for [print]. And I need to malloc and copy a string. I can't print
character by character, since when I encounter an error, it will have printed until the error.
Still, I makes it harder when you don't know the final size of it. Maybe malloc every time I
encounter a %?]

[I will probably put something like as an example, but I want to put it here because of how nice it
look.]
proc [x y] [
    print [Hello, World!\n]
] as [proc]

proc [name] [
    print [Hello, %!\n] name
] as [greet]
greet [World]

print greet [
    will output:
    [parse copy-token item [name] _ print [Hello, %!\n] name]
    and maybe:
    [iter [k] keys [parse copy-token item k _] free keys print [Hello, %!\n] name]
    also [do-here] to evaluate iter block without creating a new environment – or maybe I should
    instead do [item-in]?
]
[How many programming languages can you do that in? I mean the [item k _]; in C you could create a
hashmap, but I this language this is the default. I like.]

[[parse] and [copy-token] and the like should only be usable in a higher scope. Otherwise, things
get really messy. Further experimentation is needed.]

[Maybe I can have two different [do]?]
item [do] [stuff...]
do []
[^ need to do this to see changes.]
item 1 [do] [stuff as well...]
[the change is immediately noticeable, since the rest of the code is executed using this [do].]

[As scuffed as procedures are now, I can't make them in another way without adding metadata, but
adding metadata is worthless since I eventually plan to compile these things.]

[The more I think about, the more difficult compiled symbolic programming sounds. I suppose that why
it hasn't been done yet, in the straightforward I'm trying to do it, I mean. Or has it. Probably
some LISP dialect.]

[Fuck it. I want to simulate compiled procedures. I don't want to write [do] everytime, so I will
use metadata, but only for this specific case; and then, I will naturally remove it once I can
compile them. The only other alternative to using [do] is to write C files, compile them and run
them from the CLI – something I want to absolutely avoid.]

[I don't just want to make the interpreter as small as possible; I want to follow the unix
philosophy in general.]

[Damn, I make a lot of typos.]

[Wait...]
for 0 10 print [%i\n] it
[this could work because [for] remembers the start of [print]; once [print] finished executing,
[for] continues executing, and returns the pointer back to the start of [print].]
[I should really consider it, so I can avoid nesting as much as possible.]

[For using the REPL of this programming language like a shell, I would need a way to import binaries
and call them.]
load-bin [/usr/bin/]
bc [-e sqrt(121)]
[this should print 11]
[although, I might need quotation like in the shell]
bc [-e 'sqrt(121)']
[maybe I can also load individual binaries or entire folder accordingly]

[Do I say S-Statements instead of S-Expressions?]

[Just found out about realloc. Should use it to concatenate strings.]

[Shit, how do I malloc?]
item str [hello]
item-at 0 str [H]
print str [outputs Hello]
[Maybe it's no that difficult?]

[Man, being able to define procedures opens so many doors!]

[I can make a [format] procedure with the new concat function.]

[I should be [get] and [set]]
item [str] [Hello]
get 1 str print [%c\n] _ [outputs 'e']
set 1 str [E] print str [outputs 'HEllo']

[Should I have a special syntax for characters?]
[or maybe]
item [char] [x]
[if the value is a single character long, it just interprets it as a char? No need for malloc?]

[Still, I would have to be mindful when implementing string manipulation.]

[Wait a second...]
proc [] [
    + 1 repeat _ [parse 2] do
] as [?]
5 == 5 ? [] []
[^ an interesting way to implement if statements.]

[Numbers have to be treated specially, otherwise...]
item [a] 1 [throws error, undefined symbol]

[Should I make it so that [return] pops the scope?]
proc [i list len] [
    for [n] list [
        ch n == i ? [return 3 n] [++ len]
    ]
]
[Maybe something similar for [continue]? Like, it's equivalent to [goto 0], or something?]
[Perhaps break as well, but it returns nothing?]

[I'm starting to think that i need special notation for char.]
item [c] 'c'
[^ the string [c] is equal to the char 'c']
[I could make it so a string of length 1 becomes a character automatically, but right now, I don't
know.]
char [a] item [a] _
[^ maybe?]

[Just realized that my language simulates function currying.]

[For [do-here], I don't need anything special; just don't create a new [env], change the [start] and
[end] positions.]
proc [x y] [
    do-here func x y
] as [func]
func 1 2
[First call creates a new [env] because of [do], second+ calls do not.]

[Btw, [type?] is impossible.]

[Everything I say here will probably change once I actually compile the procedures, but whatever.]

[There no point to [then]/[else]]
1 ? [print 1] []
1 then [print 1]
[^ same length]
[I would have to rename [then] to something shorter.]

[Wait, [del] instead of [delete]]

[Create new scope should always be opt-in. So there should be a [do []] inside of all procedures.]

[I will probably have to figure out how to make procedures reference eachother.]

[Perhaps it should just be in [proc] that things are compiled, but everywhere. Like, every statement
is compiled first, then executed. [proc] just makes it so that every statement in the block is
compiled ahead-of-time.]

[Maybe I could take this to my advantage?]
for [][][] [
    print [Hello\n]
]
[you know, how quotes don't check if there're a space at the end?]

[What if the procedure needs the inputs as strings or to invalidate inputs depending on type? Then
you you the arguments to be assigned strings, and the procedures calls inside will manipulate those
string into the desired data.]

[I might need a macro key word that goes does process the parameters.]

syscall 4 [] [is good idea because:]
proc [] [
    syscall 4
] as [write]
write [1 [Hello, World!] 14]

[With my design, even when compiled, [1 + 2 + 3] is too instruction heavy.]
1 + 2 + 3
[is equivalent to ]
[atoi on '1', load into register x0]
[atoi on '2', load into register x1]
add x0, x0, x1
[logic for computing hash]
str x0, [memory location]
[repeat for '3']
[lots of unnecessary steps...]

[Wait]
proc [fd buf n] [
    syscall 4 [fd buf n]
] as [write]
item [str] [Hello, World!\n]
strlen str
write 1 str _
[[write] should not take a variable number of arguments.]

[Yeah, I'm not doing [+=]. Too confusing.]
+= x 2
[or]
+= [x] 2
[? Both are valid and invalid. I don't like it.]
[Well, in any case, it should be easy to define, if you insist on having it.]

[I wasn't initially interested in [defer], but after seeing an example of how [free] could have a
lot of repetition, I reconsidered it. I should try it, at least.]

[Man, I really dug myself in a hole with 64 bit unions. Now I have not way of doing [strcpy], or
whatever.]

[I guess this is a solution.]
load 1 str
stor 1 str 'c'

[I guess, it's also a [goto] vs [defer] thing. Though, people will absolutely hate [goto],
no doubt.]

[It should be the interpreter itself that assigns [_] at the end of a procedure call. The procedure
itself should not concern itself with that.]

[I should figure out how to stuff on the stack... for procedure calls and such.]

[[free] should keep track of what was freed and what wasn't. Avoid double free, basically. I mean,
[free] isn't actually a syscall, apparently. Let's take advantage of that.]
[Then again, it's also an overhead...]

[I can use the [ret] instruction to calculate the size of a procedure!]

[I suppose procedures should concern themselves with processing the tokens into data, and instead
just look at the stack?]

[I should build the disassembler in parallel to the assembler, as the code is basically the
reverse.]

[[proc-len]... hehe.]

[I could just use the args to define the header of a procedure?]
[Then, I just need to trim the header and stuff. I don't know.]

[So what if I shoot myself in the foot? I still have the other one!]

[I could probably create a capture type of mecanism with a different lookup that doesn't search
lower levels.]
[Captures to make code more pure.]

[I found a way to implement [goto] elegantly (said no one)]

[The language is like water: it can take whatever shape you want it to. And because it can take
whatever shape you want it to, you only need to change the behavior of the LSP to contain to shape
of the language. That way it can behave as if it had types, without actually having types.]

[Or not? I don't know. I will have to see when I get to implementing plugins.]

[I could maybe call the capture procedure [with]? maybe [using]? though the second doesn't sound
right.]

[I just realized how insanely difficult these error messages are going to be...]

[Yeah, I'll probably to postpone the implementation of proper errors, since when procedures actually
compile, it will probably change anyway.]

[Anyway, I had an idea: procedures should have a head, body and foot. When you chain calls in a
newly defined procedure, these things get removed. I don't know how I will implement errors with
that, but whatever. I'm going to resist metadata until it's no longer feasible.]

[This would be so much easier if I could just add metadata...]

[Right, iteresting idea as well:]
"\x1b[58;2;255;0;0m\x1b[60mcurly\x1b[0mnormal"
[instead of making my code read. But idk, couldn't make it work with printf.]

[[proc] should be a wrapping, a macro? a wrapping over something, that does define the head and foot
of a procedure, just by default, using some sort of algorithm.]

[So [proc] should be able to detect but ahead-of-time? Or the LSP? Because otherwise, everything is
runtime...]

[Maybe I should rename [quote] to [text] and [symbol] to [name]? but what about numbers?]

[prelude, interlude and epilogue? nah, I don't have to be so fancy. I'm not a haskeller.]

[My [goto]s are actually quite lame, aren't they?]

[Another reason for [meta]:]
item [a] [test]
item [b] [test]
a == b
[this works because the language knows the type and can decide whether to call it or push it on the
stack.]

[Also]
a b 1 1.4142135623
[these value should know be in the hashmap, with the key [_], they should be in the stack, back to
back. Though, I don't know how the procedure knows to access the stack. Oh wait!]
ldr x0, [sp]
[for latest? it has to be in asm otherwise you'll waste time searching the hashmap.]

[hmm]
let [a] = 5
[[let] pushes [a] in the stack, [=] upserts in the hashmap.]

[if the head of a procedure is a single instruction, it will be easy to trim. Something like [bl] to
a procedure called [push] that takes a number as arguments, and scans said number of arguments in
the source code.]

[shouldn't forget to add [proc-len] and [debug-proc].]

[at this point, why not just make it stack-oriented?]
1 2 3 4 + + + 10 == [true]
a b c d + + + [also works]

[i should really do asm instructions proc; they are stripped of the register saving instruction whem compiled]
mov x0 #5 [moves number 5 to register x0; saves register info on the stack for later use]
init-asm [saves all registers on the stack?]
quit-asm [pop all registers on the stack?]
proc [] [
    mov x0 #42
    mov x16 #1
    svc #0
] as [test-exit]
test-exit [works as intented, but no need to save registers.]

[also, inline proc that inlines stuff]
proc [] [
    inline test-exit
]
debug-proc _ [print the instructions of [test-exit] since there is no [bl]]
[still, that means that some procedures within [proc] get executed?]

[another reason to avoid meta: it encourages stack oriented programming... or is that a plus? the
stack *is* fast.]

[inline asm should be as easy as possible]

[creating a programming language is such a skill issue. meanwhile computing can write code in
binary. pathetic.]

[I need a raw [item-in] that is unaffected by [layer-offset].]

[Ah shit, it's because [repeat] does create a new scope – that's why!]

[I've been thinking a lot about loops (as you do), and isn't [goto] the simplest way of doing it? I
mean, damn. It makes me gag having to say (write) this, but recursion doesn't make that much sense
for this programming language. This... Yeah, I don't know where I'm going with this. I need to
implement the assembly first, then decide.]

[[proc] is basically a mini-compiler.]

[You know... I could actually do [str == [a string]] – and I mean why not right?]

[Maybe I should do [struct], just not the typed kind.]
struct [Car] [
    [make]
    [model]
    [year]
    [engine size]
    [price]
    [color]
    [is-electric]
]
Car::new [test-car] [
    [Tesla]
    [Model S]
    [2024]
    0.0
    79999.99
    [Red]
    1
]
print test-car.make  [outputs [Tesla]]
print test-car.model [outputs [Model S]]

[I guess [struct] defines the [Car::new] procedure? And [Car::new] does:]
item [test-car.make test-car.model ...] [Tesla] [Model S]

[And then, we have this]
test-car.delete
[which deletes all the fields. I also remembers to free the strings? I don't know.]

[or maybe]
struct [test-car] [
    [make]        [Tesla]
    [model]       [Model S]
    [year]        [2024]
    [engine size] 0.0
    [price]       79999.99
    [color]       [Red]
    [is-electric] 1
]
[which does the same as the above code]

[hmm]
struct [Vector3] [[x][y][z]]
Vector3 [test] [1 2 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[or]
struct [test] [[x] 1 [y] 2 [z] 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[...]
struct [Vector3] [[x][y][y]] Vector3 [test] [1 2 3]
struct [test] [[x] 1 [y] 2 [z] 3]
[the second one is clearly more terse, but that's only because this example only does it once.]

[I could do both, like:]
struct [] []
object [] []

[Alright. I'm going with this. It looks too sexy not to.]

[Oh, and I'm dropping the [::new]. Don't know why it was there. I felt right, I guess. Rust muscle
memory?]

[Also, if I am very much following the prototype-based route. No OOP here pls.]
[then again, is there any point in doing something like [Person.clone]?]
[and can I nest structure?]

struct [Vector2] [[x] [y]]
struct [Vector3] [[inner] [y]]
Vector2 [test1] [1 2]
Vector3 [test2] [
    test1
    3
]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]

[...]
struct [Vector2] [[x] [y]]
struct [Vector3] [[y]]

proc [name args] [
    get 0 args as [x]
    get 1 args as [y]
    get 2 args as [z]
    strcat name [.inner]
    Vector2-in 1 _ [x y]
    Vector3-in 1 name [z]
] as [Vector3]

Vector3 [test] [1 2 3]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]
[this is hella scuffed... doesn't even have [.delete]]

[well, I'll figure it out eventually.]

_.err?

[I guess I could also have this:]
test.meta
[which is a list of the fields?]
[and you know]
delete-struct [test]
[which iterates over [test.meta]]

[bitwise instruction disassembler?]
00100010 & 00000110 == 00000110 ? [[is mov instruction]] []
[(rough example)]

[I guess I should do the REPL in C then.]

[Maybe the max line width should be 99?]

[I need to do string manipulation before I can do the REPL. Otherwise, I will be too scuffed.]

[Damn, that's right. I can't rename [.intValue] to [.int] because C is a pain in the ass sometimes]

[Even if a procedure ends in an infinite loop, or jumps to another procedure to finish, I should
still have a [ret] instruction at the end. Otherwise, there is no way of calculating the length of
a procedure.]

[I should try implementing this thing (😂) eventually. I think it's called UTF-8?]

[Alright. So I thought about this stupid shit for a while now, and this [ioctl] thing is now really
what I want. Instead of banging my head against a wall, I'll just disable canonical mode...]
[Shit, I just found out that disabling canonical mode requires me to use [ioctl]. Well that's
embarrassing. I should probably remove this piece of text... Later. Too lazy right now.]

[I should have to do this]
1 == 1 as [b1] 2 == b && b1 ? [] []
[[b1] should have been pushed on the stack, and the result of [2 == b] as well. [&&] would have
popped them.]

[I should add the ability to memoize procedures.]

[I should, I should, I should... I should stop saying 'I should'.]

[I should write a vim like text editor, where in normal mode, the cursor hovering over a symbol
executes said proc. And when the procedure get executed, there is a cool effect with colors showing
that the code is being executed.]

[Instead of [item-in], I could do [=+]]
=    [pi] 3.14159
=+ 1 [pi] 3.14159
[whatever.]

[wait, could [_] be the stack pointer?]
[when you lookup a value, you should really be getting a pointer to it. you know [table + hash]]
[wait no.]

[Okay, so I took a shower, and thought a little: I want procedures to be compiled. If I keep
implementing features the interpreted way, it will become harder and harder to migrate; and
honestly, runtime procedure compilation is one of the main features of this language. I have to get
to it.]

[I think I'm going insane. I don't how symbol can override the outer value... And why printf not
print until a newline is shown??]

[Maybe for the editor thing, the cursor also move along. When finished, it's in position for you do
enter another command.]

[I'm adding features as I need them.]

[Jupyter notebooks?]

[Just as there is a [push arg-count], there's also a [pop size] that pops the stack for a value of
a defined size, and assigns it to [_].]

[Damn, I don't know how to add things to the stack with all these function calls...]
[I need to think.]

[This may be a long shot, but I thing I need to rewrite the whole thing in assembly... Wait no, I
can just use -S!]

[Okay... I have to spend a long time trying to understand and trim the assembly code.]

[Dear lord... This is so hard. The more I think about it, the more difficult it seems to be...]

[You know what? One problem at a time. I'll start by figuring out how to read a file and then print
it.]

[I won't be getting very far without knowing how define malloc and free...]

[I'm going to do assembly in the new directory I created, but I will also do the interpreted
version. Instead of using the actually stack, though, I will create my own. If I don't do that...
My progress may lag too hard...]

[A lot of procedure have optionnal arguments?]
compile main
compile: [executable-type mach-o] main
[or]
item [args] [executable-type mach-o]
compile: args main

[heh.]
1u64  [x16]
42u64 [x0]
4 + syscall _
[skip [push n]]

[I guess I don't really need a distinction between [i64] and [u64]?]

[Shit, I was talking about push n and stuff, but how do I do this??]
syscall 1 [0]
[I guess I just put the pointer on the stack, and inside the [syscall] procedure, I'm extracting
the info... But that had to be at runtime. Otherwise it will be too slow.]

[[syscall] should be a macro for inline asm.]
mov x0,  0
mov x16, 1
svc 0
[^ too short for a procedure call.]

[I have to actually think about numbers.]
FFF:x
1011_0010:b
0o777:o
543:d

2134:1
2134:2
2134:4
2134:8

.2134:4
2134.4:8
[Okay. I think that's good.]

[also]
255:1 == -1:1

[it kind of looks like a ratio... anyway, I like how it throws the syntax of other languages like
rust on their head:]
let n: u8 = 42;
item [n] 42:1

[Maybe I should also allow this:]
item '[' [...]
[I don't know... exactly how I'll implement this, but it sounds like a fun idea.]
[I can even do this!]
item ' ' [...]
[Muahahahaha!]

[[defer] should execute in the opposite order.]
[Maybe have a fraction struct?]
[I need [parse] to be more reliable.]

[I could do this:]
item [env.next] [print "New code\n"]
[So when EOF is reached, the app continues.]

ch [filetype mach-o]
compile: _ [print "Hello, World!\n"]

[I feel like I can just do arbitrary precision.]
item [x] 198412847120581251251209851281204981240912840192812057250129851029812308123409128
[can't I just divide this into multiple longs?]

[I should use i32 for default int, and f64 for default float, like rust.]
[I need to make my code libc independant...]

return 5 _

[Is there a way to make a syscall macro in C?]

proc [vector] [
    Vector3.y vector
    print "y = %i\n" _
]
[or maybe I just can't pass an struct to a proc?]
[or maybe i don't need structs, just arrays?]
[array programming?]

[btw]
print [Hello, World!\n]
print "Hello, World!\n"

item '"' [...]

get-at x 4 vec1

[The stack is increasingly more difficult without [meta].]
[These vrariable length types are impossible to work with...]
[I either do meta or things i push on the stack are the same length.]
[Maybe low level should be more stack oriented, while high level uses the hashmap?]

[Also, easy way to convert from one base to another.]
print "%i\n" FFF:x

[I should learn learn "vfprintf" and "strtox"]

[Inline asm should only be doable in a "do" block, or similar, like in a procedure.]
do [
    mov x0,  0
    mov x16, 1
    svc 0
]
[^ this works because the block is first compiled, then executed as binary.]
[while this doesn't:]
mov x0,  0
mov x16, 1
svc 0
[because the registers are messed around with before each procedure call.]

[sure, you could ldp every register before the call, and stp after, but that's such ugly solution
to the problem... just use a do proc at the top level. In a procedure, you don't need since
everything is compiled first.]

[Actually, stack-oriented programming may not be possible...]
1 == ret as [b1] 2 == ret && b1 ? [] []
[for this to work, it would need to not take any arguments...]
1 == ret 2 == ret && ? [] []

[The logical way to approach this, would be to convert the symbol to the pointers or values in the
hashtable.]
[But then I would be using the heap an awful lot...]
[That's probably it, for now. I need to focus on compiling, anything.]

[You know, everything was smooth sailing until I tried to compile. I made so much progress...]

[I wonder if you could implement significant whitespace using this:]
item ' ' [...]
[Just to be unnecessarily evil.]

[also]
proc [str1 str2] [
    print str1
    print str2
    print str1
    print str2
]
_ [Hello, ] [World!\n]
[it would be easy to malloc these strings, but they will on be used in this procedure...]
[wait...]
_ str1 str2
[so they should be pointers??]

[The ideal would be to neither put them on the stack, nor malloc them. I mean, they are already
loaded in memory: "token[start]"!]
[In other words, I should change print to not be null terminator dependant. At least for string
literals.]

[Then again... (I keep going back and forth) I guess I could also insert the string within the
procedure... Because, I mean, what if you have a procedure that returns a procedure? And the scope
of the procedure call gets popped? I need to make my procedures as portable as possible! And in any
case, I plan to make every part of my binary either executable/readable or writable/readable. Or
not? Maybe I should have the minimum? Whatever, later.]

[Okay, but about this?]
_ [Hello, ] [World!\n]
[where are the strings?]
[how should I always write a fixed number?]
[the [write] syscall doesn't check for the null terminator anyway. and I will need to length then.]
[In that case, I only need to push the pointer to the start of the quote on the stack?]

[Maybe I should data after [ret]?]
[If i don't put the string after [ret], i will have to [b]...]
[But how will I now to compile the data as well when compiling to an executable file?]
[Decisions, decisions.]

[Wait, if I malloc something, then mmap it, then free it, will it still be mmap-ed?..]

[Maybe I could push stuff on the stack, and then when I compile, I put the stack in a readonly
section?]

[Holy shit!]
label [n]
[is equivalent to]
adr x0, 0
[... I think.]
str x0, [x29]
add x29, 8
br x0
[hmm, needs testing]

[I shouldn't forget the idea that procedures never return, instead they call eval on the next
statement.]

[Really like this syntax.]
0 ~ print [%i\n] _

item ' ' end++
[I'm so funny aren't I?]

[prepend on item names?]
module [hello]
item [x] [Hello, World!\n]
[for other module]
hello.x
[this is really just string concatenations:]
module-name ++ "." ++ item-name
[something like that]

[Some instruction parse the arguments, then put on the instructions on the stack, others parse
arguments, evaluate them, then put the result on the stack. The former are procedures, the latter
are macros.]
[There really shouldn't be any syntactic difference between the two...]

[hmm]
1 == ret 2 == ret pop && _ ? [] []

[runtime compilation (lol)]

[The LSP throws an error when you're about to call a non-executable part of memory. The program
still runs though.]
[Do you bootstrap the LSP as well?]

do [
    proc [] [
        print "hello"
    ]
    defer [free _]
    _
]
[but you can't do that, because you're using mmap for this...]
[i should try implementing it anyway. some way or another.]

[Need macro push and pop]
push(int, value);
pop(int);

[I don't think I need [adrp] for c. I can trim it. Or maybe it's already trimed?]
[I should test [adrp] with inline in c.]
[[adrp] will be such a pain in the to deal with...]
[like how many bits is printf %x ptr?]

[The interpreter should avoid [malloc] as much as possible.]
[I'm still amazed I'm writing a lisp without really knowing lisp.]
[...]

[I could just chain procedures and never assign the first one, in the top scope, for lambdas; [as]
within second proc.]
[Maybe the next push pushes to _, but before that pushes whatever _ had to the stack?]
[I'm thinking I really need to consider a size value attached to a variable...]
[Maybe I don't need ''.]
item [c] [Q]
[what if [c] is a pointer where token[start] == 'Q'?]
[maybe i don't need to malloc a new scope (it would make error messages so much easier if yes]

[In the asm interpreter, I could just store globals in the stack and access them whenever I want,
but for the C interpreter, I need a weird workaround.]
item [str] [Hello, World!]
do [
    ch str & 0xFFF
    movz x1 [_ 0]
    ch str >> 12 & 0xFFF
    movk x1 [_ 1]
    ch str >> 24 & 0xFFF
    movk x1 [_ 2]
]
[something like this?]
[but I need to change the notation...]

[hmm]
mov x0 3
bl PUSH
[is equivalent to]
mov x0, arg1
mov x1, arg2
mov x2, arg3
[?]
[so]
mov x0 3
bl PUSH
svc 0
[is all you need?]

[okay, what is the notation?]
mov [1] [3]
[move x3 into x1?]
mov [0] 77
[move #77 into x0?]
mov [0] [77 1]
[move #77 << #16 into x0]
mov r v
[move value with possible shift pointed to by symbol [v] into register pointed to by symbol [r]]
mov r [v s]
[move value [v] with shift [s] into register [r], each pointed to by symbol]
[i guess this works]

[i still have no idea how I will do arguments...]

[I could also do]
item [x0] [0]
item [x1] [1]
[you know, to make it more like actual asm]

[wait]
mov [0] [[1] 1]
[i guess that works]

[I think I'm giving myself too much of a headache. A lot of these are aliases. movz will never move
from one register to another.]
[In other words, I can just use integers as inputs.]

[There's a variable called this.]
print this [prints the entire code of the first file.]
item [this] [] [does nothing]
item-in 1 [this] [] [breaks the program, because the source code got deleted]

[oops, just remembered there is w0 and x0.]
[maybe]
movz 0:4 2
[?]

[wtf, why do you need w0? you're moving a halfword??]

[Maybe I should always use exponential sizes?]
1:0 [char ]
1:1 [short]
1:2 [int  ]
1:3 [long ]
[2 ^ x * 8 = number of bits]

[i shouldn't forget about this]
printf("%.5s\n", str);

proc! [] []
[instead of]
macro [] []
[? well, it's the same length so whatever.]

[There should probably be a register reserved for the [token] value.]

[Also, nvm for "", I need to be better than this.]
print "Hello, World!\n"
[...]

[wait a second]
[a] = 2
[I can do this because the quote is ignored, and [=] can backtrack... but do I want to? probably
not.]

[Okay.]
proc [text len] [
    write 1 text len
]
proc [fd buf nbytes] [
    movr 9 0

    ldr 0 9   [fd]
    sub 9 9 8
    ldr 1 9   [buf]
    sub 9 9 8
    ldr 2 9   [nbytes]

    movz 0 fd
    movz 1 text
    movz 2 len
    movz 16 4
    svc 0
]
[or [ldr] with offset. idk]

[Do you like driving without a seatbelt? Do you like being a menace to society? Well this is the
language for you! No rules. The only limit is your imagination, and your ability to avoid law
enforcement...]

[maybe I should have a stack for executables?]

[pop]
0 < val 65535 > val . && _
0 val < 65535 val > &&
[it's either [^] or [.] or whatever else]

proc [] [
    0xf9400508
]

[need a [debug-stack] procedure.]

[I can actually implement dependent types... I mean, I just learned zig has them with comptime
right? Like damn.]

[Then again, maybe I want more than that? Because some search algorithms need sorted list as input,
but what, I need to check whether the list is sorted everytime? If it's a runtime check, it becomes
expensive real quick... Since there is no way to attach the fact that list is ordered onto a
symbol, I can't prove that a procedure will always work. Not without types.]

[Also, I really like the fact that you can write proofs with dependent types. It's so fucking
cool!]

[Then again... 'Ordered' could just be a wrapping over a List. You can't pass a List instead of an
Ordered argument, but you can pass an Ordered to a List... I guess List is the wrapping here.]

[Honestly, I will probably implement [meta]. Doing [get-at pos size from] is too long. But again,
I'm going to try to make as far without it as possible. I need to see what it looks like.]

[Alright, suppose I do have to implement types:]
item [x] 12
typeof x print [%s\n] _ [outputs [Number]]
type [Number] [u8 u16 u32 u64 i8 i16 i32 i64]

[but how do you express fixed size lists?]
array [x] [1 2 3]
typeof x print [%s] x [outputs [Array Number 3]]

[So I guess]
x == [
    [value] [1 2 3]
    [type] [Array Number 3]
]
[[type] doesn't have to be a string. It can be pointers to strings, and depending (lol) on the
pointer, the size of [type] can vary. But how do I know which types take in arguments?]

[wait]
type [Array inner-type length] [Array inner-type length]
[it seems redundant, though.]

[but then you have to say everytime a procedure uses IO and stuff...]
[and what happened to this]
u32 [x] 11

[A big reason to have types, that it makes operating on fractions so much easier.]

[Need to think about this.]
[So, in [proc], the procedures have something like [reduce] called on them, and the instructions
are pushed on the stack without being evaluated. On the top-level, they are pushed as well, but
popped and evaluated afterwards. Okay. But what instructions are pushed on the stack? If you define
[write] for example, the instructions that are pushed on the instructions pushed on the stack are
the instructions  for taking arguments, and then pushing instruction again with thoses arguments
hardcoded to push on the stack as well. So when [write] has taken arguments, you now have a
procedure that pushes the same thing on the stack everytime, and you can evaluate thoses
instructions or insert them inside another procedure. Because you can insert them inside another
procedure, you can't just push the data at the end of the procedure (after ret). You need to
hardcode it as mov instructions or mix code with data, do a ldr offset from pc where you put some
data, then jump the data with a branch instruction... This is going to be hard to implement. Not
just for [write] but for everything.]

[Okay. I wrote a lot.]

[You know, it's a little funny to think about safety in a language that, a its core, is more unsafe
than [strcpy].]

[If I do something like Elm, I will probably remove h1, h2, etc. And just have text... Then again,
accessibility and all that...]

[Depending on the types, a procedure can have a different number arguments?]
[Types should really be string, a least at first.]

[Functional programming is, to my dismay, seeming more and more appealing.]
&& < 0 val > 65535 val          [functional]
0 < val as [b] 65525 > val && b [current model]
0 < val 65535 > val . && _      [current with pop]
0 val < 65535 val > &&          [stack oriented]
[functional and stack oriented are the clear winners here]

[I understand that I want to make this programming low-level and such, but some things are
objectively better than others. Once I finish implementing a working procedural model, I will try
types, then funcitonnal, and compare the implementations.]

swap str + 1 str

[Another good reason to have types: errors are so much easier to do.]

[The language has to be built from the ground up with [x] feature, otherwise a plugin would be too
awkward.]

[Should I make it so that it only compile after the first use? That might solve the recursion
issue.]

[In functional, I could use [_] as a discard:]
_ write 1 [Hello, World!] 13
[write doesn't return anything this way.]

[Division by zero should equal zero, like in [Gleam]]

[Maybe I can do everything lazy, and where it only compiles when function is called?]
item [f] [print [Hello, World!\n]]
print [%s\n] f [outputs [print [Hello, World!\n]]]
[Of course, [item] does not malloc the string like before. It only get a pointer to the start of it
(token + start).]

item [f2] [f f]
print [%s\n] f2 [outputs [f f]]

[but]
f2 [will compile [f f] and therefore [print [Hello, World!\n]] as well]

[also, when printing a function, you won't just be getting the function body. you still need to do
the argument logic, and all that.]
[and let's not forget]
func [f x] x
[is equivalent to]
item [f] fn [x] x

[still, that means that everything starts of lazy?? this might not work, since we need intrinsics
to define the rest... damn, thought I figured it out for a second there!]
[maybe recursion will forever be off the table...]

(define [f x] [
    print [Hello, World!\n]
])
[maybe I should just give up and do it like this... seems cleaner at this point.]

(print [hey])

[wait, what about function with not arguments?]
(if (< 4 10)
    [f1]
    [(f2)]
)
[i suppose that works.]

(define [f x] [(
    print [Hello, World!\n]
)])
[lol, this is worse than lisp.]

[no, a thing I really like about my language is that I can [scan-token] and [copy-token] and
[parse] or none of the above, without any reservation about what actual arguments the caller gave
you. in lisp, you're pretty much forced to take the arguments within parentheses. it's a tradeoff
with its merits and demerits, but I prefer it.]

[Suppose I implement the functional style, variables should also be functions with no arguments,
that always push the same value on the stack.]
item [f] lambda [x] [print x]
func [f x] [print x]
[ah, that brings back memories. right, if I do this]
item [str] [Hello, World!\n]
[how do I know that it's a string or function?]
[and so one of the big reason to have functional style is thrown away just like that.]

[i guess i could be more lispy?]
define x 5
define [f] 5
print x [outputs 5]
print f [outputs 0xffffffff (pointer to function)]
[wait, how do you call?]
print (f) [outputs 5]
[hmm, so like the outer scope doesn't need a parentheses?]

print f [outputs 5]
print ptr [f] [outputs (pointer to 'f')]

[wait]
(define [f x] [
    print [Hello, World!\n]
])
(f 5) [outputs [Hello, World!\n]]
f [outputs [print [Hello, World!\n]]]
[but how would that work?]

[no]
(define str [Hello, World!\n])
(define [f x] [eval x])
(print str) [outputs [Hello, World!\n]]
(f [print str])
[I have no idea.]

[I don't even know why I'm exploring this shit... Man, it was so much easier when I was just interpreting.]

[Maybe I could invert it?]
define str [Hello, World!\n]
define [f x] [eval x]
print (str) [outputs [Hello, World!\n]]
f [print str]
[somehow, that's kind of nice?]
[although]
print $str [outputs [Hello, World!\n]]
[no reason to use parentheses when it's not a list]

[or]
define str [Hello, World!\n]
define [f x] [eval x]
print str [outputs [Hello, World!\n]]
f [print str]
print ptr [f]
[every symbol is a function]

[I like how I'm basically pushing the problem from one place to another.]

[parentheses will never be an option, because they will always be more verbose than procedural,
losing the motivation to go for a functional style.]

[The only serious alternative is]
print + 1 2
print ptr [+]
[against]
1 + 2 print _
print +
[I see. Procedural can be much shorter.]

[The really beautiful thing about procedural is how you don't need an AST; everything is just
text.]
[But also, how you can actually implement functional in procedural.]
[I feel like implementing procedural in functional would be a pain though.]

[maybe]
func [] []
proc [] []
[each parsing arguments in different ways?]
[but the inconsistency could drive you mad...]
[but it's similar to [macro] too?]
[...]

[no, [func] requires type metadata; [proc] does not.]
[or rather, the way variables work would have to change for the two, and the only way to make the
behavior consistent is to have metadata on variables.]

[In the long run, functional may be more useful. And I also, need types. The key thing is to still
use the procedural model, but parse stuff differently. I want [scan-token] and the gang.]

item [x] [hello]
item [x] fn [] []

[I guess [fn] does compile, but only partially, and it compile the instructions to compile the rest
of itself?]

[but then again...]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[one is longer, sure, but it makes more sense.]
[the other is simply not text based.]

[for god's sake! this is such an impossible problem!]

[another reason not to fully compile everytime, is faster runtime. otherwise, you would have to
compile every imports everytime you run the app. this makes it so you only compile the things you
actually use.]

[Is recursion even possible without types? How can you tell it's the end of an array?]

[I should create an actual lisp]
[Probably built on top of python this time. See how far I can get.]

[I should probably put the compilation on hold so that I can implement the rest of the language, so
that I can then objdump the assembly and have a better idea of what to do. Also, I need to avoid
using the standard library.]

[Just had an idea:]
rand-proc-call as [val err]
[so like, instead of having [rand-proc-call] define variables that could clash with the lower
scope, we just put the stuff on the stack, and [as] can assign multiple values from the stack.]

[I should try to do C structs without [struct].]

[I should try something like [do-set]:]
proc [] []
[here [_] is know a pointer to an executable part of memory that will call [do-set] on the start of
the procedure block, compile it and reassign [_] the compiled code.]

malloc Vector3
[[Vector3] is the size of the structure.]
[wait no]
malloc Vector3.size
Vector3 [1 2 3]

[Functional may make more sense.]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[like what? does procedure assign [_] as well? Was it not supposed to be in the stack?]
[no, this is small]
proc [x] [print x] as [_] _ [input]
[or]
proc [x] [print x] . _ [input]
[as always, very verbose.]
[still I need return values to be on the stack as that is so much easier to work with for multiple return.]
[or maybe]
proc [x] [print x] ; _ [input]
[I kind of like it?]

extract [_ err] sp
[similar to [as] but takes pointer?]

[when I do the documentation, I really need it to start with:]
exec 16 [very-long-hex]
[which of course prints [Hello, World!\n]]

[maybe meta is just a long, but that long can be anything, and the procedure decides?]
[[size], [meta] and [value]:
if [meta] is 0, then the symbol is an int, float, or whatever;
if != 0, then it's a pointer to something and meta is size of [something]]

[no, int for size and int for meta, to 64 bit total]

[i should implement a meta circular evaluator.]
[just to remind myself why I created this language,
fix in lisp: right-to-left, parentheses, abstraction, nesting]

[i need to list what types to implement, and features those types allow.]
[like every variable has metadata to improve errors, and a size for the value, and a nullable size
for referenced memory, with maybe whether or not that memory is executable?]

declare [val1] [int]
declare [val2] [Array int]
[i don't know.]

[the reason no one made this language is because of how unsafe it is...]
[i think i read somewhere that mmap allocates an intire page every time? in other words: it's
extremely inefficient...]

[There's a sort of shit to my language, that wasn't there when it was just interpreted.]
proc [] [
    1 + 1 ;
    print [%i\n] _
]
[how the fuck do I translate this to machine code, and how the fuck do I remove the need for
symbols? like what, I lookup a hashtable in compiled/optimized code? I need to be better than
this.]

[Maybe I should drop the hashtable? I mean, the only reason I use it is because chatGPT said it's
typical? But then [malloc] is bad. Also, I now have the stack and want to use it to put values in
it.]

[Also, I really need to learn the io programming language. I'm really thinking objects to the
language, because with types, it's just a waste not to have objects. And we can have stuff like
this:]
object [String] [
    [ptr] 0
    [len] 0
]
new String [str] [[Hello, World!\n] 14]
[... so awkward. need to think this through. Also, still not set in stone that I will use types and
objects. I will resist it till the end!]

[I can't continue programming until I figure this out:]
proc [] [] _
[vs]
proc [] [] ; _

[wait a second...]
proc [] [
    ch [hello\n]
    print _
]
[this isn't a hard problem? ... I just do as normal, but when it actually compiles, [print]
compiles, it doesn't compile with [_], but with the absolute value that of [_]. Am I for real? Is
it really that easy? Am I missing something?...]

[Also,]
proc [] [] _
proc [] [] as [val err]
[are both valid?]
[wait, no. [proc] needs to have a call that assign [_] at the end. like [return] or something.]

[I suppose [ch] does not compile, but is already compiled? That's why I don't have to worry about
it?]
[Still, that means that [push] needs to work differently...]

[If I do modal programming, I could do it where things are both pushed on the stack and on the
hashmap? I call the same procedure, but the procedure behave differently depending on the global
state.]

[Also, I feel like I can still do currying. Everytime I take an argument, I push something on the
stack, and stuff, except the thing that I pushed is a procedure that take the remaining arguments,
and then returns the actual body of the procedure.]

[Types, types, types!]
my-list to-iter
[make like rust iterables? [.next] I mean. And more importantly, lazy and infinite.]
0 -1 iter [is an infinite data structure?]
map [x] [x * x]

proc [] [type _ == [Vec 8] ? [logic] [Iter]] as [a-way-to-do-overloading]

[The two most basic types are Code and Data. All other types are derived?]

fork ? [] [
    print [Hello, Async!\n]
    exit 0
]

[Reference type]
item [str1] [hello]
item [str2] [hello]
str1 == str2 [true]

ref str1 as [str1]
ref str2 as [str2]
str1 != str2 [true]

[Everytype is by value by default?]
[Like, we have arbitrary sized integers, but with strings too. Strings are just very, very long
integers. So they should behave the same.]

[I should find a way to do a hashmap without malloc... Or just put everything on the stack?]
Variable :: {
    name : String
    type : String
    size : i32
    value: Any
}
[I don't know...]

struct [Variable] [
    name String
    type String
    size Number
    value Any
]
[Type could also just be [Structure]]
[I guess [item] should then push this on the stack?]
[Also, how do lookup in the outer scope? Also also, I guess I can't do [item-in] any more...]
[No, the first variable of a scope is basically just metadata about the outer scope.]
[Wait, I don't even need [item-in]! When the scope is gone, all my variables are still there! I
just write over them, or be clever and write them where they should've been to begin with!!]

[Okay. This is one of the most interesting ideas I've had in a while.]
[I don't even think it's that much slower than a hashmap, despite being linear and stuff.]

[But happens here?]
1 + 1 dbg
[is [name] equal to null?]

[Also, an [env] could just be another variable on the stack, except its size is the size of every
other variable combined?]

a = 2 [is possible because] push a [is equal to]
Variable [a] [Undefined] 0 []
[or something like that]
[and then, we simply reassign the value to 2.]

[also, when we lookup the stack, we go from the of the stack.]
[Damn! Just realized how easy looking up into multiple environments is with this model! Damn I'm smart!]
[Also, if there is a [stack] variable, it is in the bottom of the stack everytime.]
[Also also, shadowing.]

[Honestly, it's probably nowhere near as fast as a hashmap... thinking about it for real, the
bigger the application (and they get pretty big), the slower it will get, exponentially.]

[Still, unlike a hashmap, I can define variable length values – scrath that. In a hashmap, I can do
it as well.]
[Wait, what about pushing pointer to the procedure you will use a lot in the start of a scope...]
[No no no. Before that, isn't it the job of the programmer to ensure that the stack has no bloat
that make the linear search take forever?]
[Even before that! Procedures are compiled to begin with, so it should take that long?]
[... Or maybe I should have multiple stacks?]

4
[==]
Variable [_] [Number] 3 4

[[Mutable] and [Immutable] types?]

[Maybe [import] is a procedure that returns variables on the stack?]

[If the language become so stack centric, should everything be a function that return their value
to the stack? Even variables?]
[^ Functional refuses to die.]

i32 [name] 1
[is equivalent to]
Integer [name] 2 1
[where 2 is the size]

[don't forget]
malloc(typeof(Entry) + entry.size)
[or something like that.]

eval fn [] []
[maybe [_] is latest stack variable?]
[damn, don't even need [return]]

[since every variable has a type, you don't need to "call" a variable. but the syntax makes it look
like you do.]

[both item and as work for declaring a function]
let [f] fn [] []
fn [] [] as [f]

[discard]
let [] func-call

[[eval] is called on the arguments of a function...]
[I should give crafting interpreters another chance. The type system is a real pain in the bum.]

[overloading]
fn [arg1] [
    string? arg1 ? [stuff] [
        throw [Unsupported type: %] type arg1
    ]
] as [overload]
fn [arg1] [
    number? arg1 ? [stuff] [
        overload arg1
    ]
] as [overload]

[I don't even need [item-in]...]
[type [Struct Vector]?]
[objects and templates? or prototypes?]
[but a prototype is just another object...]

item [val] do [1 2] as [val2]
item [val] do [1 2] next [val]

[maybe every variable should have a padding, to allow for arbitrary sized values?]
[you can call clone on any object?]

[damn, i can do] var . proto . type
value size [where [size] is just another overloaded function that check the type of the value in the stack?]

[this just doesn't work]
a == b || b == c

sqrt 9 [returns special type? like an [Or] type that means the value can be any of the list]

[has to be + a b for constexpr]
let [VALUE] + + 1 2 + 3 4

[interesting: using this model, there is no mutation from inner to out block...]
[or not? how do I do globals?]
[maybe I should let and set like other programming languages?]

[oh shit i can do static methods...]
Object [
    [name] [test-object]
    [func] fn [] [
        print [This works!\n]
    ]
]

[eveything is not a function, but everything behaves like one, syntaxically]
[everything is a "function", including types]
[I should do [functions.c]]

[Maybe there shouldn't be a distinction between code and data... You're gonna have to call a
function anyway, to push the data on the stack and stuff...]
[memcpy and stuff.]
[everything behaving like a function but not really being one could be the best way to implement
lambda calculus on a computer...]

[I may be giving up on [proc] too quickly. I feel typeless is pretty much dead now, tough.]
[Still it is a fact that procedural made me agonize over a few things. – Honestly, I should be more
open to experiment with shit, even if it's not going to bear any fruit.]

let [ret] func-call
ret match
    [Some a] [print a]
    [None  ] [throw [Failed to unwrap monad.]]

length list
clone vec

[Initially, I wanted functional. I should try it. If it doesn't work, then too bad.]

let [C] import [libc]
let [main] fn [] [
    let [a b] i32 3 i32 4
    let [result] C.add a b
    print [% + % = %\n] a b result
]

let [true ] fn [x y] [x]
let [false] fn [x y] [y]

[I should have a function that takes piece of code and debugs it step-by-step]
debug [
    print [Hello, World!\n]
]
[Similar to a GDB or LLDB breakpoint, it halt the execution of your code to enter a TUI debugger
for the requested piece of code.]

let [func] []
do [
    set [func] fn [] []
    defer [munmap ptr-to [func]]

    [fine]
    func
]
[will segfault]
func

[do I really need fexpr?]
[I mean, I just need to pass in a string to a normal function. No... Every function is an fexpr
(or macro) by default; they just choose to always evaluate the arguments. And you can still use
[macro], but it's like really deep in the language, and not idiomatic, I guess.]

let [c] char [🤓]
             [  ]

let [a] 123
let a = 123;

let [a] i32 123
let a: i32 = 123;

let [io] import [System/IO]
io.print [Hello, ]
use import [System/IO]
print [World!\n]
use [
    import [System/String]
    import [System/Syscall]
]
import [System/String] as [text]
print text.reverse [Hello, World!\n]

[I should probably make it so that everything in the language follow this form:]
let [symbol] [something]
[like this]
let [number] 4
let [string] [Hello, World!\n]
let [function] fn [] [
    print string
]
let [person] Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
let [person2] clone person
let [person2.name] [Jane Doe]

[also, I just had a brilliant idea for objects:]
let [sys] import [System]
[is problematic because [import] returns an object, and how is [sys.something] defined then? Well,
[let] manages that. It checks if the value of the assignement is some sort of object, and if yes,
does seperate assignements for all the fields. Clever, right? Right??]

[wait a second.]
let [] import [System/IO]
.print [Hello, World!\n]
[right?]
[no, it shouldn't work like that...]

[Maybe take the zig route?]
let [std] import [std]
let [print] std.debug.print

[Still, I wanted [import] to work a bit like [load]]
let [lib] load [lib.txt]
let [sys] import [System/]
[or something like that]

let [Vector3] fn [x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [vector] Vector3 1 2 3
println vector.x

[I should try to implement dependent types, since this language already blurs the lines between
compile-time and runtime. Also, it's a good way to learn.]

[By the way, this language probably won't have any tuples, since those are basically just
structures.]
let [tpl] tuple [1 [Hello, World!\n] 1/3 Vector3 1 2 3]
let [tpl] Object [
    [0] 1
    [1] [Hello, World!\n]
    [2] 1/3
    [3] Vector3 1 2 3
]
println tpl.1 [outputs [Hello, World!\n]]
[then again... they are objects, but [tuple] could just be a shorthand (macro or function) to avoid
naming things inside the object]

[Also, enums]
let [] enum [
    [Monday]
    [Tuesday]
    [Wednesday]
]
println .Monday [outputs 0]
[I guess this is similar to a tuple. That is to say that it's just some macro for shorter object
initialization.]

[People talking about arbitrary compile-time execution; I talk about arbitrary runtime compilation.]

let [func] fn [] []
let [func] ptr-to [func]
let [func] val-of [func]
func [works]

print type-of Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
[will output:]
[Object [
    [name] [String 10]
    [date-of-birth] [Date]
]]
[or something like that]

[I should do Elm style, that also compile to html/css/javascript]

let [n] 10
let [test-fn] fn [n] [
    while -- [n] [
        println n
        n
    ]
]
let [factorial] fn [n] [
    as [arg1 arg2]
    while != arg1 n [
        * arg1 arg2 as [arg1 arg2]
    ]
]
test-fn n
factorial n

[hmm.]
[maybe everything should be an S-expression...]
let [test] ? condition [
    do-something
] [do-nothing]
[yeah, this code is impossible with the old model.]

let [condition] or = 1 2 ≠ 2 2

[Maybe I should just use a VM. The only difference is that the vm is for arm64 assembly?]
[Man, I wouldn't have this headache if the OS just allowed me to make things for writable and
executable.]

ls | sort-by [size] | reverse
[is there a way to implement this?]
[maybe I should reconsider the very first approach]
reverse sort-by ls [size]
ls push [size] sort-by reverse
[no, if I wanted multiple return values, I can't]
let [value1 value2]
    reverse sort-by ls [size]
    where ls [> size 1kb]

[maybe it's just a macro?]
ls | sort-by [size] | reverse
[is equivalent to]
ls ; sort-by _ [size] ; reverse _

[Maybe there is a stack type and a heap type?]

[Pattern matching?]
if let [value] dup func-call [
    debug value
]
[[dup] for duplicate... or should I overload [clone]?]

[[mut] instead of [set]?]
[because [set] was paired with [get] for array assignment and retrieval.]
[or [set] could just be overloaded.]

2.0
let [number] print [number: ]
println number [outputs [number: 2.0]]

[I guess floats should have a precision field so it actually prints [2.0] and not [2.000000]]

clone value
length value

[I forgot: modal programming!]
ls | reverse
[[ls] pushes an array of characters onto the stack. [|] changes the mode to [Piped]. [reverse]
looks at the mode first before executing.]
[Then again, maybe every type can become piped?]

let [_] last-stack-item
[special type?]

[[=] vs [==]]
[value vs reference]
let [str1] [test]
let [str2] [test]
println =  str1 str2 [outputs [false]]
println == str1 str2 [outputs [true]]

printl [vs] println [?]

[Oh mother fucking shit!]
compile opt [
    [filename] [Terminal]
    [filetype] [ELF]
] [main]
[^ an [Options] type!]

[I will probably still have a [return] function.]
let [print-unsigned] fn [number] [
    if < number 0 [
        return Error [Number too small.]
    ] []
    printl number
    return []
]
let [e] print-unsigned -1
if != e [] [
    throw e
] []

0 ~ print [%i\n] _
0 ~ print [%\n] _
print [%\n] ~ 0
print ~ 0

if condition [
    func-call 1
] [
    func-call 2
]

print 1 \n
let [\n] fn [] [
    print [\n]
]

print [\%] [outputs [%]]

[zig is great, yeah, but I feel like I want this language to take more after jai]
let [items] Array [
    ptr-to [print]
    ptr-to [let]
    ptr-to [\n]
    ptr-to [ptr-to]
    ptr-to [Object]
]
for items [print it \n]

[hmmm, [[]] made sense before, when I had [item-in] for return values, but now, not so much.]
let a 2
let str [Hello]
let [push-str] [[ world]]

[become more lispy by the second. wait till I add this revolutionnary feature called
((("parentheses")))]

[lispy formatting]
let [render] [
    fill-rect proj-rect proj-x proj-y
              unpack-color PROJ-COLOR
    fill-rect bar-rect
              unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
           fill-rect target-rect it
                     unpack-color TARGET-COLOR] []]
]

[this might be better; more consistent with the [for] loop's format]
let [render] [
    fill-rect proj-rect proj-x proj-y
        unpack-color PROJ-COLOR
    fill-rect bar-rect
        unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
            fill-rect target-rect it
                unpack-color TARGET-COLOR
        ] []
    ]
]

[or all in one line; but hard to read]
let [render] [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool [if ! it.dead [fill-rect target-rect it unpack-color TARGET-COLOR] []]
]

[I suppose lispy formatting will eventually grow on me, like vertical alignement, but right it's
either the second format or all in one line. For all in one line, I could just assign to a variable
if it gets too long. I believe this is the pythonic way of doing this.]

[Also, I don't have to worry about readability like before, since with the new type system, syntax
highlighting will be much better, probably.]

let [func] [
    func1 func2 func4
                func5
          func3 func6
                func7
]

let [func] [
    func1 func2 func4
            func5
        func3 func6
            func7
]
[yeah... the second one is hella ambiguous.]
[as ugly as it looks, the first one is objectively better.]

[no, if I multi-line a function call, I do it the C way.]
func-call
    func-call
    variable
    func-call

func-call(
    func-call(),
    variable,
    func-call(),
);

[The formatting problems only occur when I push the first argument on the same as the function
call. If I don't do that, then all is good.]

[[dup] vs [clone]]
[dup: pushes a copy of the value attached directly to the symbol; like numbers, floats, and
pointers.]
[clone: clone value being referenced by symbol; like Arrays, Objects, Strings, and things pointed
to by pointers.]

[another reason to do it like this]
let a 2
++ a

[what about reassigning [let] and [++]?]
[I suppose I just have to not use them for the reassignment? Like how [let] and [++] where
initially assigned?]

[It's basically recursion vs easy overloading...]
[But the minmax algorithm is a pain in the ass without recursion...]

[The same way a function gets called when [do] is called with it as an argument, should an [Object]
expand to just the fields?]
fn [x] [print x \n] [Hello, World!] [outputs [Hello, World!\n]]
Object [func fn [] [print [Hello, Again!\n]]]
func [outputs [Hello, Again!\n]]

[Wait, this may be a way to do multiple assignment?]
Object [
    [var1] 1
    [var2] 2
    [var3] 3
    [var4] 4
]
print var2 [outputs [2]]
[Interesting. I should consider it seriously.]
[Granted, you can no longer do this:]
fn [] [] as [func]
[But so what? You're not supposed to anyway.]

import [System/IO]
print [Hello, World!\n]
let [io] import [System/IO]
io.print [Hello, Again!\n]

[holy fuck, I don't even have to use [use]!]
let [func obj] [
    print obj.var-within-obj
    obj
    print val-within-obj
]

[Damn, nevermind. There's a discrepancy between returning an object and exposing it's fields.]
let [func obj] [
    print obj.var-within-obj
    use obj
    print val-within-obj
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[There also another problem...]
let [arguments] [
    1 2 3
]
Vector3 1 2 3
[vs]
Vector3 arguments
[vs]
Vector3 arguments [] []

[that is to say, should a function know how many arguments an argument actually is?]

[maybe it's not that bad? it's a question of [use] vs [return]...]

[imports]
use import [System/IO]
import [System/IO]

[Object initialization]
let [Vector3 x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[multiple variable initialization]
use Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]
Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]

[and functions]
do fn [x] [print x] [hello]
fn [x] [print x] [world]

[I guess function returns are not exactly related to Objects returning...]

[oh shit. suppose functions do have meta data concerning argument count.]
let [func] print [Hello, World!\n]
let func print [Hello, World!\n]
[the first one is lazy, the second one is eager.]

[maybe I can use that to mix in eager and lazy in a function?]
let [func x] do [
    print x

    [this has to be function, since [x] is not known yet.]
    let [value] + x y

    [this is basically function composition.]
    print value
]
[it returns a string if I don't put [do]?]

[I should consider function metadata more seriously.]
for items print it
for: item items print item

[I guess macros, which is what all functions are built off, would need to figure out the function
metadata.]

let [fib n]
    if or = n 0 = n 1
       n
       + fib - n 1
         fib - n 2

let [fib]
    : : 1 1 zip-with [+] fib tail fib

[I guess I should do function overloading? But instead define types that are comprehensive enough?]

[need [println] if I want single line functions]
let [say-hello] println [Hello, World!]

[I don't know; I've been implementing features to get syntax I want, not for consistency...]

let [say-hello] println [Hello, World!]
let ptr ptr-to [func]
val-of [ptr] [outputs [Hello, World!\n]]

[Dude, haskell is insane: I looked up how to implement a [Vector3] object or similar in it, and was
extremely shocked! Gasp!]

data Vector3 = Vector3 { x :: Int, y :: Int, z :: Int }
    deriving (Show, Eq)

main = do
    let v = Vector3 1 2 3
    print $ x v

[this is fucking insane. I can't believe haskell implemented the stupid idea I had! And weirdly too! Since you can't overload [x]...]

[By the way, [import] opens a file, reads it, executes it... then what? how is it turned into an object?]
[I guess, maybe, it somehow convert the [env] into one?]

[Shockingly, typescript is the most similar to what I envision the final implementation could look
like... Well, not syntaxically of course. You know, the prototypeness, structured types and stuff.]

[Should the language require to specify mutable input?]
let [func mutable-input constant-input] do [
    set mutable-input constant-input
]
[something like that?]

[Should an array be an object?]
[I should have an [Object.Field] type]

[how do I insert the fields of an object in the initialization of another object?]
let Person Object [
    name []
    age  []
]

let Citizen Object [
    Id  []
    use Person
]

[but then, there is no way I could make the name field non quoted...]

[typescript's way of combining types with [&] is really nice and elegant! I should take notes.]

[Maybe I should make the stack have a variable length? Like, I [calloc] when pushing makes the
stack too big? Or maybe not? I mean, when variables have a symbol associated with them, they are by
default on the heap, in a hashmap... There limited cases where this is useful.]

[Also, I should the functional implementation with a very simple version of [let]. None of that
fancy syntaxic sugar please. Though I will implement it eventually, and see how good it is.]

[I'm just gonna use [use] too, at the start at least. Again, I will try a lot of things.]

[Is it possible to make the language fully functional in syntax, but it actually mutates a lot?]

[I'm going too far down the functional rabit hole...]
object [] as [Vector3]

proc [x y z] [
    object [
        [x] x
        [y] y
        [z] z
    ]
] as [Vector3]

[I'm feel like I should only symbolic programming, but quoted symbols are basically pointers...?]

let [Vector3 x y z]
    Object [
        x x
        y y
        z z
    ]

[functions have arguments in type, macros do not]
[function types is according to first use?]

let test-macro macro [print next-token]
[wait – no no no!]
let [test-macro] print next-token
[macros are just functions without arguments!]

[maybe true and false are macros?]

print type-of [Vector3] [Function 3]]
[for 3 arguments]

[wait]
for 3 printl it
[?]

[hmm.]
let [Vector3 x y z] todo
let Vector3 x y z = todo

[[Object] should be capitalized like [Vector3]]

[complex numbers]
let z + 3 4i
[or]
let z 3+4i

[I talk about inconsistency, but what about [[]]? How do you return a string?]
[I guess a string is basically an array?]

let [ret-str] do [
    String [Hello, World!\n]
]

let value Pattern [1 5 25 125 625]

[[Alias] type?]

[I should figure out how to infer function types without arguments. Like, you have macros, but the
macro behave exactly like a normal function, except it's written like a macro just because. And I
should still be able to infer the type (not the implementation though)]

[oh shit]
load-bin [/bin/]
mv [path1 path2]
type mv Function [String String []]
mv path1 path2
[maybe?]

[I think I will still do [let-in], otherwise, some macros can me a pain in the ass.]
[I could make it so the type of a function is infered from it's first use; that or pretyped.]
let [func1 arg] arg
func1 123
[or]
type func2 [Function String]
let [func2 arg] arg
print func2 [Hello, World!\n]

[Then again, no. It should be infered from usage. Like duck typing.]

[I was thinking that arrays could be objects, but why not the reverse?]
let "vector3" [1 2 3]
println get vector3

let ["func" "arg1" "arg2"] func arg1 arg2
[This is weird. I don't like it. Still, the Haskell way, of not really having object should be
explored.]

[maybe [+] is overloaded for objects?]
let [Person name age] Object [
    [name] name
    [age ] age
]
let [User name age] + Object [
    [id] random 0 ^ 2 64
] Person name age
print User [test-name] 123
[outputs:
    [
        [id  ] 123857120581204
        [name] [test-name]
        [age ] 123
    ]
]

* 100 - .5 random

[It makes me gag, but every value should be an object. Well, a tagged union to be exact?]
let [val] 123
debug val
[outputs
    [
        [type ] Integer 32
        [value] 123
    ]
]
print val.type [outputs [Integer 32]]
print val [outputs [123]]

let [obj] Object [
    [name] [test]
]
extend [obj] [age] 43
print obj
[outputs
    [
        [name] [test]
        [age ] 43
    ]
]

[maybe special syntax?]
:= variable field

[I should add named arguments...]
let [test] [
    let token next-token
    if == [-] * token
        match token [
            [-o] set output-name next-token
        ]
    let file next-token
]
test -o main main.txt

let [func arg] print arg
let [func] print eval next-token
let [func] print next-arg

[doc function]
doc [print] [
    prints formatted output to stdout.
    automatically call [to-string] on non-string inputs,
    and [format] on string inputs.
]
help [print]

[functions are colored but only for the linter? like, a symbol will be orange is if it is unsafe?]

[[;] for eval?]
print [Hello, World!\n] [Hello again.\n] ;
print [final hello\n]

[no, remember. a function that an infinite number of arguments. only, it call the functions passed
to it. and the next statement is just that, an argument passed to it, that never returns because it
also calls another function.]

[huh. so i guess you can just do this]
+ 1 2 3 4 5 6
[no, it doesn't work.]
+ + + 1 2 3 4

[LISP has parentheses, I have types.]

[A big reason for function compilation to be lazy, is inter-recursion. I'm pretty sure I saw it in
the 'C programming language book', but there are case where functions doing recursion one after
another makes sense.]

[maybe "" is pushed on the stack, [] is not? and that's the only difference?]

[I should let go of the old object system, and instead have prototypes and instances, where the
object itself is just a macro taking a symbol, and matching it with stuff.]
let [test-obj] do [
    let [token] next-token
    match token [
        value    5
        function do [
            printl [Hello, World!]
            do next-token
        ]
    ]
]
print test-obj value
test-obj function print [rest of the application]
[vs]
print test-obj.value
test-obj.function print [rest of the application]

[hmm]
my-list iter filter fn [item] == item id 132 collect
collect filter fn [item] == item id 132 iter my-list
[btw, this can't be done with [my-list.iter]. you need () function calls and actual [.] syntax.]

[while this is technically the same, it isn't. One requires function overloading, the other
doesn't, and can be done using macros and functions.]

[more importantly, the initial way I had planned to structures was to just take a slice of an array
using [get-at], but it sucked. Still, if I just have the same behavior, but with pre-built
functions attached to a macro object (yeah, just came up with this name). Still, doing mutation is
now kind of hard...]

[also, this model allows for prefix, postfix and infix functions in a more natural way.]

[no. how does [my-list iter] know whether to call the next token, or to just return an iterable?]
let my-iter-list my-list iter []
print my-iter-list filter fn [item] == item id 132 collect
[nah, prefix syntax is just simpler and better.]

my-list iter [filter fn [item] == item id 132 collect]
let my-list my-list iter []
my-list [filter fn [item] == item id 132 collect]
[maybe?]

[it's not that difficult when compiled, but when prototyped...]
let [test-func1] printl eval next-token
let [test-func2] test-func [Hello, World!]
[this should work, since macros and functions are equivalent... but it probably won't be that
simple.]
[I guess [test-func1] is a function taking no arguments, and that's it. But then, they aren't
equivalent...]
let [test-func text] printl text
let [test-func] printl eval next-token
[to make them equivalent, I need to check if [next-token] is called, or just use [] for nesting
everywhere...]

[Even if I don't actually compile, emulating the compile once, then execute every other time is not
that hard.]
[Or should I just start of with proper compilation?]

for range 0 10 printl it
for-in i range 0 10 printl i

fill 255
fill rgb 255 0 0
fill rgba 255 0 0 255
[since object are also functions/macros, this is possible]

do-version file [./main.txt]
do-version 2.5 code [
    printl [Hello, World!]
]
[[file] and [code] both just change the type of a thing.]
[or maybe it should be [cast File [./main.txt]]]
[or just [
    File [./main.txt]
]? That is to say, capitalized.]
[in any case, [do-version] is basically just a function that can execute any version of the
interpreter. perfect for backwards compatibility.]

let [test-func obj] printl obj.name
test-func object [
    name [John Smith]
    age  34
]
[should age also be passed to test-func? or is this equivalent to this:]
let [test-func name] printl name
test-func [John Smith]
[are objects just syntaxic sugar to avoid have 100 arguments to a function?]

let [func n]
    if == typeof n [Number]
        printl n
        overload func n
[basically explicit overloading. the overload function basically just calls the initial version of
the function (throws if it doesn't exist) and doesn't do recursion.]
[I either do OOP/Prototypes with [this], or overloading. There isn't really any reason to do both.
I guess I could, but prefix syntax for everything seems cleaner.]

[I should avoid putting methods in structures.]

let [f x] - 1 * 0.5 x

let value do [
    let val1 69
    let val2 420
    let val3 + << 69 3 420
    val3
]
printl value [outputs "69420"]

[i should have a function called [delete-computer]]

[then again, I guess I could try some form of implicit function overloading?]
[i mean, there's no real reason redefine a function and remove the initial definition, right?]
[and overloading will be everywhere, so I should make the syntax as simple as possible]
[i should use the terminology [overloading] and [overriding] to make it easier to talk about.]

[should I force the use of [return] inside a [do] block?]

[[alias] vs [new-type] vs [ref]]

[[loop] is the only thing you really need.]
[I can't buil [for] and [while] loops using recursion unless I figure out the performance issue]
let i 10
loop [
    print "Hello, World!\n"
    if ! -- i break []
]

let [for] do [
    let [init] get-arg
    let [cond] get-arg
    let [incr] get-arg
    let [body] get-arg

    init
    loop if cond do [
            body
            incr
    ] break
]
for let i 10 != i 0 -- i print "Hello, World!\n"
[I might need some seperators...]
[But anyway, [loop], or at least [goto] needs to be a built in construct]

[I guess I could have a [optimize] function that copies all the function that where defined packed
together, then unmaps the old memory, then continues running with the new memory? Then again, all
the pointers will be wrong. And it will be a pain to change them all...]

[macros will work if we first define the type before defining the function?]
type add-macro Function [i32 i32] [i32]
let add-macro fn [] [
    return + next-arg next-arg
]
let [add-two n] add-macro 2 n
[[return] is of course optionnal]

[this language does have implicit return, but it's not for use all the time. only when it makes
sense.]
let value if condition 5 0
[right, [return] also exits a function, so that should be kept in mind.]

[I should just have () in case someone wants to be more explicit with their code?]
[But I just don't ever want people to use it.]

[[Quote] and [String] types should be different. A quote can become a string, but it can also
become a array.]
[Like [Number] can be either [Integer], [Float] or [Fraction].]

[There should be multiple ways to construct a [String].]
let my-str String 4
set my-str "hello" [Error: Type mismatch, String 4 -> String 5]
let my-str String "hello"
print type? my-str [outputs "String 5"]
let my-str "hello"
print str-len my-str [outputs 4, because [str-len] is overloaded to take both [String] and [Quote]]

[Just realized that I don't need to make [String] a struct/object because the length is stored in
the type!]

[Wait. So you can do this?]
type my-str "String 5"
set  my-str "Hello"

[Also, characters]
let my-char 'b
[No need for two single quotes. It's probably just a shorthand for this:]
let my-char Char [b]

[I don't do this anymore, but I used to.]
for [let i 0][< i 10][++ i] [
    printl i
]
[If "][" was ";", I could do this]
for [let i 0; < i 10; ++ i] [
    printl i
]

[Hmm, maybe types are variables?]
[Like enums, I mean. Everytime a types gets created, a number is assigned to the symbol.]
let [MyNewType] String
type my-str MyNewType
if == type? my-str String then [
    printl "They are the same type!"
] else [
    printl "They are not the same type!"
]
[where]
let [then quote] do quote
let [else quote] do quote

[but then, I would need to...]
let my-str new String 5
let my-str new String "Hello, World!\n"
[where new is overloaded... but then again, how?]
[[String] is always of type [Type]!]
[Maybe I need two namespaces for types and strings, but I don't like the idea of that.]
[What if I want to pass a type to a function?]

[But then again, if the value a type is a function pointer... I could make this work.]

[[type?] vs [meta?]]
[[type?] gets the first part of the type string, a symbol, then returns its value.]
[[meta?] gets the latter part of the type string; basically the dependant/refined type metadata
like the length of a string/array.]
[don't know about the question mark]

[What happens if...]
let [String] Integer
[I imagine the other types that depend on [String] change not, but about these?]
if == MyNewType String
    print "Yay!\n"
    print "Nay!\n"
[I imagine it shouldn't break older pieces of code like this.]
[If it does, you call that dynamic scoping, and that's bad!]

[actual, [println] is good! that way I won't feel any obligation to use it!]
[Wait no. I just need [\n] as a function.]
println 123
print 123 \n
print "%\n" 123
[equivalent to this in scheme]
(display 123) (newline)

[I should give tail recursion a real try. If I can successfully implement it, it will make looping
so much nicer.]

[Casting from value to pointer should be done implicitly, or not?]
let obj Object []
let [test-func obj] do [
    set obj "Hello, World!\n"
]
[Then again, no?]
let obj ptr-to Object []
let [test-func obj] do [
    set obj "Hello, World!\n"
]
test-func obj
print obj [outputs "Hello, World\n"]
[^ now this works?]
[is the pointer/value overload implicit?]

[[type] to declare things is a little silly. [let] should always be used with default
constructors.]
let str String 10
set str "Hi!\n"
[but is it on the stack or on the heap?]
[wait, [String] allocates space? It doesn't just change the type?? Damn, that change things...]
[Or is it only being reserved? And only actually being allocated when being assigned... Then again,
it's also probably just static memory. You can get the string in the source code, after all.]

[[var] vs [let]]
[Yeah, I need immutable data. Probably a type thing. Maybe every symbol has it?]

[[Float] and [Integer]]
[When you don't want to think about the size of a value, or it's just not important, there should
be a way to not have to specify it.]
[
    Float
    Float 32
    Float 64
    Integer
    Integer 8
    Integer 16
    Integer 32
    Integer 64
]
[[Float] and [Integer] just default to 64 bits. When you use them, you're telling other it doesn't
matter.]
let n Integer []
[but you usually just use inference I guess.]
[Hmm, it's faster to just assign it to zero.]
[But what if you want it undefined?]
let n []
[can be used later.]
[wait, should I use i64 and int and such?]

[Maybe I should add syntax?]
let a 2
let a = 2;
[The latter is more verbose, but it's clearer what's happening.]
let [add a b] + a b
let add a b = + a b;
[The great thing about the latter, is that variables and functions do behave the exact same way.]
add 1 2
add 1 2;
[I guess I don't really need the semi-colon.]

[But if I add syntax, I would rather go the Jai route than the Ocaml route.]
add a b :: + a b
[Nevermind. It sucks. You can see why.]

[By the way, how does Ocaml do inference?]
[Holy fuck! ChatGPT tells me it look into the body to figure that out!! That's what I was trying to
do!!!]
[Damn, this is interesting. So I guess I could make the language look dynamic without actually
making it so.]

[I should dynamically load [printf] from libc just as a proof of concept.]
let value = 123
printf "My value is: %i\n" value

[[symbol] could a be a function that returns the symbol of an argument before it was passed to a
function?]
let macro a = print symbol a
macro hello [outputs "hello"]

(define (reverse-list lst)
    (let loop ((prev '()) (current lst))
        (if (null? current)
            prev
            (loop (cons (car current) prev) (cdr current))
        )
    )
)
(display (reverse-list (list 1 2 3 4)))
(newline)

let [reverse-list lst] do [
    let [loop prev current]
        if null? current
            prev
            loop cons car current prev
                cdr current
    loop [] lst
]
println reverse-list [1 2 3 4]

[I naturally took some liberties. My language having a rich type system, it doesn't actually need a
[list] function (though it of course can be added). Also, [let] behave like [define], and could be
more accurate if the original version of the code was written use it... Still, shockingly enough,
the parentheses make it easier to read. I guess you need a pretty good LSP for this language. I
guess I also don't really need [null?] – in either of the codes, too! Nevermind, just tried it and
['()] is not falsy. Shame on you Scheme! So yeah, advantage for my C-like language.]

let [reverse-list lst] do [
    let [loop prev current]
        if current do [
            loop cons car current prev cdr current
        ] else [ prev ]
    loop [] lst
]
println reverse-list [1 2 3 4]

[do/else is probably better than then/else.]

let [reverse-list lst] do [
    let prev []
    let current lst
    while current do [
        set prev cons car current prev
        set current cdr current
    ]
    return prev
]
println reverse-list [1 2 3 4]

[As usual, imperative is so much easier to read.]

let [add a b] Function [int int int]
let [add a b] + a b

let [greet] Function [void]
let [greet] print "Hello, World!\n"

[Not too bad, but it doesn't work. Because types are values, [greet] essentially just returns a
type.]

let [StringAlias] ptr-to [String]
[vs]
let [NewStringType init] String init

if == ptr-to [StringAlias] ptr-to [String]
    print "The types are the same!\n"
else
    print "The types are not the same, but they behave the same!\n"

[The language doesn't have name arguments, of course.]
[Instead, you do it like JavaScript, where you pass in an object with all the options as fields.]

[For multiple return values...]
let [test-func value] do [
    if some-test value do [
        return [value []]
    ] else [
        return [[] Error [Value is incorrect.]]
    ]
]
let result test-func 123
print get 0 result [outputs 123]
[Hmm, the syntax is ambiguous. What if I want to return a string? Anyway, that's how – or at least,
something like this – that I will use to do multiple return values.]

[But then...]
if tail result do [
    let e tail result
    eprint e.msg
    exit 1
]
[I can of course shorten it...]
if tail result throw tail result
[Or just this?]
throw-if tail result
[It's probably safer since it check the type to see if it's actually an [Error].]

[Still, should I have something like this?]
print get-field [msg] e
[equivalent to?]
print e.msg
[the former is more verbose, but probably better because...]
let print get-field [print] import [System/IO]
[but then...]
let io import [System/IO]
io.print "Hello, World!\n"
[vs]
do get-field [print] io "Hello, World!\n"
[I guess I need both?]
[Wait a second!]
let print get [print] import [System/IO]
[Because of course [get] is overloaded!]
[I could even do this!]
let-get [print] import [System/IO]
[But what about this?]
let-get [print read] import [System/IO]
[I don't see why not?]
let-get print import [System/IO]
[This too?]
[Hmm, isn't this basically destructuring?]
let [test-func n] Result [n []]
let-get [value error] test-func 123
[I guess I could also overload [let-get] to work on arrays?]
[Maybe I should call it match?]
match [value error] test-func 123

[What if [.] was a shorthand for [quote] like [']?]
iterable .next
[Nevermind. It's ugly.]
[... Just like parentheses. But damn! Parentheses make so many things so much more simple.]

[I should have overloading for things like sorted and unsorted lists.]
let [element-of-set? x set] Procedure [Any Ordered[Any]] Boolean
set [element-of-set? x set] cond [
    null? set    #f
    = x head set #t
    < x head set #f
    #t element-of-set? x tail set
]
[Damn, this is hard to read.]

let numbers [42 17 93 8 56 27 91 35 74 3 88 65 12 39 81 53 18 99 47 23 77 6 50 28 96 84 31 62 11 4 90 48 66 14 19 87 45 78 25 70]

let [quick-sort ls] do [
    if null? ls [] else [
        let pivot head ls
        let rest  tail ls
        let smaller filter lambda [x] <  x pivot rest
        let larger  filter lambda [x] >= x pivot rest
        append [quick-sort smaller pivot quick-sort larger]
    ]
]

print quick-sort numbers \n

[macro?]
#type Procedure [Any List[Any]] Boolean
let [element-of-set? x set] cond [
    null? set   #f
    = x car set #t
    #t element-of-set? x cdr set
]
#type Procedure [Number Ordered[Number]] Boolean
let [element-of-set? x set] cond [
    null? set    #f
    = x head set #t
    < x head set #f
    #t element-of-set? x tail set
]
[where]
let [#type] do [
    let type next-arg
    if ! = next-token [let] error "Invalid syntax:\n\n%\n" next-expression
    create-procedure type next-expression
]
[Honestly, I like it. I should mention that you can still do overloading without explicit types,
but it will probably not be as smooth.]

[I should postfix change changing procedures without [!] like in scheme.]
let msg "Hello, World!\n"
print msg [outputs "Hello, World!\n"]
let [change-nothing] let msg "Goodbye, World!\n"
print msg [outputs "Hello, World!\n"]
let [mutate-state] set! msg "Goodbye, World!\n"
mutate-state
print msg [outputs "Goodbye, World!\n"]

[By the way, [let] is an expression.]
let val1 let val2 do [ 123 321 ]
print [val1 val2] \n [outputs [123 321]]
[[let] evaluates the expression then assigns the value at the end of the stack to itself.]

[Also, [List] can be an [Array] or a [LinkedList] or a [Tree] or whatever like that.]
[Though I guess it would need to flatten the tree?]
[What about B-trees?]

[Maybe I should add some syntax that isn't really syntax?]
append [quick-sort smaller  pivot  quick-sort larger]
append [quick-sort smaller, pivot, quick-sort larger]
[These two things are equivalent. the commas are just syntaxic sugar to make it easier to read.]
[Yeah, I'm pretty sure this is a step in the right direction. It's as simple as considering it
whitespace. [;] would probably also make the list.]
let a 2  let b 5
let a 2; let b 5
[I guess I'll call them "syntax" characters? Similar to whitespace, but added to give the language
syntax to make it easier to read. It's of course optionnal, but was judged necessary still.]
['(' and ')' will probably also make the list.]
print (quick-sort numbers) \n
[I don't know about [:] though... I wanted to use it in names and such...]
for range 0 10 print it
for: n range 0 10 print n
for-in n range 0 10 print n
[I guess I mostly wanted [:] for options and such, but I guess I dont really need it.]
[I can always use the type [Option] as the first argument if I really need to.]
let opt Option [with: "newline"]
print opt "Hello, World!" [outputs "Hello, World!\n"]
[Not the best example, but you get the gist of it.]
[Anything else? Can't think of anything.]
[I don't think I will do [=] though.]
let a 20
let a = 20
let a: 20
[Main reason: it just doesn't look that good.]

[Basically: '(', ')', ',', ';', ':', '"' ]
[Maybe ['] should be a short hand for ['a => Char [a]]]
[What about [{] and [}]? Can't think of anything.]
[What about...]
let [a b] {1 2}
let {a b} 1 2
let {a: 1, b: 2}
[... some sort of special destructuring syntax?]
[What if it's still a quote, but there a way to tell what kind of quote it is?]
print type? [] [outputs "Quote [Bracket]"]
print type? "" [outputs "Quote [String]"]
print type? {} [outputs "Quote [Curly]"]

[I should use these things in moderation. And on second thought, I don't mind adding 'syntax', but
it should remain fake, otherwise the language will become bloated very quickly. So I'm dropping the
{}; I just don't need them.]

[Should [Char] really be a type? Or just an [Integer]?]
print Char [a]       [outputs 97]
print type? Char [a] [outputs "Integer"]
[I think this should be the case, at least for now.]

[Holy shit.]
let obj Object [
    name: "John Smith",
    age: 32, #tag [Ignore]
]
[What ever [Tag [Ignore]] means, I don't know. Anyway, because the [Object] procedure is smart, it
will be able to see that there is an item of type [Tag] and not add it to the object as some field,
as well as add it to the metadata, or where ever the fuck. I can even something like [Private]!]

[Also, I guess it doesn't matter where the [Option] is passed?]
let opt Option [with: "newline"]
print opt "Hello, World!"
[is equivalent to]
print "Hello, World!" opt
[Because if [print] is responsible for executing the rest of the application, then it will have to
check the next argument regardless.]
[And I can have an implicit field in [Context] or [Environment] where I can extract the options
from.]

[I know I said no syntax...]
let a 2; let b 3
print "a b" [outputs "a b"]
print [a b] [outputs [2 3]]
[I mean I should right? Otherwise, it will become insanely verbose. And Scheme's printing of lists
is so nice to work with! I want some of that!]

[[xyz] is parsed as a string and matched to the symbols [x], [y] and [z]?]
swizzle vec xyz

[[=], [==] and [!]?]
print ! =  1.0 1 [outputs #f]
print ! == 1.0 1 [outputs #t]
[I don't know. I guess [=] is a 'loose' equal, while [==] is a 'deep' equal.]

[I guess it should be [#opt]?]
let file open "./random-file.txt"
print "Hello, World!"
    #opt [with: "newline", without: "format", output: file]
[I guess this is important also because a procedure can take a type of [Option] the normal way.
This is just a way to make sure the [Context] captures the options.]

[I should maybe go back to calling things [Word] and [List], because I'm struggling a little with
[Expression] and [Statement] (which is which?).]

[[import] returns a value of type [Module] which is overloaded with [do] to expand.]
import [System/IO]
print "Hello, World!\n"
[or]
let io import [System/IO]
io.print "Hello, World!\n"
[or]
let io #import "System/IO"
io.print "Hello, World!\n"
[because [#import] is actually a macro that expands to]
let io Module [
    let [print fmt] do [
        [INSERT PRINTING LOGIC HERE]
    ]

    [INSERT ALL THE OTHER IO PROCEDURES HERE]
]
[maybe?]
[I certainly prefer the [#] and ["] syntax.]
#import "System/Syscalls"

[Also, I need an [Or] type. For polymorphism or whatever.]
#type : Or [Number, String, Object[Any]]
let item proc-call-that 123 "will return" Object [random: "value"]
[Or should it be an [Inherit] type?]

[[#] is a prefix for procedures that modify the usual execution of procedures.]
[[#import] for example is a modification on [do].]
[[#type] is a modification on [let].]
[[#tag] is a modification on [Object].]
[[#opt] is a modification on every procedure, and their implicit [Context].]

["" (String) and [] (Quote) are both the same, in that they stop the normal execution of code, but
they are different, and procedures may overload them accordingly.]
[Or should I say [List] instead of [Quote]?]

[I guess I could just do [inline].]
let [square x] inline [
    * x x
]
square 4
* 4 4

[Maybe I should put the [#type] modifier after the assignment?]
#type Proc [Number, Number] Number
let [add x y] + x y
[vs]
let [add x y] + x y
    #type Proc [Number, Number] Number
[Nevermind, it's ugly.]

[Hmm.]
let [say-hello] do [print "Hello, World!\n"]
let [a b] [1 2]
print a \n [outputs 1]
print b \n [outputs 2]
[Damn!]
let list [1 2 3 4 5]
let [x y] list
[But no, it doesn't really work.]
[But I can figure this out! It's doable.]

[I guess this is better right?]
let [element-of-set? x set] cond [
    null? set : #f
    = x head set : #t
    < x head set : #f
    #t : element-of-set? x tail set
]

for 0..10 as i print i
[Damn, I just remembered why I decided to implement [println].]
[Anyway, I thought that I could've a [..] special notation for numbers but...]
let N 10
for 0..N/2 println it
[Yeah, that's illegal.]
[Anyway, big idea! [as] macro that changes [it].]
let [as] inline [
    let next-token.......
    next
]
[Fuck. I can't do it.]
[No wait. I can't give up.]
let [as] inline [
    assign next-token it
    delete it
    next-arg
]
[Something like that?]
for range 0 N as index println index

[I should use [print\n] instead. Just for shits and giggles.]
for range 0 N as index print\n index

[But...]
str1 :: "Hello, World!\n";
str2 :: "Hello, World!\n";
if str1 == str2 print true;
else print false;
[^ this will be true, because it's a strcmp, but...]
if &str1 == &str2 print true;
[this is the standard C [==], which frankly speaking makes sense... That being the case, do I
really need a loose equal?]
let str1 "Hello, World!\n"
let str2 "Hello, World!\n"
if == str1 str2: print "true"; print "false"                   [outputs "true" ]
if == ptr-to [str1] ptr-to [str2]: print "true"; print "false" [outputs "false"]
if = str1 str2: print "true"; print "false"                    [outputs "false"]

let new-print [print]
new-print "Hello, World!\n"
[this should work because there is a difference between quoted and a string, probably.]

[should be like this instead.]
#type [Proc Number Number Number]
let [add x y] + x y

[I guess [] can turn a procedure into a value?]
print add 1 2 [outputs 3]
print [add]   [outputs [outputs 0x1aebeff453 something...]
[no, it should print [add].]
[you can still call it. I just need to not forget the value-symbol-pointer relation.]

#type [Real Number]
[^ if a function takes any number type, then it first check the first type, then it checks the
second, until it either finds it or throw and error because this function does not this type.]
[basically this]
cons [Dog] cons [Mammal] [Animal]

[By the way, I'm reading SICP, and the Scheme way of doing dynamic dispatch is so interesting.]
[[#type] should be a macro for that.]
let [#type] inline [
    assign do [
        let type next-token
        if = next-token "let" do [
            error "[#type] only works on [let] procedures."
        ] []
        let name next-token
        let body next-datum
        put global.overloads name type body
        return [name (get global.overloads name type)]
    ] do-nothing
]
[something like this?]

[I guess I should be able to do something like this?]
map [+ 1] [1 2 3 4 5]
[and]
let test [print "Hello, World!\n"]
test
[^ this works and so does this]
return test
[but this is delayed?]
return [test]
[I guess [] is more of a delay than a quote?]

[Honestly, fuck it.]
cp -i file.txt folder/file.txt
[This should be valid code.]
[Okay, no. Too much.]
cp -i "file.txt" "folder/file.txt"
[Now this should be valid code.]
[But then again...]
cp "file.txt" "folder/file.txt" #opt -i
[I guess I change nothing.]

[Wait a second...]
let [add x y] + x y
[this is multiple assignment on one like...]
add, x, y = () => x + y, 1, 2
[it is just that the x and the y are delayed?]
[but how do I use this knowledge? If I think of this a currying, then this could become extremely
elegant.]

[All strings are delayed evaluation.]
[[extract]? [let-for]?]
[[+] is both a symbol and a pointer until it is used?]

[Moral dilemma: strings are procedures, at least on the surface.]
let add [+]
[vs]
let [add] [+]
[vs]
let add lambda [] [+]
[one should return a string/function, the other should be a function.]
[equivalent to this:]
(define add +)
(add 1 2 3 4 5)
(define (add) +)
(add) => #<procedure +>
[similarly]
let add [+]
+ [1 2 3 4 5]
let [add] [+]
print add [outputs "add"]
[since procedures are strings. strings need indirection to not be evaluated as strings.]

[I need to sit down and figure out the essentials. The language is a mess right now.

[List of things that will not change.]
    print "Hello, World!\n"

[List of things that may change.]
    let say-hello [print "Hello, World!\n"]
    say-hello [outputs "Hello, World!\n"]

    let [hello-str] "Hello, World!\n"
    print hello-str [outputs "Hello, World!\n"]

[I have no need for [#type [Proc Int Int Int]], just put all the arg types and the final type is a
procedure. For variables, just have the return type and nothing else.]
#type [int int int]
let [add a b] + a b

[Maybe a [#mutates] which marks a procedure call that mutates the global state of a program? To
help find bugs?]
[I should name asm instructions [move-register], [move-immediate], and some such. It's longer, but
clearer.]

[It sucks, but I should explicitly overload functions like in Odin.]
[Or not? What if procedures are either polymorphic or overloaded?]
[If I don't put an explicit type, they become generic, not dynamic?]
[So [sub n] and [sub x y] are overloaded without the need for a [#type]?]
[Nevermind, I can't do that.]

[What if [Text] is the most fundamental datatype?]
[This always always returns a string or [Text], but the receiver can parse it however they want...
but how does it capture variables?]
return [something something-else]

let val [print]
[calls [do] on [print] which makes it return a procedure pointer, but]
let [val] [print]
[calls]
let val lambda [] [print]
[which calls [reduce] or something which doesn't return a procedure pointer.]

[No, a procedure is always both a string and a pointer.]
let say-hello [print "Hello, World!\n"]
say-hello [outputs "Hello, World!\n"]
print [say-hello] [outputs "say-hello"]
print "say-hello" [outputs "say-hello"]
print ptr-to [say-hello] [outputs 0x(random pointer)]
print val-of [say-hello] [outputs "print "Hello, World!\n"]
print say-hello [outputs 14 (or strlen "Hello, World!\n")]
[I don't know. It's nice. I think I like it.]

[When we import binaries...]
load "a.out"
a.out ["Hello, World!\n"] [outputs "Hello, World!\n"]

#type [int]
load "a.out"
let n a.out []
print\n n [outputs "Hello, World!\n14\n"]
[or not. I think I had an idea, but I lost it.]

[Maybe I shouldn't bother with special function declaration.]
let add [
    let [arg1 arg2] next-arg next-arg
    + arg1 arg2
]
[no, even beyond that...]
let add [
    [[args] is the program code + offset for the current part of the program.]
    let [x y] args
    [which is equivalent to [let [x y] [1 2]]]
    + x y
]
add 1 2
[I actually really think I'm onto something here.]
[In LISP, it's all about linked lists, in this languages, it's all about strings.]

[Holy, fuck. [args] is a string, so it gets executed!!!]
let [print-2-words] [
    let [x y] next [args], next [args]
    print "%, %\n" x, y
]
print-2-words Hello World! [outputs "Hello, World!\n"]
[Also, [let] can go back to always being quoted... But isn't that a problem?]
[By the way, does [let] consume when doing [let [x y] args]?]
[No, it consumes when it's being run.]

let two + 1 1
let add [+]
let [str num] "Hello, World!\n" 123
[Whatever, I guess I'm keeping the non quoted [let].]
[You shouldn't be doing multiple function declarations anyway.]

[Hmm.]
let [str num] "Hello, World!\n" + 1 2
[What if num equals [+] and not 3?]
let [new-print] print
let new-print [print]
[equivalent?]
[I know this:]
let val + 1 2 [=> 3]
let val [+ 1 2] [=> + 1 2 (lazy)]
let [val] [+ 1 2] [=> "+ 1 2" (lazy)]

[Wait, I know.]
let [str num] "hello" 123 [str == "hello", num == 123]
let vals ["hello" 123]
let [str num] vals [str == "hello", num == 123]
[Imagine [vals] getting evaluated, and it being replaced with the first example because the braces
have gotten removed.]
let [vals] ["hello" 123]
let [str num] vals [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == ...]]]] You get the gist of it.

[Anyway don't think [+] should get evaluated. But I don't know.]
let [str num] "Hello, World!\n" + 1 2

let [read write] #import "System/IO"
[Then again... It should otherwise this isn't possible.]
[And honestly, there's not much point in it not executing...]
let io #import "System/IO"
#import "System/IO"
[These 3 should be valid always.]

[I guess I can't do this.]
let [obj2 obj1] obj1 obj2
[It will destructure obj1 otherwise.]

let test-proc [
    for args print it
]
[Honestly, wow. I really hope I can work this out, because fucking hell!]

[but what does [#import] return specifically...?]
[something like this?]
[
    read  [...]
    write [...]
]
[Maybe I really should have something like a distinction between strings and lists... That would
make it easier.]

let #import [
    let full-path (+ global.modules-path args)
    let file (read-entire-file full-path)
    return (reduce file)
]
[No, this is wrong.]
[I think I got it!]
[What does [#import]? Nothing, that's how I'll do it!]

#import "System/IO"
[is equivalent to]
let read  [...]
let write [...]
[maybe [...] should be the [error Not-Implemented] call?]
[anyway]
let io #import "System/IO"
[is equivalent to]
let io [
    let read  [...]
    let write [...]
]
[but that means you should be able to do this for every assignment?]
let val [
    let a 123
    let b 321
    + a b
]
print\n val.a
[Wait... Did I accidentally come up with a clever ass way to do objects?]
[The problem is this.]
let [read write] [
    let read  [...]
    let write [...]
]
[But I guess it's fine. Literals should not be destructurable.]
let pkg [
    let read  [...]
    let write [...]
]
let [read write] pkg
[this works!]

[Now that I think about it, I already had this idea for objects a long time ago.]
obj :: {
    a :: 123;
    b :: 321;
}
[Yeah, I didn't even use square brackets yet. It was that long ago. Before I even decided to
conceive this language.]

let obj1 [let name "John Smith"]
let obj2 + obj1 [
    let age 23
]
[and they even double as constructors.]
let new-obj [
    let field1 args
    let field2 args
]
let obj (new-obj 1 2)

[Wait!]
let test [
    return [1 2]
]
let result1 test
print result1 [outputs "1 2"]
let [result2] test
print result2 [outputs 1]
[That's how I do multiple return values.]

[The equivalent in Jai:]
result2 :: test();
print("%", result2); // outputs 1
[Actually, there's no real equivalent... You can return arrays in Jai, but I don't think you can
casually destructure an array like I did.]

let #import [
    let [module-name] args
    let file (read-entire-file (+ modules-path module-name))
    inline file
]
[Should it really be that simple? Seriously?]
[No, there's a bug somewhere.]

[For one, this is scoped, so the top level full import is discarded.]
let #import [
    let [module-name] args
    let file (read-entire-file (+ modules-path module-name))
    return file
]
[Wait, I changed it to a return randomly, but that actually makes sense!]
let io #import "System/IO"
[Now [io] runs the file everytime it is called.]
io
[nothing happens, but if the module had top-level prints, or it returned something, then that
would happen.]

[But no... I need to think about this harder.]
let f1 [
    return [print\n "hello"]
]
f1 [what happens?]
[I don't know. So I'm going to assume that it executes the text because that's what would make
[#import] work easier.]
let f2 [
    let g [print\n "hello"]
    return g
]
f2 [This also should evaluate.]
let f3 [
    let [str] "print\n \"hello\""
    return str
]
f3 [and this]
[When it becomes different is with [let].]
let ret   f1 [== [print\n "hello"]]
let [ret] f1 [== print\n]
[Ahh... This is becoming a bit of a pain. But I really need to figure this out.]

[Wait, [f2] returns [] or void. [g] is eager, so it gets evaluated.]
[Okay, I know. The thing I said about [f2] still stands.]
[[f1] also. For [f3], it's equivalent to this.]
let ret f3
ret [outputs "hello"]
let [ret] f3
print ret [outputs "print\n \"hello\""]
[which is of course equivalent to]
let ret   "print\n \"hello\""
let [ret] "print\n \"hello\""
[Wait, but how does the receiver know how the string was returned?]

let [str1] [print "hello"]
let str2 str1 [I guess this just doesn't get evaluated.]

[There should just be 3 ways for strings to be parsed, then again. Otherwise, is this a procedure
or a string?]
return [print\n "hello"]
return [1 2 3 4 5]
[God, then return value things are so damn confusing!]
[There are so many goddamn layers to it! It's never ending!]

[I wonder if I should make it so it's impossible for the language to error?]
[Probably not, but I could right?]
[No, some things need to error.]
tail []
[for example.]

[maybe?]
let imports do [
    #import "System/IO"
    [...]
]
[I guess I could also do this if I had "" and [] as different types.]
let imports #import [
    "System/IO"
    "..."
]

[Actually, I decided to create a file in which the list of things that will not change will go.]
[It's like a very barebones spec.]

[I've been thinking about it for a while, but fuck "procedure". It sound worse and looks worse then
"function" in every way. I'm using "function" from now on.]

[What about, if the function returns [], it matches on the fields, like an object. And if it
returns something, it is multiple assignment.]

[Destructuring]
let obj [
    let field1 123
    let field1 321
]
let new-obj obj
print new-obj [outputs []]
print\n new-obj.field1 [outputs 123]
let [field1 field2] obj
print\n field1 [outputs 123]

[Multiple return]
let obj [
    let field1 123
    let field1 321
    return [field1 field2]
]
let ret obj
print ret [outputs "field1 field2"]
print\n ret.field1 [outputs 123]
let [ret] obj
print ret [outputs 123]

[Wait but that means these are still the same!]
let new-obj obj
let ret obj
[It's only destructuring that changes.]
[If this was a boring/useful language, I would probably not allow this... but whatever.]

[I guess there is no way to return a function with literals.]
[or is there?]
let obj [
    let field1 123
    let field1 321
    return [print\n field1]
]
let ret obj
print ret [outputs "print\n field1"]
let [ret] obj
print ret [outputs 123 and then [] for the second print.]

[I did it. Finally. It's done.]
[Damn.]

[And it makes sense. Right?]
[When we destructure something, we want the result to be evaluated.]
let obj [
    let field1 123
    let field1 321
    return [field1 field2]
]
let [ret] obj
print ret [outputs 123]
[This prints 123, not "field1". So it's eager.]
[And because it's eager, and the first field gets evaluated, we can just put in a function with
arguments. It will get evaluated, and so will it's arguments.]
[I'm so happy, man.]
[Finally.]

[The only caveat is returning one string. But that's manageable, of course.]
let obj [
    let field1 123
    let field1 321
    return ["Hello, World!\n"]
]
let [str] obj
print str [outputs "Hello, World!\n"]
[Actually, it's not even a real caveat!]
let obj [
    let field1 123
    let field1 321
    return "Hello, World!\n"
]
let str obj
print str [outputs "Hello, World!\n"]
[I mean, yeah. Of course it would.]

[bad]
let obj [
    let field1 123
    let field1 321
    return field1 field2
]
let ret obj [error "Not-Found" on symbol "field1" with call (field1 field2)]

let f [f] [== infinite loop]

let print-all [
    for args print\n "% " it
]
print-all [1 2 3 4 5] [outputs "1 2 3 4 5 "]

[I hope I don't find yet another headache about the language.]

[What if after destructuring the return, you can still get the fields?]
let obj [
    let field1 123
    let field1 321
    return [field1]
]
let ret obj
print ret [outputs "field1"]
let [ret field2] obj 666
print field2 [outputs 666]
[On second thought. No, it would be better to keep multiple assignment for this.]

[Then again! You should not destructure and multiple assign at the same time!]
[It's either one or the other.]
[And as usual, I prefer to remove limitation rather than adding them, so...]
let [ret field2] obj 666
print field2 [outputs 321]

[And if you want to do multiple with a function that returns a string, well you're fucked.]
[And anyway, it's impossible. Not with this model, at least.]

[I should mention, that if a function returns a single value, not quoted, it defaults to multiple
assignment.]

let [type-list] ["text" "[text]" "number"]
[That's pretty much all I need right?]
[Everything else can be built the scheme way.]
[If object layout is like C structs, then that's a lot of problems out the window, just like that.]
[And I already figured out that enums and tuples are glorified objects.]

[Oh!]
let func [
    let arg1 int args
    let arg2 float args
]
[Is this better than [#type]? Probably. But it needs working.]
[And this doesn't work.]
let func [
    let [arg1 arg2] int float args
]
[but you can do this.]
let func [
    let [arg1 arg2] int args, float args
]
[I don't see any reason not to.]

[I suppose both [] and 0 should be falsy. "" as well, of course.]

[overloading]
++ [
    if text [for 2 args] [...] [...]
] +

for 10 print\n it
for [0 10] print\n it
for [10 0] print\n it
for [10 0] as i print\n i

[infinite]
for [-5] print "% " it [outputs "-5 -4 -3 -2 -1 0 1 2 3 4 5 ..."]
[this as well. It defaults to 0.]
for [] print\n it

[I need to have implicit return.]
let add [+ args args]
add 1 2
[otherwise]
let add [return + args args]
add 1 2
[It's fine honestly. The only problem is a non-problem.]
let something ["something"]
[^ you will never do this.]
[You can implicitly return everything else.]
[If there's something you don't want returned...]
let [] func
[It gets discarded.]
[Multiple return argument that aren't destructured are also discarded.]
let mul-ret [return [1 2 3]]
let [ret1 ret2] mul-ret
[Wait, forget what I said about strings being a non-problem... Though I guess it's not that bad.
If you do multiple return, you should be explicit about it.]

[Infinite smart lists?]
for [1 10 100] print\n it

[[i/t] for rational numbers, because [rat] and [rational] are ugly...]
[... Actually, nevermind. [i/t] is perhaps even uglier.]

[This should be a feature.]
print take 10 [0 10 100] [outputs "0 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000"]

[Array programming.]
print + 5 [0 5 10] [outputs "5 10 15"]

for 0 print\n it
[is also infinite.]
[also, [] should == 0]
[there are a nice symetry if I do it (see for loop).]

[by the way.]
if true [
    print "it's true!!!\n"
] [
    print "it's false?!?\n"
]
[[] should be obligatory, otherwise...]
if true do [
    print "it's true!!!\n"
] else [
    print "it's false?!?\n"
]
[or]
if true
    print "it's true!!!\n"
    print "it's false?!?\n"
[which are harder to read.]
[while I was exploring the earlier model, it was something that annoyed me, and I put brackets
despite not needing them, just because of how unclear the language was without them.]

for 0 [print\n it]
[I guess I don't need [print\n] anymore. – Who am I kidding. It's a pain in the ass otherwise. More
characters and... and honestly, it grew on me. Yeah.]
for 0 [print it \n]
[^ this is so ugly. Ugh.]
print "Hello, World!\n"
print\n "Hello, World!"
[$$$ Beautiful $$$]

[I will eventually have to figure out how to return strings from if/ternaries...]
[Did I already mention that only the last implicit return actually returns? Well, I have now.]
[Technically, [/ arg 0] returns [] which is void or undefined. But because [] == 0, it also means
that it returns 0.]

[A way to "implicitly" return strings?]
let my-str if condition [text "1"] [text "0"]

let f [
    print next arg [outputs [1 2 3]]
    print next next arg [outputs 1]
    print next 2 arg [outputs 1]
]
f [1 2 3] [1 2 3] [1 2 3]
[... should it? This feels wrong.]

[lol]
let ever 0
for ever [print "THE END IS NEVER "]

[also, the remainder [%] should also be 0. What other value could it be? Infinity?]
[btw]
let Infinity 0
for Infinity [print "THE END IS NEVER "]
[and]
print-bool = (/ 1 0) Infinity [outputs "true"]
[or should it be...]
print bool = (/ 1 0) Infinity [outputs "true"]

[Strings are not null terminated. Nothing is.]
[Every value in the language has a [size-of].]
[The value is in bytes, and is stored in the symbol table.]
[[size-of] is low level and goes there to find the size of it. It's fast.]
[[str-len] uses [size-of] instead of the null check.]
[[length] as well. By the way, [length] checks the number of elements in an array, so...]
let [arr] [0 1 2 3 4 5]
length arr
[btw]
let arr [0 1 2 3 4 5]
print\n arr [outputs 5 because it's the last implicit return.]

[[int] casts value to int.]
[[int?] returns true if input is an int, otherwise false.]
[[int!] throws an error if the value is not an int, otherwise returns the int.]
[[float] casts value to float.]
[and all the equivalent functions for the other number types.]

[currying]
let create-add-n [return [+ arg]]
let [add2] create-add-n 2
print\n add2 4 [outputs 6]

[I may be called a heretic... But lists should be one-based.]
[Also, ranges should be inclusive.]
for [1 5] [print\n it] [outputs "1 2 3 4 5"]
let arr map [* 2] [1 2 3 4 5]
print\n get 5 arr [outputs 10]

[It's nice and all, but it will only truly be successful once I figure out how to make secretly
static.]

for [1 .5 .25] [print\n it] [outputs "1 .5 .25 .125 .0625 ..."]
for [1 1/2 1/4] [print\n it] [outputs "1 1/2 1/4 1/8 1/16 ..."]

[Huh. What if I print an infinite list?]
print range [] [outputs "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ..."]
[I guess [range] is defined as such?]
let range [
    let [val] arg
    + if and val, (<= tail val, head val) [
        head val range [+ 1 val, tail val]
    ] [
        text [0] range [+ 1 val, tail val]
    ]
]
[I guess?]

let [len arr] length . arr
[[.] duplicates an a [text].]
let array-with-length pair length . arr
print array-with-length [outputs [3 [1 2 3]]]
[or]
let array-with-length [length . arr]
[no, it only returns one value.]

let bool [
    if arg [text "true"] [text "false"]
]

[Oh shit!]
[In python,]
x[-1]
[is equivalent to]
x[len(x)-1]
[I'm totally doing that.]
[Another way to never crash.]

get -1 arr
[calls length by itself.]
[also, length should be memoized.]
[no need to pair it with a list then.]

[On a single value.]
let single 123/2
let val int single
print\n val [outputs 61]

[On multiple.]
let arr [1.34 single 3 "123" 5+3i]
let val int arr
print\n val [outputs [1.34 61 3 123 5]]

[On wrong value.]
let arr [1 2 3 "asldkjasldkj" 5]
let val int arr [error "Impossible-Casting" on value "asldkjasldkj" to type [int]]

print\n real 3+4i [outputs 3]
print\n imaginary 3+4i [outputs 4i]
print\n + real 3+4i, imaginary 3+4i [outputs 3+4i]
print\n complex 3 4 [outputs 3+4i]

[I should have negative indexes like in python.]
let [list] [1 2 3 4 5]
print\n get -1 list [outputs 5]
[but if I have negative indexes, I can't have one-based indexing... Oh well.]

[Since I am to make it almost impossible for the program to crash without an explicit panic, should
I do this?]
let [list] []
print\n tail list [outputs []]

[No even haskell can do this. This is some insane APL shit.]
let . [let n arg; return [n n]]
let square [* .]
print\n square 4 [outputs 16]

[[??] and [!?]]
let [nil] []
let not-nil 123
print\n ?? nil 321 [outputs 321]
print\n ?? not-nil 321 [outputs 123]
print\n !? nil 321 [outputs []]
print\n !? not-nil 321 [outputs 321]

let ?? [
    let [x y] args
    if x [
        return x
    ] [
        return y
    ]
]
let !? [
    let [x y] args
    if x [
        return y
    ] [
        return x
    ]
]

[By the way, this returns [].]
let val []
[It's still a function, but function without a body always return [].]

[Maybe calling [tail] on the last item goes back to the start? That would make sense if [get -1] is
the end.]
[New piece of syntax. -symbol negates a symbol and -[] negates every item in an array. -arr also
does it.]
[Wait, I can't forget that]
let [list-of-strings] ["dog" "cat" "elephant" "so on"]
for list-of-strings [print\n it]
[works for objects as well.]

[Nevermind for 1 based indexing. And I think I'm going inclusive ranges as well.]
[N has to be inclusive, otherwise [10..0] will be fucked.]

[Oh my god!]
let val [] [== 0]
[So it's zero by default. Is it even possible to have true undefined?]
[Wait no. They are equal but not equal at the same time.]
[[] is closer to the "" and can be used as an actual undefined. Who cares if a single int is 0? It
did not initialize the array it points to... But then again, how do I initialize it?]

let nil []
let zero 0
print\n bool =  nil zero [outputs "true"]
print\n bool == nil zero [outputs "false"]
[[=] is true because they are equivalent.]
[[==] is false because they are of different types.]

for [0 10] as n [print\n n]
[[as] attaches itself to the start of the code block so]
[assign [n] it; print\n n]

[These should do different things.]
let x arg
let x args

[functions are objects right?]
let.single [x] [print "hello\n"]
x [outputs "hello\n"]

[I can even do overloading like this.]
print.overload "complex" [
    let number arg
    print "%+%i" real number, imaginary number
]
let number complex 3 4
print\n number [outputs 3+4i]
[[print\n]'s definition is of course based on [print].]
let print\n [print args; print "\n"]

[I suppose I should make it so every function is overloadable. They are just overloaded by default
on basic text, [text] and number.]
[Also, I just realized that the above code is maybe broken?]
[I know what to do.]
let x args
print x [outputs [print "hello" 123 "arg3" ...]]
let [x] args
print x [outputs "hello"[]]
[... This is a bit of a long shot, but what if the arguments aren't consumed until they are used?]
[so this code would be valid.]
let print + [
    let [number] args
    if = "complex" type? number [print "%+%i" real number, imaginary number] []
] print
let number complex 3 4
print\n number [outputs 3+4i]
[Isn't it beautiful? Function overloading is just string concatenation.]

[By the way, args at the top-level takes the args from the terminal call.]

[The [print\n] is wrong. Let me think about it more.]
let print\n [print head args, tail args; print "\n"]

[Should I do this?]
let [x y z] args [tail y == z]
[No. What if [y] is a list?]

[I shouldn't about this.]
let x nth 0 args
[macros basically.]
[then again.]
let x nth.lazy 0 args
[this is probably better.]

[heh.]
let x nth.number 0 args

[wait]
let print + [
    let [number] args
    if = number.type "complex" [print "%+%i" real number, imaginary number] []
] print
let number complex 3 4
print\n number [outputs 3+4i]
[then again...]
= number.type "complex"
= type number "complex"
[I shouldn't hide fields like that.]

[[+] vs [++]]
print\n + 1 2 [outputs 3]
print\n + [1 2 3] [outputs 6]
print ++ "Hello, " "World!\n" [outputs "Hello, World!\n"]
let val 5
print\n val [outputs 6]
print\n ++ val [outputs 6]
print\n val [outputs 6]

let val 5
+= val 2 [-> 7]
+= 2 val [-> 7]
+= [1 2 3] val [-> 11]

let [val] "Hello, "
++= "World!\n" val [val = "World!\nHello, "]
++= val "World!\n"  [val = "Hello, World!\n"]
let [ue] "World!\n"
++= val ue [val = "Hello, World!\n"]
++= ue val [ue  = "World!\nHello, "]

let loop [loop args]
loop [
    print "THE END IS NEVER "
    break
]
[But no. That would be the ideal because of how simple it is... But I don't know how to make it
work. I'll have to think about it.]
[I should try to warp the logic of the language to allow for that though. It's too sexy!]

[I guess it should be this.]
let loop [loop do head args]

[A pointer to any type is [type].]
[This works too: [number].]

echo "print [Hello, World!\n]" | ./a.out

[nested destructures]
let [[field1 field2]] args

[rust]
#[function_component]
fn Component() -> Html {
    html! { 69 }
}
[vs]
let Component [
    html [69]
]

[val-of vs ptr-to vs do]
let f [print "hello"]
val-of [f] [-> [print "hello"]
ptr-to [f] [-> (random pointer)]
let [s] "print \"hello\""
ptr-to s [-> (random pointer)]
do s [outputs "hello"]

let withdraw do [
    let balance 100
    return [
        let [amount] args
        if >= balance amount [
            set balance - balance amount
            return balance
        ] [
            return "Insufficient funds"
        ]
    ]
]
[I guess you can't multiple return a function and other things...]
[But aren't variables functions?]
[Or maybe you can, but the function has to be the last one...]
[Or maybe [let] is secretly a tree argument function? And so is [if]?]

[I should probably define the standard library before I actually implement the language... Then
again? I don't know. If I do it before, I could get things that are mathematically elegant.

[Maybe I should create a borrow check of sorts, just more implicit?]
[Like instead of throwing an error because a variable no longer owns a value, it implicitly inserts
a copy?]

[My language should have the same energy as c89, at least for obfuscation.]

[I should add single quotes as well.]
let [my-str] 'Hello, World!\n'
print 'Hello, World!\n'
print "Hello, World!\n"
[Then again, maybe not. Unlike ["], it doesn't look good enough for me to make an exception.]

[I have three options right now:
    - Do it like math, where I just write the overview of the language.
    - Do it like emulated, where it's not truly compiled. I can test it though.
    - Do it like a true interpreter/compiler.]
[I don't know. I initially thought to just do the third one, because I'll just have to change it
anyway, once it's done, if I do another model. But I don't know about that anymore. I saw how
elegant some of the algorithms are and thought that I could try to first defined those elegant
functions without worrying about performance, then workout the implementation details. The goal is
something that is both elegant and performant...]

[I should consider making order of assignment irrelevant. I already planned that out for the
top-level, but I mean for inside functions as well. And it makes sense to have that, since
[#import] basically just reads an entire file and evaluates the resulting string as a
function.]
[I suppose order of assignment should only matter for redeclaration or usage?]
[There is compile-time and run-time right? So I could do it... Then again, I don't need to, since
it's literally just a bunch of strings.]

[Honestly, I'm starting to see the limits of this way of doing things. I should try to write a
second interpreter again... But honestly, I should also finish reading SICP. There's a lot of
knowledge I can steal from that.]

[There are maybe two types of [set]s? One sets variables for dynamic scoping, the other for static.
That way, there no need to create functions that create new scopes and functions that don't.]
let test [
    set.dyn var + var 123
]
[... or maybe if there isn't a global variable that matches, it simply continues searching using
dynamic scoping?]
[Or maybe I can just get away with not having it period. Yeah, I'll features as I need them.]

[Even if I do the string model, I should include [#run].]

[I guess a macro is just this.]
let test-macro [
    let val 22; do
]
let val 33
test-macro
print\n val [outputs 22]
[That and you know, the non-evaluated args.]

[I should define a map function.]
(define (map f lst)
    (if (null? lst)
        '()
        (cons (f (car lst))
              (my-map f (cdr lst)))))

let map [
    let [f lst] args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[It's nice, but I still don't know how [args] behaves.]

[I should be able to do this.]
map [+] [1 2 3] [4 5 6]
[The number of arguments is determined by the function.]
[Nevermind, should follow haskell and only partially apply the function.]
[Then I'll use [zip-with] for stuff like that.]

[Constants are uppercase, but there is nothing forcing you to not mutate.]
[You can force it by making it so that [set] can't redefine uppercase (lol).]

[[char] chars takes a [text], and converts it to list of chars:]
chars "hello" [-> ["h" "e" "l" "l" "o"]]
[Single character strings are synonymous with characters, and you can loose compare them to
numbers.]
[Maybe I should have a "text" type as well; not for any real reason, just to help with pretty
printing. Though, nevermind. That would complicate things unnecessarily.]

[There is a [type] and [true-type]. The true type is actually what's used to optimize things.]
[Every type starts as [indeterminate].]

[I shouldn't always need [#run]. If a function is pure, it should run at compile time
automatically.]

[Everything is copied by default]
let say-hello [print "Hello, World!\n"]
let ref [say-hello]
[^ to create reference.]

[Maybe [:] won't be a syntax char...]

[One of the goals was array programming but...]
[That's on hold for now, since there are no array programming languages without scheme/haskell like
syntax that I can copy. This is telling me that the syntax is probably a big aspect of it. Anyway,
array programming will be a second thought.]

[[do] and [val-of] should work on pointers.]

[If functions call themselves recursively, there no reason not to be able to do this.]
let obj [
    let name "John Smith"

    let method [
        print\n name
    ]
]
obj.method [outputs "John Smith\n"]
[or even]
let obj [
    let name "John Smith"
]
let obj.method [
    print obj.name
]
[now I now this is weird, especially considering]
let new-obj [obj]
[but you should remember that [new-obj] is still [obj]. All the earlier aliases are still valid.]
[Then again...]
let new-obj val-of [obj]
[This is broken.]

[I don't want [.] to be a special character... but it would be so good if I could do this.]
let obj []
set [obj.name] "something"
[I guess I should do this?]
set-field obj [name] "something"
[Honestly, there's no real reason not to.]
[I should and I will.]
[It's not a special character, of course.]
[The [set] function simply choose to treat it specially.]

[Passing a struct to a function should not copy the whole struct, that way I don't have to worry
about adding fields to it.]
[If the language follows a pattern, it will become something precise. otherwise, it's all just a
list of [Any].]

[What if...]
* 3 [] -> malloc * 3 sizeof [indeterminate]

[I hate it, but I really need to separate [let] destructuring and multiple assign. It's too
confusing otherwise.]
[Maybe I should consider {} again?]
[Or... I just give up on destructuring? Is it really that needed? Right, destructuring was for
multiple return.]
[The biggest problem is the function call syntax. How about I use [:] as the syntax for calling a
function?]
main() [vs] (main) [vs] main:
[The biggest gripe I had with () is that the argument count is forced.]
[I think the trick to multiple return values might be implicit return?]
[If I add [:], that means i won't need two text types anymore.]
return: [1 2 3] [vs] return text "hello" [?]

[Technically, there is still text and [text], it's just that [let] does automatic assignment for
[var:], of type text.]
==: [... [:] is a last resort.]
[also]
let: f complex [and] let: f [complex:] [are redundant]
[[return text "hello"] returns a string, [return [print "hello"]] returns multiple values or a
function, depending on the receiver.]

[I'm having another crisis.]
((func1) 1 2 3)
(display (func1))
[How do I do this is my language?]
func1:: 1 2 3
display: func1:
[Nah, this sucks.]
((func1 'field1) "hello")
(display (func1 'field1))
func1 [field1] "hello"
print [func1 [field1]]
[Or not? Maybe I can do this.]
[The only difference is that scheme returns the pointer to the function, which can be called, or
passed around, and I create lambdas.]

print "Hello, World!\n"
print: "Hello, World!\n"
let f complex 3 4
let: f complex: 3 4

[Wait a second, I can do arrays!]
let arr [
    let [index] args
    cond [
        (= index [0]) 123
        (= index [1]) 312
    ]
]
print arr[0]
[I mean right?]
[Still, assignment...]

[You know, why not?]
set arr[0] 4312
[Because you're setting [arr] to [0]. That's why.]
[I think I should focus on first doing everything scheme can do. Otherwise, I'm going to get
overwhelmed.]

[I really need to figure this out...]
let func [
    return [text "hello"]
]
print func [outputs "hello"]
let func [
    return [text "Hello, %!\n", text "World"]
]
print func [outputs "Hello, World!\n"]
let func [
    return [+]
]
print\n func 1 2 [outputs 3]
let func [
    let val 0
    return [
        ++ val
        print\n val
    ]
]
print func 1 2 [outputs 3]
[Uh...]

let f [return [1 2 3]]
let f [return "Hello, World!\n"]
let f [return [+ 1 2]]

print f [outputs "1 2 3"]
print f [outputs "Hello, World!\n"]
print f [outputs "+ 1 2"]
[equivalent to]
print [1 2 3] [outputs "1 2 3"]
print "Hello, World!\n" [outputs "Hello, World!\n"]
print [+ 1 2] [outputs "+ 1 2"]

(print (f))
print: f:
print $f
[Ahh... AHHHH. ARRRHHGGHGHAGS!!!!!!]

[Multiple return, returning functions, returning strings...]

let f [
    return { print "Hello, World!\n" }
]
let f [
    return [ 1 2 3 ]
]
let f [
    return "Hello, World!\n"
]

let val0 (+ 1 2)
let val1 {+ 1 2}
let val2 [1 2 3]
let val3 "Hello, World!\n"

print\n val1 [outputs 3]
print\n val2 [outputs [1 2 3]]
print\n val3 [outputs "Hello, World!\n"]

let f {
    return [1 2 3]
}
let [a b c] f
[equivalent to]
let [a b c] [1 2 3]

let f {
    return { + arg 0, arg 1 }
}
print f [outputs { + arg 1, arg 1 }]
[Functions that are returned are never executed.]
[As opposed to this.]
let f {
    return + arg 0, arg 1
}
print f 1 2 [outputs 3]
[I guess... You can only really really return numbers and strings?]
print f "test " "123" [outputs "test 123"]

set [arg 1] 69420
[huh]

let map [
    if (arg 1) [pair do (arg 0) (arg 1), map (arg 0) tail (arg 1)] []
]
map [* 2] [1 2 3 4 5]
let map [
    let [f lst] arg 0, arg 1
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[Things are so much simpler when I don't do destructuring.]

[Wait a second.]
let map [
    let [f lst] split args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[I mean I could, right? Did I fix it? Just like that?]
[And it just makes sense, right? Like with [as].]

[Should I use [..] instead?]
let map [
    let [f lst] .. args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[Yeah I should.]

[If order of assignment doesn't matter, I can do forward [goto]!]

[Technically, [..] has the same purpose as [do].]
let map [
    let [f lst] .. args
    if lst [pair .. f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[It remove the [].]
[Then again, no. [do] creates a new scope.]
[But [..] doesn't? I don't know about that.]
[There's no reason for it not to create a new scope.]
[But it might be intersting for it not to.]
[Better than [do-here], that's for sure.]

[Also, this would break the [..] function.]
map [
    let [x y] 2, arg 0
    * x y
] [1 2 3 4 5]

[Still, I ended up breaking [#import]. I don't know how to fix it while keeping the behavior the
same.]
#import "System/IO"
let io #import "System/IO"
[like this?]
.. #import "System/IO"
[You know, at this point, why not? Fuck it.]
[It makes sense. It's not as nice, but it makes sense.]

.. #import "Basic"
.. #import "File"
.. #import "String"
[vs]
#import "Basic";
#import "File";
#import "String";

[Honestly, Jai's imports are nice, but they don't make that much sense. I prefer consistency.]

[Though it's weird, I should be able to do this.]
map [.. #import] [
    "Basic"
    "File"
    "String"
]
[or rather like this]
.. map [.. #import] [
    "Basic"
    "File"
    "String"
]

[By the way, [...] is still the error not implemented function.]

[[let] should return the value that's passed to it.]
let x let y 0
print\n [x y]  [outputs [0 0]]
[This is clearly wrong...]
[But something tells me this should be right.]
[The weird usage of [print\n] I mean.]
[No, there's a better way of doing this.]
print\n reduce [x y]  [outputs [0 0]]
[Having no need for new syntax is always a good thing.]

[From now on, if variable is passed to function, it should always be equivalent to passing the
literal directly. No need for surprises.]
let [val] "hello"
print val
[equivalent to]
print "hello"
[and this for every function.]
[that does mean I will have to change my for loop logic...]

[Also, I just realized an interesting mnemonic.]
[I thought of it as something ugly before, but now it's better.]
let val [print]  [type = text]
let [val] "print"  [type = [text]]
[See the resemblance?]

[How do define [arg]?]
let arg [
    let index (get 0 args)
]
[Damn, the one time I need a dynamic scope.]
[Wait.]
let arg [
    let index (get 0 args)
    return get index #args
]
[Two [args] variables. One static, the other dynamic.]

[By the way, for trailing comment, two spaces beforehand.]

atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

let fib [
    let n arg 0
    if or = n 0 = n 1
        [n] [+ fib - n 1 fib - n 2]
]

let obj [
    match word 0 [
        [field1] 123
        [field2] [print]
    ]
]
print\n obj[field1]  [outputs 123]
let set-field [
    let field arg 0
    let old arg 1
    let value arg 2
    let [new] [
        if = arg 0 field [value] [old]
    ]
    set old new
]
set-field [field1] [obj] 321
[And this would of course be optimized away.]

[It should behave more like this.]
set-field obj field1 321
[or like this?]
set [obj field1] 321
[but it also breaks the [#import]s. But it's also more elegant in a way.]

[The [obj field] also solve the chaining problem. I need to make it work.]

[Holy fuck.]
let fib [+ fib (- arg 0 1), fib (- arg 0 2)]
set [fib 0]
set [fib 1]
[^ a Haskell.]
[Also, [set] should not change the type.]

[I shouldn't abuse of parentheses. One of the purposes of this language was to be rid of the
accursed parentheses.]

[The LSP can use the indentation of the code to check if the obj field calling is erronous.]

[Initializer]
let val int []
let val int 123

let [val] [for 30 int []]
print\n get 0 val
let val (array 30 int [])
print\n val 0
[I don't know how I'll do it.]

[[#import] returns a [text] with an environment, right? Why not have a function that operates on
that? And convert the environment into an object function?]

let set-name [
    set [obj name] arg 0
]
print\n set-name "John Smith" [outputs (function body)]

[old] my-list iter filter fn [item] == item id 132 collect
print\n (my-list iter filter [= (do (arg 0) id) 132] collect)
let obj [my-list iter filter [= (do (arg 0) id) 132]]
print\n obj collect
[This works, though it's stupid.]
[Well, when you don't have overloading, you gotta do what you gotta do.]

[[iter] is only there to avoid name conflicts.]
set [my-list iter filter] [
    filter arg 0 my-list
]
[but how do I return a plain string?]

[[arg []] returns the full list?]
[but then [arg 0]...]
[...]
[one based indexing!?]

[I should try implementing infinite lists.]
for range [0 infinity] [print\n it]

[Should [let] differenciate [] and ""?]
[And no other function does it?]

let number 123
let func [print "hello"]
let str "hello"
[yeah, but...]
let array [1 2 3]
[... doing so introduces unnecessary complexity.]

[Instead, [cond] should just be like [if], always evaluating a function body.]
let condition true
if condition [
    print\n "It's true."
] [
    print\n "It's false."
]
cond [
      condition [print\n "It's true." ],
    ! condition [print\n "It's false."],
]
[Yeah, I'm doing this. Not to mention that's it's more consistent with [if] this way.]
[And you know. The body of [if] just makes sense for lazy evaluation.]

set [obj field] [text "Hello, World!\n"]
print\n obj field
[Because [set] does not change the type, any reassignment has to be the same type.]
let [my-str] "hello"
set my-str [hello]  [-> type [text]]
let my-func [print "hello"]
set my-func [print my-str]  [-> type text]
[... Or not?]
let [str] "hello"
set [str print\n] [print\n str]
print\n str
str print\n
[Every function can behave as a string, but not every string can behave as a function?]

let arr [1 2 3]
set [arr 1] [get 1 arr]
print\n arr
print\n arr 1

[I got it.]
set val [print "hello"]
set [val] "hello"
set [val say-hello] [print "hello"]
val say-hello  [outputs "hello"]
set [val [say-hello]] "hello"
print\n val say-hello  [outputs "hello"]
set [val [say-hello number]] "hello" 123
print\n val number  [outputs 123]
[Nevermind about [set] not changing the type.]

for 1 .. 10 [print\n it]
set [number ..] [range [number arg 0]]

[If you have called [let] beforehand, it's alright. [set] it for you.]
set [obj field] 123
[is equivalent to]
let obj []
set [obj field] 123

[Nevermind.]
[Fields always call functions.]
[That way, I can do this.]
set [obj "John Smith"] [
    return [
        123
        312
        [other data]
    ]
]
obj "John Smith"

let file (#import "File" open-file "./file.txt")
let file [#import "File"]
let content (file open "./file.txt")
context add (#import "File" context)
[Zig style imports... I need to figure them out.]

this context
that context

let open [#import "File" open]
let File [#import "File"]
let open [File open]
[maybe I don't need to import everything?]

[You know, if you program with discipline, you won't need to worry about name conflicts.]
[Objects shouldn't have too many nested fields.]

[The more I think about these Zig style imports, the more I like them.]
let File [#import "File"]
let file File open "file.txt"
File fscanf [file] "%d %d " val1 val2
[[val1] and [val2] should need to be explicitly declared. Though, these C-style mutations should be
avoided.]

[Ah damn.]
let [val1 val2] [] []
do [
    set [val1 val2] .. File fscanf [file] "%d %d "
]
print\n val1
print\n val2
[This is awkward.]

use [#import "File"]

let-key val1 [field1] [
    print "Hello, World!\n"
]
set-key [val1] [field2] [print "Hello, World!\n"]

val1 field1        [outputs "Hello, World!\n"]
print val1 field2  [outputs [print "Hello, World!\n"]]

[no.]
set [arr 0] 123
set [arr 1] 321
print\n arr 0
print\n arr 1
[it needs to match.]
[but then the awkward scoping assignment...]

[I guess this fixes it?]
set-key [arr 0] 123
set-key [arr 1] 321
print\n arr 0
print\n arr 1
[or just]
let arr []  [optional, but available for reset of all fields.]
key [arr 0] 123
key [arr 1] 321

[I guess [key] is also like an upsert? Or should [set] just create a new variable if not bound?]
[I guess [key] behave the same as [set] when there's only one variable?]
[Or not? Maybe [key] always takes text as functions, while [let] takes as strings?]

[No, [key] behaves the same as [let] when only one input, as [set] when more than one.]
let [str] "Hello, World!\n"
key [func] [print "Hello, World!\n"]

let [str number] "Hello, World!\n" 123
key [obj field] [print "Hello, World!\n"]

[This is nice though.]
let str "Hello, World!\n"
key func [print "Hello, World!\n"]
[or this?]
var str "Hello, World!\n"
let func [print "Hello, World!\n"]

var [str num] "Hello, World!\n" 123
let [obj field] [print "Hello, World!\n"]
let [obj field] "Hello, World!\n"
let [obj field] [text "Hello, World!\n"]
let [obj field] [1 2 3 4 5]
let [obj field] [text [1 2 3 4 5]]

[You know, if I just drop multiple assignment, like Scheme, this would be much easier.]
[If functions return multiple values, then just return a struct/array or something.]
[But no. I need multiple return for args.]
var [arg1 arg2] .. args

[Honestly, I hate it, but using different functions for multiple assign and function assignement
and object construction just makes more sense.]
[The real question is whether [let] should have both function and object assignment.]
[I'm guessing yes, otherwise there will be too many functions for every little thing.]
[String and quotes are common enough to justify seperating assignment into two functions.]

[The other question is should I make it more like scheme, and just omit objects?]
[All you really need is a list in the end.]
[And the whole obj model is kind of a pain with macros and stuff.]
print obj field
print Object.field obj
[The latter is longer, but there is no ambiguity.]
print Object.field obj
print Object/field obj

[But what about [#import]? It's broken again?]
[Does it just return a table of key/value pairs? An environment?]
[RIP, zig imports.]
[Yeah, lists and selectors just make better objects.]

[raku]
my &func = {
    my ($val1, $val2) = @_;
    print "Hello, World!, $val1, $val2\n";
}
func 1, 2;

[this]
let func [
    let [val1 val2] .. args
    print "Hello, World!, %, %\n" val1 val2
]
func 1 2

[Shockingly, as a whole, this language has fewer characters?]

let [my-vector] [1 2 3]
print "x = %, y = %, z = %\n" .. my-vector  [outputs "x = 1, y = 2, z = 3\n"]
print "x = %, y = %, z = %\n" Vector.x my-vector, Vector.y my-vector, Vector.z my-vector
let Vector.x [nth 0 arg 0]
let Vector.y [nth 1 arg 0]
let Vector.z [nth 2 arg 0]
[I should keep [arg n].]

[[#] for dynamic scope?]

[This really, really sucks, but I might have to do imports, not the Jai way, not the zig way, but
the odin way...]
#import "File"
open "my-file.txt"
#import File "File"
File.open "my-file.txt"
[Well, not exactly like odin.]

[Or different from anything else?]
let open (get "open" #import "File")
open "file.txt"

let [File] #import "File"  [File -> a table of key/value pairs.]
let open get "open" File
open "file.txt"

[[get] gets the nth element if the index is a number, or – scratch that. Tables should have numbers
as valid keys as well.]

[Should packages have [return env] at the end? Like in Lua?]

let [File] #import "File"
match [open close] File
open "file.txt"

[I guess the values should just maintain there type, which is why [match] works, but what about the
earlier combination of [let] and [get]?]

[I guess this is how a table would print.]
[
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
match [value1 value3] #import "test-module"
print\n value1
value3

[[match] actually extract a level of quotation.]
let [test-module] #import "test-module"
match [value1 value3] test-module
[is equivalent to]
let value1 get "value1" test-module
let value3 get "value3" test-module
[You can't do multiple assign, because the return is quoted.]

let func [print "Hello, World!\n"]
let [func] fn [print "Hello, World!\n"]
[But how do I implement this?]
[I guess it's similar to [..], but unlike it, does separate the return into different entries in
the stack.]

let [MyInterface] [
    name
    age
    [value1 value2]
]
make "MyInterface" MyInterface

let [value] ["hello" 123 [321 "something"]]
print\n MyInterface.name value  [outputs "hello"]
MyInterface.name! value "hello again"
print\n MyInterface.name value  [outputs "hello again"]
[I guess this is the best. It's so simple.]

[If the input of a getter/setter is a number, it treats it as a pointer to a struct, otherwise as a
value.]

make "MyInterface" [
    value1
    value2
    [value3 value4]
]
let [obj] ["hello" 123 [321 "something"]]
print\n obj
print\n MyInterface.value1 obj
MyInterface.value1! obj "bye"
print\n MyInterface.value1 obj

print\n MyInterface  [outputs [value1 value2 [value3 value4]]]

for MyInterface [
    use MyInterface
    print "% = %, " it, do it obj
]

struct "File" #import "File"
[Nevermind, "struct". I don't like duplicates.]
#import-as "File"
[But then again, there's no choice. What if you want to rename it?]

to-obj "File" #import "File"
let [file] File.open "file.txt"
use File.interface
print\n File.name file  [outputs "file.txt"]

to-obj "obj" MyInterface obj

[Okay, far simpler.]
#import "File"
File.open "file.txt"
use File
open "file.txt"
use #import "File"

[Oh.]
#import "File" as "F"
[What's going on here?]
[Well, [as] looks at the latest values added to the environment, and mutates the names.]

[Nevermind. Too complicated to implement.]
#import [File F]
[This though...]
[Hmm. It's better, because there is less noise/duplicates. There won't be fields named both
[File.something] and [F.something] at the same time.]
[Still, it would be interesting if it both has side-effects and return an environment at the same
time.]

[Maybe strings should implicitly return?]
let [val] if condition ["true"] ["false"]

# Maybe strings should implicitly return?
let [val] if condition ["true"] ["false"]

# Yeah. That might be better, because otherwise you can't do this.]
make "MyInterface" [
    value1  # Only for value4
    value2
    [value3 value4]
]

table->obj "File" import "File"

print\n MyInterface  [outputs [value1 value2 [value3 value4]]]
print\n MyInterface  # outputs [value1 value2 [value3 value4]]

# Still, if I do add [#], that means adding syntax, and abandonning [#args] or [#import].
# But frankly, I never liked how numbers and functions implicitly returned, and text did not.
# And what's up with [#import]? Why does it have a [#]?
# Also, [#!/path/to/interpreter] is now possible.

object "my-obj" [
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
my-obj.value1

# There are two ways of doing objects:
# - Tables
# - Lists with getters/setters

# I suppose this is still possible?
let func [
    object "obj" .. args
    print\n obj.value1
]
func [
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
# But I guess, you can't just use [set] on it.

# I'm really warming up to [#] for comments. It looks so nice.

# I should probably not use tables as struct, since they very much have a runtime overhead.
# Tables are more for dynamic stuff.
# Structures as lists make more sense, since they actually match the implementation.

# [rename] function
let [val] "hello"
rename "val" "value"
print\n value  # outputs "hello"
print\n val  # error: not bound

# size (in bytes)
# count (number of elements in list)
# length (length of utf-8 string)

for chars "Hello, World!\n" [print it]
# equivalent to
print "Hello, World!\n"

for chars "Hello, World!\n" [print it]
for chars "Hello, World!\n" as c [print c]

let str ["Hello, World!\n"]
let [str] "Hello, World!\n"
print str
# both are equivalent to
print do ["Hello, World!\n"]
# damn, this actually looks really nice.

let func [
    let [arg1 arg2 arg3] .. args 3
]
# ^ this is the lazy way of doing things.
# there's no way of consuming arguments otherwise.
# hmm.
let next-arg [top-args 1]

# the best.
let func [
    args [arg1 arg2 arg3]
]
# functions use arguments so often, it would be dumb not to do this.

let square [* .]
print\n square 5  # outputs 25
# [*] and [.] should not exit the scope, even if the args are outside it.
# that's why this works.
let test [
    let value 25
    do
]
test print\n value  # outputs 25
# although... it only works for once function call, which is good!
test [
    print\n value  # outputs 25
    print\n square value  # outputs 625
]

# oh!
args 3  # returns list of eager arguments
args [arg1 arg2]  # returns nothing. sets symbols to [.. args 2]

args 0   # returns all the args in a list.
args []  # same here because 0 == [].

# maybe [do] should only pop the scope when there is a quote?
let test [let value 25; do]

test [print\n value]  # outputs 25
print\n square value  # error: "value" not bound

test
print\n value         # outputs 25
print\n square value  # outputs 625

# yeah, this is the best. I still have the behavior where the scope gets poped, and can still
# include multiple function calls in it, but now I have a way to include the rest of upper scope
# without putting it in [].

# nevermind... what if a function returns a string?
# in fact, every function either return [] or something else.

let test [
    pop  # or maybe [done]? you know, to pair with [do] which creates a scope?
    let value 25
]
# yeah, but pop is called automatically at the end so...
let test [
    pop-scope
    let value 25
    push-scope
]
# ugly.
let test [
    done [let value 25]
]
# now that's better.

# for popping multiple scopes?
done 2 []
# or I guess it doesn't really pop them, otherwise this wouldn't work:
let test [
    let value 5
    done [let value 25]
    print\n value  # outputs 5
]
# All it does is set the environment.

# this only works if [let] returns nothing.
if let value ! % 2 . 5 [
    print\n value
]

let test1 [
    print\n "hello"
]
let test2 [
    print\n "hello"
    return []
]
print\n test1  # error: no argument found.
print\n test2  # outputs ""

# but what about...
let value if condition ["hello"] []
# do I need to write it like this now?
let value if condition ["hello"] [[]]
# still, the fact is that you can do this.
print\n * . 5  # outputs 25
# you can have functions that return multiple values.
# so why not functions that return nothing?
# I should figure out how to define [.]

let square [* .. .]
# if [.] returned [val val].
# but no, [..] also returns multiple values.

# this is how it should work.
let test1 [
    print\n "hello"
]
let value test1 5
print\n value  # outputs 5

let multiple [
    return .. [123 321]
]
let multiple [123 321]
let [a b] multiple
print\n "% %" a b  # outputs "123 321"

let multiple [
    123 321 return
]
# If I allow this way of doing multiple returns, then things will be more terse in some part, but
# also more verbose in others. And I'll have to use discards everywhere now...

# What's going on here?
let [a b] .. [1 2 3]
# Is 3 discarded?
# But it's a good thing no? It's more explicit. I know people like explicit.

# Should I call [] a set?

# What about a function that only runs if a function that normally never returns suddenly does, and
# therefore executes the code that's passed as a body? Like for an error?
# I don't know.

# [digits] function
print\n digits 123  # outputs [1 2 3]
# what about hex and bin?

# damn, there's actually a use for true/false constants.
let true  [u8 1]
let false [u8 0]

# it's only natural for a function that can take multiple inputs to be able to have multiple
# outputs as well.

let test [
    print\n value
    let [value]
]
test 5  # outputs 5
# nevermind. this only works for functions because they are 'strings'.
let test1 [test2]
let test2 [test1]
# this wouldn't work.
let test1 test2  # error: "test2" not bound
let test2 [test1]

let multiple [123 321]
let [a b] multiple
let [a] multiple  # discards 321
let a multiple    # discards 321 as well?
# if feel like it should.
# thing is, I really need use cases to make a decision.

if let a multiple []
# vs
if let a . 5 []
# [. 5] is a function like [multiple] that returns two things.
let a multiple  # should not discard 321 then.

# honestly, I'm not really liking this [if let] syntax.
if let a swap % 2 . 5 [] # i have to do stupid shit like this.

# maybe [let] returns the updated environment? so I don't have to do [return env]?

print\n list multiple  # outputs [123 321]
# takes any number of returns from function call and puts it in a list

let test [1 2 3]
print\n + - test  # outputs 2 -> (1 - 2) + 3
let test [1 2]
print\n + - test 3  # same as above

fold-left [+] 0 [0 1 2 3 4 5]
fold-left [+] 0 [0 1 2 3 4 5]

let [] func-call  # needs to discard.
# and I guess it's fine if it's the only thing that discards?
# also, I guess if a function explects an input but gets nothing, then there will be hell to pay.
let test []
print\n test  # error: passed void as argument

let multiple [1 2]
let test [
    args [a b c]
]
test multiple 3  # this should work.

let multiple [1 2 3]
let [] print\n - multiple  # outputs -1
# or
clean let [value] - multiple
print\n value  # outputs -1
# should I just not have the ability to discard?
let [a b _] multiple
print\n _  # outputs 3
# it's just a convention. it could be any name.
# [_] just keeps getting reassigned to 'discarded' values.
# this is probably the best. [let] now behave like all the other functions.

# but then what does this do?
let [] multiple
# it could throw, but I thinks it's better for it to just not do anything.
# it's equivalent to
multiple

let [byte-arr] map [u8] [1 2 3 4 5 6]
# then again...
let [byte-arr] u8 [1 2 3 4 5 6]
# all you need is an overload.

# actually, nevermind for [list].
let multiple [1 2 3]
print\n [multiple]  # outputs [multiple]
print\n reduce [multiple]  # outputs [1 2 3]

# [<>] instead of [swap]?
let multiple [1 2]
let [a b] swap multiple
let [a b] <> multiple
# or even
let [a b] >< multiple
# nah. [swap] is better.

let [quoted] [print "Hello, World!\n"]
print\n quoted  # outputs [print "Hello, World!\n"]
to-fn quoted
quoted  # outputs "Hello, World!\n"

let [arr] [1 2 3 4 5 6]

print\n first 3 arr  # outputs [1 2 3]
print\n first   arr  # outputs 1

print\n last  5 arr  # outputs [2 3 4 5 6]
print\n last -1 arr  # outputs [2 3 4 5 6]
print\n last  0 arr  # outputs [1 2 3 4 5 6]

print\n half   arr  # outputs [[1 2 3] [4 5 6]]
print\n half 0 arr  # outputs [1 2 3]
print\n half 1 arr  # outputs [4 5 6]
# [first] and [last] work. I still need to think about [half].

# constant just capitalized for the same reason that [_] is used as a discard variable.
# it's all convention. no need to actually change the language to add these "features".
# though again, you can add them; just not through the default channels.

# I still can't get over this. so simple, yet so smart.
let multiple [1 2 3]
let [a b _] multiple
let [a _ _] multiple
let _ test
let [val err] test
let [val _] test
let err drop test  # [drop] takes one argument, and returns nothing.
let drop [args [_]]
# nah, this is better.
let [_ err] test
# or this.
let err let [_] test
let drop [let [_]]

# Go
import (
	"fmt"
	"os"
)

func main() {
	// Try to open a file
	file, err := os.Open("example.txt")
	if err != nil {
		// Handle the error
		fmt.Println("Error opening file:", err)
		return
	}
	// Don't forget to close the file
	defer file.Close()

	fmt.Println("File opened successfully")
}

# this
import "File"

let main [
    # Try to open a file
    let [file err] File.open "example.txt"
    if err [
        # Handle the error
        print\n "Error opening file: %" err
        return
    ]
    # Don't forget to close the file
    defer [File.close file]
 
    print\n "File opened successfully"
]

# maybe I should seperate imports and uses?
import "File"
use [File]
# but again, I don't like repetition for such common operations, so no.
# the problem is what [import] returns.
# if it returns something, thing will become pretty dirty, pretty quick.
let [_] import "File"
drop import "File"

use [File System Graphics Core]
# i think this is the best. it also encourages the use of [use].

let [file err] File.open "example.txt"
defer File.close file
# vs
let [file err] File/open "example.txt"
defer File/close file

# [.] looks kind of better with ["].

# oh shit.
let import [
    args [file]

    if ! between count file, 1, 2 [
        error [usage = [import "module-name optional-rename"]]
    ]

    let [content] read-file get 0 file
    module get 1 file
    done [add env, get 0 file, content]
    done content
    module ""
]
# damn, this is actually so simple.
# I think you can omit the ending [module] call.
# unless it is in a [done] call. then you have to include it, unless you want the effect to be
# included in the outer scope.

let use [
    for args 1 [
        done 2 [do it]
    ]
]
# [for] should automatically call reduce on the array that's passed.
# you can still iterate of symbols, but you have to quote them first.
for quote args 1 [...]

print\n quote [1 2 3]  # outputs ["1" "2" "3"]
let arr [1 2 3]
print\n quote arr  # outputs ["1" "2" "3"]
print\n quote [print "hello"]  # outputs ["print" ["hello"]]
print\n quote 123  # outputs "123"?
# or should I do this?
print\n quote 2 [1 2 3]  # outputs ["1" "2" 3]
# I don't know. I don't see much use from this.

let test [args 3]
test 1 2 EOF  # error: invalid argument count. expected 3, got 2

# I like the idea that because the functions are so general, you can get some "happy accidents"
# from it. functionality you didn't expect, I mean.

# does this throw?
get 1 [1]
# it should. so...
get-or 1 [1] []
get-or-nil 1 [1]

# I guess [] and 0 should be equal to each other. otherwise...
+ [] 2
+  0 2
# what should I do?

let [arr] []  # null pointer?
set 0 arr 5  # [5]
set "val1" arr 6  # [5 [val1 6]]
# cannot have numbers as keys then.

print\n get "val1" arr  # outputs [val1 6]
print\n key get "val1" arr  # outputs "val1 6"
print\n value get "val1" arr  # outputs 6
print\n get-key "val1" arr  # outputs "val1"
print\n get-val "val1" arr  # outputs 6
# [get-val] runs the function if it is one.

set "val1" arr [print\n "hello"]  # to set functions
set "val1" arr ["hello"]  # to set strings
# or
set "val1" arr fn ["hello"]
set "val1" arr "hello"

even? [1 2 3]  # false, because list count is not even

add arr [val1 hello]  # though it doesn't check for duplicates...

let [str] "hello"
set 2 char str "x"
print\n str  # outputs "hexlo"
# but [char] should probably copy it.

let [str] char "hello"
set 2 str "x"
print\n str  # outputs ["h" "e" "x" "l" "o"]
print\n to-str str  # outputs "hexlo"

# I just realized. I don't need [get-key] – because it's stupid – but also [get-val] because that
# should just be [get].
let arr []
set "value" arr 123
print\n get "value" arr  # outputs 123
# fuck. I just realized. I can't use [set].

let arr []
set [arr] at 0 arr 123
set [arr] at "test" arr 321
print\n arr  # outputs [123 [test 321]]
# or
let-at 0 arr 123
set-at "test" arr 321
print\n arr  # outputs [[0 123] [test 321]]

# I know.
let arr [[] [] []]
set 0 arr 123
set 2 arr 321
print\n arr  # outputs [123 [] 321]
set [0 2] arr 4
print\n arr  # outputs [4 4 4]
# nevermind. I don't know.

key 0 arr 123
key "test" arr 321
print\n arr  # outputs [[0 123] ["test" 321]]
print\n get "test" arr  # outputs 321
# the key cannot be a symbol
let n 0
print\n get n arr  # outputs 123

set 2 123  # error: not bound [2]
let 2 123
print\n 2  # outputs 123
# lol.

let [arr] reduce [* 3 []]
set-at 2 arr 123
print\n arr  # outputs [[] [] 2]
# if the array was empty, it would not check if the index was out of bounds, like C.
print\n at 2 arr 123  # outputs [[] [] 2]
# [at] return, doesn't mutate.

set-at [1 0 2] arr 123 321 333
print\n arr  # outputs [321 123 333]
set-at [1 0 2] [arr1 arr2] 123 321 333
set-at range [0 2], arr, .. range [10 12]
# now I need to figure out arr vs [arr].

let val 123
let [val] 123

let func [print "hello"]
let [func] fn [print "hello"]

let [str] "hello"
let str "other hello"
print\n hello  # outputs "other hello"
# alright, from now I'm quoting the symbol passed to [let] as well.
# I can always go back if I don't like it. still, I should try this consistency thing.

let [import] fn [
    args [file]

    if ! between count file, 1, 2 [
        error [usage = [import "module-name optional-rename"]]
    ]

    let [content] read-file get 0 file
    module get 1 file
    done [add env, get 0 file, content]
    done content
    module ""
]
# doesn't change that much, honestly.

import "File"

let [main] fn [
    # Try to open a file
    let [file err] File.open "example.txt"
    if err [
        # Handle the error
        print\n "Error opening file: %" err
        return
    ]
    # Don't forget to close the file
    defer [File.close file]
 
    print\n "File opened successfully"
]
# not much at all.

let [arr] reduce [* 3 []]
set-at 0 [arr] 123
print\n arr  # outputs [123 [] []]
let [index] 2
set-at [0 index] [arr] 123 321
print\n arr  # outputs [123 [] 321]

let [arr] []
set-key "hello" [arr] 123
set-key "bye" [arr] 321
print\n arr  # outputs [["hello" 123] ["bye" 321]]
print\n get "bye" arr  # outputs 321
print\n get 0 arr  # outputs ["hello" 123]
set-key 0 [arr] 666
print\n arr  # outputs [["hello" 123] ["bye" 321] [0 666]]
print\n get 0 arr  # outputs ["hello" 123]

# hmm.
let [arr] []
set-at "hello" [arr] 123
set-at "bye" [arr] 321
print\n arr  # outputs [["hello" 123] ["bye" 321]]
set-at 0 [arr] 123
print\n arr  # outputs [123 ["bye" 321]]
# good. this fixes the [set-key 0] problem.

# I shouldn't allow number assignment. if it's more code to add such a stupid feature, I'm not
# doing it.

let [test] fn [
    print\n args 0
]
test 1 2 3 4  # a random comment.
print\n "Hello, World!\n"  # another random comment.

# this should print something like [1 2 3 4 print\n "Hello, World!\n"].
# the comments are of course ignored. I guess that's how you do metaprogramming?
let [meta] fn [
    print\n first args []
]
meta hello world  # outputs "hello", then error because "world" not bound
# or rather...
let [meta] fn [
    print\n first quote args 0
]

let [test] fn [
    for args 0 [
        if = "end" it [
            break
        ] [
            print "%, " it
        ]
    ]
    print \n
]
let [\n] "\n"
test 1 2 3 4 5 6 [end]  # outputs 1 2 3 4 5 6

let [break-list] ["for" "while" "loop"]
let [break] fn [
    pop-until [contains this break-list]
]

let [for] fn [
    args [list body]
    let [it] first list
    do body
    for last -1 list, body
]

let [it] 6
for [1 2 3] [print\n it]  # I guess [it] shouldn't be 6?
# does the static scope only work when [fn] is called then?

let [func] fn [for [1 2 3] [it]]
# equivalent to
let [func] fn [1 2 3]
let [func] fn [1 2 3]

let [test] fn [
    print\n this
]
test  # outputs "test"

do [
    print\n this
]  # outputs ""

let [test] fn [
    let [here] this
    if true [
        goto here
    ] []
]

# maybe [do] only takes strings as functions, numbers as the level.
do [
    let [x] 5
]
print\n x  # [error] not bound: x
do [
    do 1 [let [x] 5]
]
print\n x  # outputs 5

do fn []  # [error] scope level too high
# or not. [fn] should return a string. so...
do fn []  # [error] argument not quoted
# or something.

# everything is a string.
let [val] 123
char *val = "123";
let [val] [123]
char *val = "[123]";
let [val] [print "Hello, World!\n"]
char *val = "[print \"Hello, World!\n\"]";
let [val] fn [print "Hello, World!\n"]
char *val = "print \"Hello, World!\n\"";

do val  # will equally run a string as if it were a function

let [_] [this is a comment, lol.]
drop [this is a comment, lol.]

# string manipulation needs to be hella good, because it's also code manipulation.

do 0 [
    let [x] 5
]
print\n x  # outputs 5
# this is equivalent to the old [do-here].

# [head]/[tail] vs [first]/[last]?
# and [tail] defaults to -1 for the input.
# I'm still torn on what to do for an input of 0.

let [set-at] fn [
    args [key var value]
    do 1 [
        set var, at key (do var) value
    ]
]
set-at "hello" [arr] 123
# so easy!

let [at] fn [
    args [key var value]
    reduce [
        for var [
            if = head it, key [
                [head it, value]
            ] [it]
        ]
    ]
]
# wait, but how do I do [at (number)]?

# comparing an array or a list is just a [strcmp], lol.

print\n bool = 0 []   # outputs "false"
print\n bool = 0 [0]  # outputs "false"

print\n bool == 0 []   # outputs "true"
print\n bool == 0 [0]  # outputs "false"

let [null] u64 0
let [value] []

print\n bool == null value

# actually...
print\n bool == 0 []   # outputs "false"
print\n bool == 0 [0]  # outputs "false"
# because "0" and "[]" are seperately allocated strings.
# I guess [==] is check for reference and reference only. so...
print\n bool =  0, ptr []  # outputs "true"
print\n bool == 0, ptr []  # outputs "false"
# [=] is just strcmp. I can make better in the future, but not now.

let [hello] fn [print\n "hello"]
print\n reduce 1 [hello]  # outputs [print args 1; print \n]
print\n reduce [hello]  # outputs [exec 1010101010101101]... something like that.
# or not? because...
let [vars] [a b c]
let vars 1 2 3
print\n vars  # outputs "a b c"
print\n reduce vars  # outputs "a b c"
print\n reduce vars  # outputs [1 2 3]
# right, I see the problem. [reduce] actually execute the code! it just doesn't return.

# honestly, a function passed arg that returns nothing should just take another argument.
# then again... I just don't see a use case. most cases are bugs!

# maybe I should write a [strcmp] that ignores syntax chars?

# I don't know if I can do [goto] in this language. at least not the high level unoptimized version
# of the interpreter. if I do implement it, it need to be as powerful as C's goto: can go up a
# scope, backwards, forwards, down a scope – all the directions. if it can't do that, it's not
# worth having in the language. and honestly, since everything is recursion now, I guess I don't
# even need it? I don't know, I don't know.

[-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-]
[ ASSIGNMENT                                                                                      ]
[-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-]

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-#
# ASSIGNMENT                                                                                      #
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-#

# honestly, this time, the [] win. they somehow look nicer.

let [table] [
    "my-str" 123
    "another value" "Hello, World!\n"
    "do-something" fn [print\n "hello"]
]
print\n get "another value" table  # outputs "Hello, World!\n
get "do-something" table  # ... how do I run this?
do get "do-something" table  # not this, [do] only accepts strings.
let [table] [
    "my-str" 123
    "another value" "Hello, World!\n"
    "do-something" [print\n "hello"]
]
do get "do-something" table  # I guess?
let [do-something] fn get "do-something" table
# yeah, this is the best solution.

let [File] import "File"
let [open] get "open" File
# oh! another reason why numbers can't be keys: variables can't either.
let [my-file] open "example.txt"
write my-file "Hello, World!\n"
print\n get "filename" my-file  # outputs "example.txt"
print\n my-file  # outputs [(insert file struct/table here)]

let [open close] get [open close] File
let-get [open close] File
let-get [open close] import "File"

use import "File"
object "File" import "File"
# I don't know how make these last two though...
# How do you represent a function as a string?

let [table] [
    ["my-num" 123]
    ["another value" "Hello, World!\n"]
    ["do-something" print\n "hello"]
    ["do-again", fn [print\n "hello"]]
]
# this is probably ideal.
print\n get "my-num" table  # outputs 123

let [get] fn [
    # searching logic...
    print\n found  # e.g. [123]
    do tail found
]
let [do-again] get "do-again" table
do-again  # outputs "hello"

make "File" table
print\n File.my-num  # outputs 123
# or it throws if the key is spaced.
make "File" import "File"
make-import "File"

let [make-import] fn [
    do 1 [make import .]
]

let [let-get] fn [
    args [name]
    do 1 [let name get name]
]

let square [* .]
let [square] fn [* .]

let ^ [* .]
let [^] fn [* .]

# honestly, a function that executes the moment you [get] it, doesn't make sense.
let [table] [
    "my-num" 123
    "another value" "Hello, World!\n"
    "do-something" [print\n "hello"]
]
print\n get "do-something" table  # outputs [print\n "hello"]
do get "do-something" table  # outputs "hello"
# ah, I remember now, why this was a problem.
# how do we know if [do-something] is a function?
let [do-something] get "do-something" table  # string
let [do-something] fn get "do-something" table  # string
let-get [do-something] table  # string

# this instead.
let [get] fn [
    # searching logic...
    print\n found  # e.g. [123]
    fn tail found
]

let [table] [
    ["my-num" 123]
    ["another value" "Hello, World!\n"]
    ["do-something" print\n "hello"]
]
let [do-something] get "do-something" table  # function
do-something  # outputs "hello"

let-get [do-something] table

let [test] fn [
    let 1 [x] "hello"
]
print\n x  # outputs "hello"

let [make-import] fn [
    make 1 import .
]

let [let-get] fn [
    args [name]
    let 1 name get name
]

print\n map    [+ 5] [1 2 3 4 5]  # outputs [6 7 8 9 10]
# vs
print\n map fn [+ 5] [1 2 3 4 5]  # outputs [6 7 8 9 10]
# it's still just [[]] instead of [fn []] because it's basically typed.
# it only expects a function. nothing else.

# I need to figure out what this does.
do fn []
# before, it errored, but I don't know anymore.
let [do-something] get "do-something" table  # function
do-something  # outputs "hello"
do get "do-something" table  # ???
# logically, it should just run the function... but, that creates inconsistencies.
# a function is a string without quotation characters at the start and end.
# [do] needs to remove those characters, before running the code...
# I know.
call fn []
call get "do-something" table  # ???
# I guess I could call (lol) it something else, but it's clear that this only accepts functions.

# it should be [get-at] to make it clear that it pairs with [set-at] and [let-at].
# or not? since [at] is a standalone function, and [get] has nothing to do with it?
# [set-at] is called so because it is a mix of the two functions.

# I'll be using [let] a lot, and so if I made a mistake with the argument count a function, the
# program will pick up on that by telling me that the argument returned nothing (it's an error).
# The function will have take the [let] call as an argument and gotten a invalid input from that.

call fn [print\n "hello"]
# vs
call [print\n "hello"]
# what happens?
# I guess it returns a string?
# it's equivalent to
let [test] fn [[print\n "hello"]]
print\n test                    # outputs [print\n "hello"]
print\n call [print\n "hello"]  # outputs [print\n "hello"]
# because functions called with variables and literals should behave the same.
let [test] fn [print\n "hello"]
call fn [print\n "hello"]
call test  # ...
# maybe not.
let [test] [print\n "hello"]
call test
call [print\n "hello"]
# what now?
# no, with the variable it still returns the string of code.
# but doing the same for the literal is weird... but no matter.
# even for the variable, you usually only return one string or number.

let [value] 123
assert [= value 123]
# it's funny how easy [assert] is to implement.

# intrinsics.c vs functions.c

+ fn [123 321]  # what happens here?
# I can't proceed until I figure this out.

# let's think about it. the only function that really needs [fn] is [let].
let [test] fn [123 321]
+ test
let test [123 321]
+ test
# or not?
set-at "test" [table] fn [123 321]
# or yea?
set-at "test" table [123 321]    # function
set-at "test" [table] [123 321]  # string
# should 0 == [0]?
# because I mean...
print\n 0    # outputs 0
print\n [0]  # outputs 0
# okay, my intuition says that
+ fn [123 321]
# should be treated like
+ [123 321]
# so there should be a bool [is_executable].
# the function and string representation are the same.
+ [123] [321]
+ 123 321
+ [123 321]
+ fn [123 321]
# all equivalent?

# necessary
+ 123 321

# I should get rid of [fn] because of how much trouble it causes.
# [do] vs [..] are the same.
# the language is less consistent but cleaner without [fn].
# the only reason I added [fn] was [set-at].
# I should have [unquote] instead of [fn].
# but [unquote] can break things, so it should be used conservatively.
# the only time [fn] is used is during assignment.
let [a b c] get-token, args 2

import File, import "File", import [File FileImport]
# I guess this makes more sense with [load]?
load ./lib.txt, load "./lib.txt", load [./lib.txt lib]
# though I need this...
load ./my\ file.txt, load "./my\ file.txt", load [./my\ file.txt MyFile]
# but what about
print\n "hello"
# ?
# wait.
import "File", import File "File", import FileImport [File]
# maybe? but I really don't like repetition! I want to avoid it!!
# this model is the best one. it's the cleanest, and shortest one.
import File, import "File", import [File FileImport]
load ./lib.txt, load "./lib.txt", load [./lib.txt lib]
# I can't import only a specific few things, but who cares!
# in other languages I always did things like this.
from numpy import *
# Jai also doesn't have the ability to extract specific functions.

# it doesn't look like stack-oriented programming language, but it is.
# or stack-based?

use import-as "File"

# I will probably have to do malloc to 'capture' variables.

let str ["Hello, World!\n"]
let [str] "Hello, World!\n"
print str  # outputs "Hello, World!\n" for both.

print do ["%\n" 123]  # outputs "123\n" ?

let my\ function [print\n "hello"]
my\ function  # outputs "hello\n"
# I can't have call or assign without '\'.
my\        function  # maybe the amount of whitespace doesn't matter?

let test [
    let [var] new [hello]
    ptr-to var
]
print\n test  # outputs "hello\n"

load ./src/
# honestly, I didn't expect this.
# that was something I liked about the nix programming language. who would have thunk?

# though I should this consider this.
./src/print\n "hello"  # outputs "hello\n"
# like a shell script.
File  # is already in the PATH
# so we just need to do
use File
# or
File/open "file.txt"
# but what is [/]? is [File] a directory? a file?
let open [File/open]
let close [File/close]
# need to know how Jai does it.
# what does this do?
print\n File
# I guess there is a file called "File.txt" and a directory called "File"
# [File.txt] contains all the loads for the folder [File], though there's no real need for a
# folder. it could all be contained within the file.

# preload module?

# I'm not doing the shell imports...
# If I do, then [.] and [/] have to special characters.
# I don't know if I want that.

# then again... it would look nice.
File/open "file.txt"
let open [File/open]
use File
# where [File] is a directory.
# but what is [open]? a single file? a function within a file?
# or I guess more like zig?
File/file.txt/open
# both directories and file count in the path.

append PATH "path/to/modules"
include "path/to/modules"

# hmm, I'm not liking how .txt is removed from the thing, but I'm not liking keeping it either.
# honestly, the shell model only works if you have single file binaries.
# don't now how I would actually do that though.

# if I did make it, [/] would be like the interpolation character.
File/open
# instead of [$].
$File/open

File/my-file.open "file.txt"
# so [/] for directories, [.] for files?
# I know none of this is getting in, but whatever. still interesting.
# yeah, giving up on it. too hard to implement.
# guess this language can't really be used as shell then?

# maybe?
import "File [open close]"
# well, if I really need this feature.

# eh.
import "File" as "FileImport"
import "File" as ""
import "File" as "File"
# I will take the shortest.

for 0 []  # should probably not execute.

# I guess if a function returns a non quoted string, it should just run it? but all number are non
# quoted strings... or i guess [do] just work for everything.

object [Vector3] [x y z]
print\n Vector3.x [1 2 3]

# function for strings passed by copy, strings for pass by reference?
# but strings are just functions that return strings.

let [value] if condition [function1] [function2] input
# pass [input] to [function1] or [function2]?
# I can and I will. I just need to evaluate the [then]/[else] bodies of the if statement.
# not [do] them!, just put the string in the stack.

let [value] if condition [
    function1
] [
    function2
] input

let func1 [print "printing func1!"]
do format [func%] 1  # outputs "printing func1!"
# [format] may be more useful than I thought. especially for macros.

# a static scope might be easier than expected?
# same process as the old language implementation, but the recursive lookup will search another
# linked list?

do format [let 1 % 123] "value"

let let-get [
    args [symbols table]
    do format [let 2 [%] get symbols table] symbols
]
let-get [open close] import "File"
# I guess this is the best way of doing this?
# but anyway, while we can, I should avoid doing this.
# it's ugly, and impossible if you consider recursive function calls (i.e. for/while loops)

# [Volatile] If you change these, the bytecode has to change!
enum [
    SOMETHING
    SOMETHING-ELSE
]

# I really need to make it so [get_type] properly identifies quotes, like with the scan and layers.
# just to make sure that the first and last brackets are actually pairs.

object [Node] [
    value
    next
]
let [node] [123 [321 []]]
print\n Node.value node  # outputs 123
print\n Node.next  node  # outputs [321 []]
print\n Node.value Node.next node  # outputs 321
print\n Node.next  Node.next node  # outputs []

Node.value! node 124
print\n node  # outputs [124 [321 []]]
Node.value! Node.next node 322
print\n node  # outputs [124 [322 []]]
# I guess?

do [
    use Node
    print\n value node  # outputs 124
    # it's not that different from something like a typed function.
    print\n Node  # outputs [value next]
]

# maybe I should always [debug-stack]? just as a implicit way of telling you not to fuck up.
# it prints to stdout, all the values of the stack at the end, always.

let get-obj [
    let inner 123
    let [obj] [print\n inner]
    obj
]
let obj get-obj
obj  # Variable not bound: 'inner'
# this is probably fine for now right?

let get-obj [
    let [obj] [print\n inner]
    obj
]
let inner 123
let obj get-obj
obj  # outputs 123

# do I really need to capture variables?
# the best use for it is encapsulation.
# ... wait, but can I do encapsulation without captures?

let empty []
let args [1 2]
print\n - empty args
# I'm going to allow this, I think.
# it require more code to prevent it.

# I think pointers will really be key to pass by pointer.

let ptr to [1 2 3]
set-at 0 ptr 5
print\n ptr  # outputs (random pointer)
print\n of ptr  # outputs [5 2 3]
print\n get 1 ptr  # outputs 2

let ptr new [1 2 3]
free ptr
let test [
    let ptr new [1 2 3]
    ptr
]
# I guess it makes sense? in scheme, references are also just lists.

# oh! okay, so the pointer is stored in the stack, or environment, and the actually value is
# somewhere in memory.

# hmm.
let ptr new 123
set-at 0 ptr 321
print\n get 0 ptr  # outputs 321 ?
# I don't know. it feels awkward.

# I feel like I need a mixture of a stack and a queue.
# a global stack for everything, then a queue individual scopes.
# what is left in a queue after a function returns, is pushed to the stack.
# ... no, the simpler solution is to just reverse n amount of arguments in the stack.

# maybe the special thing about [for] and [while], is that [->next] for [Program] pointers skip a
# scope? and you know, giving the illusion that the scope is special, while still retaining the
# variable are are popped after the stack gets deleted.

let func [
    let [_ _ _]
]
func 1 2 3

let func [
    let [a b c] args 3
    print\n reduce [a b c]
]
func 1 2 3

let func [
    args 3
]
func 1 2 3  # outputs 

# don't forget: free all variables at the end of the scope.

# wait, shit.
# how do I define [print\n] using the language?
let print\n [
    print args 1
    print \n
]
# ...

# oh!
let print\n [
    defer [print \n]
    print
]

# or simpler...
let print\n [
    print "%\n" format
]
