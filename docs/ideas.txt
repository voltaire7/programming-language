[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
    print a
    print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
    eprint msg
    exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functional and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

(define (fib n)
    (if (or (= n 0) (= n 1))
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functional caracteristics.]

[Converted jai code]
atom [render] do [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
    print [Hello, World!]

    if true
        print [yes]
        print [no]

    loop print [loops forever]
    for 0 10 print format [prints 10 time. this is [i]]
    while condition [you know.]

    [<3]
]

[Procedural vs functional]
atom [main] do [
    add [x] 1 2
    eq [y] x 3
    if y print [truth] print [falsehood]
]
atom [main] do [
    if eq 3 add 1 2
        print [truth]
        print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
    format x [Hello [y], my name is [z]]
    print x
]
atom [complex x y z] do [
    atom x format [Hello [y], my name is [z]]
    print x
]

[Holy fuck! Procedural actually beats functional... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
    : [x] 1 1
    tail [y] fib:x
    zipWith [y] [+] fib:x fib:y
    : [x] x y
]
atom [fib out init] do [
    : out init out
    tail [t] out
    zipWith [z] [+] out t
    : [out] out z
    fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
    print [do stuff...]
    > bool a b
    if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
    atom [temp] x
    atom x y
    atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
    atom [low] 0
    len [high] items
    sub [high] high 1
    <= [cond] low high
    atom [continue?] true
    while cond do [
        add [mid] low high
        div [mid] mid 2

        cmp [c] mid target
        equal? c do [atom result mid atom [continue?] false]
        less? c do [atom [low] mid add [low] low 1]
        more? c do [atom [high] mid sub [high] high 1]

        <= [cond] low high
        && [cond] cond continue?
    ]
]

atom [binary-search target items] do [
    atom [low] 0
    atom [high] sub len items 1
    atom [continue?] true
    while && <= low high continue? do [
        atom [mid] div add low high 2

        atom [c] cmp mid target
        equal? c do [mid atom [continue?] false]
        less? c atom [low] add mid 1
        more? c atom [high] sub mid 1
    ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
    proj-rect [pr] proj-x proj-y
    unpack-color [pc] PROJ-COLOR
    fill-rect pr pc

    unpack-color [bc] BAR-COLOR
    fill-rect bar-rect bc

    for targets-pool do [
        target-rect [tr] it
        unpack-color [tc] TARGET-COLOR
        if !it.dead fill-rect tr tc
    ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
    add [x] x y
    print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functional...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
    add [x] x y
    print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
    add [x] x y
    print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[vs]

atom [test] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functional way for the bros:]
atom [test x y]
    print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functional translate on the lower level?]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functional, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
    print [still true]
    break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
    sub n 1
    == n 0
    false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
    proc
    loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
    cmp [result] it to
    = error [[it] and [to] cannot be the same values; please try another combination.]
    > for-
    < for+
]
atom [for-] do [
    proc
    sub [it] 1
    cmp it to
    != for it to proc
]
atom [for+] do [
    proc
    add [it] 1
    cmp it to
    != for it to proc
]
atom [for-each items proc] do [
    get-len [len] items
    for 0 len proc
]
atom [while proc] do [
    atom [while?] true
    atom [label] while?
    while-arg
]
atom [while-arg] do [
    proc
    if label while-arg []
]

[But functional may actually come out of it as well...]
atom [+ x y] do [
    add [x] x y
    x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
    add [x] x y
    x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
    proc
    next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
    proc
    next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
    x
    add [x] x y
]
+ + 1 2 3
[Should I consider functional again?]

[Wait, no. Shit gets fucked up.]
atom [x] + 1 2 atom [y] 3 do [
    x
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    + 1 2
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        x
        add [x] x y
    ]
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        1
        add [x] x y
    ]
    add [x] x y
]
[Maybe if I made [x] and [y] local to the procedure?]

atom [add-all x y] do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
]
add-all 1 2 3 []
atom [x] 1 atom [y] 2 do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
] 3 []
atom [x] 1 atom [y] 2 add-all x 3 []
[Hm. Does it really work like that?]

[More functional]
let [x y] 1 2
atom [x] 1 atom [y] 2

[Should be equivalent?]
atom [func x y] []
atom [func] do [let [x y]]

[Maybe it's that simple?]
atom [atom name value] push-key name value atoms
[But any more than, and we're implementing stuff.]

[Functional again]
atom [+ x y] do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
+ + 1 2 + 3 4
atom [x] + 1 2 atom [y] + 3 4 do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        1 2
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        3 4
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
[Is it impossible? Well whatever. I can tell already: the hoops you have to jump through to get this
behavior is insane. I will probably still try to make this work, but the procedural way is far
better. You know, left-to-right and infix is just more elegant.]

chain 1 + 2 + 3 + 4 as [test]
print _ [outputs 10]
print test [outputs 10]
[I mean look at this! It's fucking beautiful!]

[Rust syntax]
atom [let name] []
atom [= value] atom [name] value
atom [;] atom [name] []
let [test_val] = 2 ;
[Well, "Rust" syntax.]

[Delete]
atom [delete name] atom name []

[I don't think this language should have something like function overloading.]

[Maybe I could have a [type] [Single] that can only be called once, and once done, it will be
removed from the list of variables?]

[If each variable has the following values:]

struct [atom] [
    name value before after
]

[where [name] is of course the symbol of the [atom], then [value] is the what it returns, or the
pointer to the value in memory. What if there was [before] and [after], where [before] is code that
gets executed before the value is called, while [after] is code executed after it's called. So like,
in [before] we could have a macro that sets up the arguments of the procedure, then adds the [value]
after the declarations? And in [after], I could have some RAII clean up? I think I'm unto something,
but the idea needs polishing.]

[Btw, if I do [before] and [after], I could probably do this:]
type [+] [
    before atom [x] prev 1
    after atom [y] next 1
]
atom [+] add [_] x y
1 + 2 print _
[I'm not sure where I'm going with this, frankly.]

[Maybe the entire program is actually a list of tokens that can change itself.]
1 2 3 print get 1 program
[outputs 2?]

[Or maybe...]
atom [+] add #-1 #1
1 + 2
[where #n is a relative value? But how do [add] work then?]

[I really need to start working on the implementation. There's only so much I can do with only
theory, and so little technical knowledge.]

[I know that, eventually, everything becomes [hex []], and then gets executed. But how does it do
it? *Sigh*]

[I feel like python will be more useful for learning how to write this programming language than
Rust or C...]

[Is this programming language becoming too complicated, like LISP nowadays?]

[I should stick with the S Expressions. Adding anything else is bloat.]

[Btw, the model where we do [add #-1 #1] is interesting but stupid, because what is [add] defined
as? There is still a lesson here though. Just need to find out which.]

[Maybe I shouldn't have a hex procedure? Maybe numbers simply get hexecuted (?) when 32 bits have be
gathered? Maybe numbers are just functions that reduce to themselves in binary format?]

[I think I should just use hexadecimal for all number types. Like what, is anyone going to use my
programming language expect me? And little endian too. Of course that would mean I need to get used
to hexadecimal, and convert it off the top of my head, but otherwise, I should try it and see how it
works.]

[Incidentally, in regards to trying out things, I think the 3 space indent is bad. I tried it for
some C code, and while it isn't as noticeable for small procedures, for larger ones, 3 spaces just
feels wrong. Not to mention, 4 spaces is byte aligned.]

[I think I might replace every instance of [atom] with [macro], because that's what they are. But I
don't know. [atom] sounds real nice.]

[If I write]
mov x0 [str]
[should x0 now have the utf-8 value of [str]? I feel like yes... But that would mean that mov isn't
a parameterless macro... Though.]

[This blows. I found out that the way an instruction is encoded is not necessarily byte aligned, an
so I will find it difficult to write the most basic macro...]

[And now chatGPT tells me that not every instruction is 32 bits. This is going to be so difficult.]

[Oh hey there, I didn't see you. So after giving RISC-V's specification a look I saw that unlike
arm64, the opcode is the smallest value, and the destination register is the thing that follows. So
I think I'm going to try and run the programming language on a RISC-V platform. This is of course
far harder than it sounds, but no harm in trying.]

[The idea about abandonning [hex []] is no longer realistic. To begin with, opcodes are not byte
aligned, whether on arm64 or RISC-V. So I'll instead have something call [bin []].]

[Damn, I don't think I could even do something like [[mov] -> 000000] because, we do do know that
[x1] will be a fixed size, but not the number that follows.]

[I am a little conflicted now: in [foo] could just be a function pointer, and you call the pointer
by putting parentheses after it. This is elegant, and I like it. Question is, how do I replicate the
behavior? Do I just quote it? But then, how is it different from a normal string? How do I, for
example, [printf] a function pointer? Damn, this is tough.]

[Ok this is something that might give LISP edge: by typing [func], you get the function pointer, by
typing [(func arg1 arg2)], call the function. But man, this sucks, because I build this whole idea
over the premise that the LISP model is imperfect. I can cede just yet...]

[I figured it out, if every value in LISP returns a pointer by default, then you would have to call
variables as well (even more parentheses; heck no!). And in C, you constanly reference and
dereference a variable, which is the equivalent of quoting and unquoting, but with a different
syntax. Not to mention you don't really have symbols. In which case, I still need to figure out the
tug of war between symbols, pointers and values.]

[Iteration may actually be better than recursion... I mean, in assembly you have branch and branch
with link; so while you usually do recursion, it's not really the same.]

[More details about eager vs lazy.]
chain 1 + 2 + 3 + 4 as [val]
macro [val] do [chain 1 + 2 + 3 + 4]
[The first one is eager because the program takes those additions and executes them left-to-right;
the second one is lazy because [macro] gets executed, but not the arguments, since they are absorbed
into the procedure call.]

[I've been getting pretty decent at the CLI, but doing so, I question having to put [] around every
thing that isn't a function or procedure call. Maybe I should follow LISP in this?]

[Another reason why I shouldn't do [import] and instead just reference a file like a script is that
I want the compiler to be single pass, but doing it otherwise would be complicated.]

[Okay, so big problem for procedural:]
atom [add x y z] todo
[How do I define it?]
atom [add x y z]
    atom x + y z
[Like this? Do you see the problem? Thing is, I'm trying to merge [add] and store instructions into
the same thing, but they are not the same thing. The solution could be as follows:]
atom [+ x] do [
    add x0 _ x1
    store x0 [_]
]
[where everything returns to [_]. Only the instructions themselves will keep use the old format, the
rest will behave much like functional, but still left-to-right.]

[But then again...]
atom [+ x] atom [_] add _ x

[It's important I get this right, because if I don't, the programming language may be dog shit.]

[Maybe everything that hasn't been defined yet evaluates to itself, quoted. So that's how I could do
numbers.]

[I might want to create a proper proper LISP first using my low level model, just to get the hand of
it.]

[Perhaps...]
atom [recursive-proc x y] do [
    todo x y
    goto [recursive-proc]
]
[that way, there is no need to redefine [x] and [y] since they are already defined.]

[[before] and [after] may be too much. An [env] should only have [symbol], [value] and [size].]

[Do I really need dependent types? Is there no better way to check for correctness?]
atom [val x] do [
    < x 0 true? error [cannot be negative]
    todo
]
val -1
[The linter should be smart enough to tell that this will always throw, and warn you of it. No need
for types; they are too complicated anyway.]

[I am all the more motivated to create a LISP, because of this:]
(define func (lambda (a) (display a)))
[Because it's eager loaded, lambda executes, creates a procedure, and returns the pointer to it.]
(func "Hello, World!")
(func func) [outputs something like 0x20D1A5BC]
[Holy fuck, is this elegant...]

[Maybe]
atom [func] lambda [a] print a
func at [func]
[outputs something like 0x20D1A5BC]
func do [func] [Hello, World!]

[In LISP, you have special notation for quoting, but everything else is call by value or call a
procedure. In my language, lists are quoted by default, and if a procedure has args, they are called
by default, when not quoted. But that was the funcionnal one. What about procedural?]

atom [func] lambda [a] print a
[Does not work because [lambda] is lazy. And procedures shouldn't be able to returns things.]
lambda [a] print a as [func]
[I think this works, but should I?]

[Once again, functional is making a comeback.]
[Also, I really need to figure out how to lazy [print]...]

[Okay, lazy vs eager eval really fucks me up, because you have to mix them up, right?]
atom [test] do [
    other-func lambda [x] x
    print _
]
[Does lambda create a new procedure everytime [test] is called?]

atom [func] lambda [x y] todo
[[lambda] is eager, but todo is not? What is the logic behind that?]
lambda [x y] todo as [func]
[More ugly but makes more sense. Maybe I already found the answer; and I'm just being stupid:]
lambda [x] x
atom [test] do [
    other-func _
    print _
]
[I guess it is still better than LISP, since I doesn't have some arbitrary procedures that lazy
instead of the eager default.]

[I should drop the eager function as arguments, or whatever. Doesn't make sense with new model:]
atom [func x y z] do [
    print x
    print y
    print z
]
func [add] 1 2
[becomes]
do [add] 1 2
[wait no... I have to rework [do []] if I do that...]

[I should consider it seriously still... The biggest problem is [atom] and it's implementation.]
[Maybe [list] will make a comeback? Nevermind again. There is simply no way of doing this without
having non-quoted lists.]

[Ok, let's think. Because I think I am unto something.]
[Still a comment/string]
(define [name] 5)
(print name) [outputs [pointer] so bad]
(print (name)) [outputs [value] so good]

[Ok, now without parentheses, or less.]
[Comment]
define [name] 5
print name [outputs [value] so good]
print ptr-to name [outputs [pointer] so good]
[problem is: should it be eager or lazy]

[cannot be eager]
define [func x y] do []

[this can]
define [func] lambda [x y] [print x print y]
func 1 2
[becomes]
let [x y] 1 2 do [print x print y]
[but should I?]

[what about]
define [func x y] ()
[yeah, I've got nothing. I thought I was unto something last night; something to do with parentheses
to be used for eager loading, but I don't remember what.]

[wait no, the lisp example works because the [value] of [name] is a pointer to a pointer!]
[damn, I went through this train of thought a while ago...]

[In any case...]
atom [atom symbol return] do [
    ch symbol len > 1
    then do [
        car symbol as [name]
        cdr symbol as [params]
        atom name lambda params return
    ]
    else append env symbol return
]
[but it has to be lazy, otherwise [then do []] will get evaluated.]
[god this shit is confusing]

[maybe...]
atom [then x] if _ x []
atom [else x] if _ [] x

[it should be lazy, but then I can't do [lambda]...]

[optional []?]
define name 3
atom [define x y] do [
    quoted? x atom x y
    else atom quote x y
]
[something like that?]

[it would be a bad practice though, but would make the all variables are quoted if undefined work.]

[Hmm, if I do this...]
atom [items] [ 1 2 3 ]
[This would be a 5 [strings] or [u8] pointers, and the atom macro would see that the first pointer
points to a value representing a array oppening, and then do the magic.]

[Man... What the first macro takes the rest of the programming language as parameters? I think I had
this idea before, but I would love to see this work!]
+ 1 2 - 3 4
[[+] takes the first two values, then the rest; since it knows it only need two values, it simply
executes [eval] or something like that, then [eval] executes the rest accordingly. If it's a
[string], it calls eval on the next value; so on.]

[Again, infix syntax, but not really.]
atom [| x y] x _ y
quote name | atom [John Doe]
[Basically piping, but dummer. Equivalent:]
quote name atom _ [John Doe]
[This is not valid...]
atom quote name [John Doe]
[Since there are only side-effects.]
[Also, I guess [x] is the first argument, while [y] is the rest of the application?]

[Okay, listen.]
atom [proc1] do [
    get args 1 as arg1
    print arg1
]
[because [args] is the rest of the application. So you can just index into it like some ordinary
array. I love this!]
[In fact, I can probably still do this:]
atom [proc1 x y z] do []
[equivalent]
atom [proc1] do [
    get args 0 as x
    get args 1 as y
    get args 2 as z
]
[Like bro, this is more elegant than anything I've come up with before!]

[Holy fuck.]
print [test]
print [test again]
[Usually, when you call a procedure, the things get put in the stack, but because the procedure
you're calling is the one calling the next procedure, you fix most problems with recursion just like
that!]

calculate bottom top = sum $ filter (\x -> mod x 2 == 0) [bottom..top]
[suppose...]
atom [calculate bottom top] do [filter []]

[I don't really like this]
1 + 1 print _
1 + 1 dbg
[I probably won't keep debug, idk]

[Functional won't die]
atom [print x] do [
    quote? x
        then write x
        else do [
            x args
            print _
        ]
]
[so]
print + 1 2 [outputs 3]

[the beauty of this language is that anything is permissible]
[the ugliness of this language is that anything is permissible]

atom [+ x y] do [
    num? x else do [x args as x]
    num? y else do [x args as y]
    + x y
]
print + * 1 2 - 3 4

[I don't think I have to check for variables though?]
atom [name] [Joe]
print name
[Damn, I don't know!]

[btw, just remembered that I still don't know how to do [atom [] do []], at least not elegantly.]

[in [bc] you can do [sqrt(2)] and the result is [1], but with [sqrt(2.0000000000)] and the result is
[1.4142135623]; very interesting.]

[The reason why [+ + 1 2 + 3 4] will never be possible is because in [+ a b], [a] and [b] will have
to be argumentless functions that always return the same thing, which is obviously not procedural.]

[Then again... Yeah, functional will never die. Anyway, can't way to finally put this project into
motion.]

[*Sigh*... Maybe I should add types... Otherwise, it becomes such a pain in the ass.]
1.2 + 5 print _
[How is [+] supposed to know if 1.2 is a float without specifying it...? [+float] maybe?
[float-add]?]

[Maybe I will have types, but they are not user declared?]

atom [func x] fn [
    print x
]
[[fn] is eager, compiles the quoted code and returns pointer to it?]
atom [val1] [func]
[[val1] = symbol to function.]
do val1 1 [outputs [1]]
atom [val2] func 2 [outputs [2]]
[[val2] = [] because [func] got evaluated, and returned nothing?]

fn [x] [print x] as [func]
[more standard lambda?]

[still, I could make it so [atom] always evaluates the value, it's just that if it's a variable,
then the variables value will get assigned to [_]?]

[maybe I could consider this:]
atom var [this is a string]
atom [var] [print [this is code]]
[...but I already decided not to do this. If I do, the floodgates will open...]

[btw, [let]]
let [
    a 2
    b 5
] []
atom [let x y] fn [
    count x as x-len
    for 0 x-len [
        get x it as [x0]
        += [it] 1 get x it as [x1]
        atom x0 x1
    ]
    do y
    x-len / 2 pop _
]
[maybe a way to do scoping?]
[nvm, can't define global variables this way.]
[wait, not [pop 3] but reverse of [for]?]

[right, almost forgot, if [fn] or whatever compile completely, we would need to compile the program
supposing that we can stand long load times, since once the procedures have been assigned, and
therefore compiled, they will run like it's a binary. food for thought.]

[Perhaps this is the only overloading I need?]
2 + 2 [integer addition]
2.0 + 2.0 [floating point addition]
[you would need to keep track of what value is what type yourself. The programming language doesn't
do it for you.]
2 + 2.0 [float added to int; fucks shit up]
[also, I guess imaginary and complex numbers are kind of the same as integers, so you just need to
keep track of that yourself as well.]
[there's also this]
2u64 + 2 [but maybe not? since temporary storage is like fixed size, but then again, it's also just
a pointer... idk]
[anyway, I should first try to avoid metadata like the plague, and see what happens.]

func 1 2 as [val e]
[multiple assignement?]

1 > 0
    then print [is bigger]
    else print [is smaller]
[^ this may be impossible, since [get args 1]]
atom [then x] [
    [insert branching logic]
        x args
]
[since args is just a pointer, and the [x] in the assignement move the pointer right, you can just
do this.]
[still, it might be useful to have something like this:]
1 > 0 ?
    print [is bigger]
    print [is smaller]
[to prevent else from executing. idk.]
[wait, shit. I remember now why I had to quote [x]: how do I know the args of [print] shouldn't be
executed?]
1 > 0
    then [print [is bigger]]
    else [print [is smaller]]

[btw, this may be possible:]
atom [func x] [
    do-shit x
    x args
]
1 func [+] 2 print _
[nice.]

[I'm still debating variable and procedure assignement.]
proc [x y] [x + y print _] as [add-show]
[^ this works, but it's ugly.]
atom [func x y] + x y
[doesn't work because of lazy vs eager.]

[i think this is the best:]
atom a 2                            [value of 2]
atom str [this is a string]         [pointer to string]
atom func' func                     [same pointer]
atom [hello x y] [print [hello, world]] [compile procedure, [hello] now has the pointer to it.]

[but that opens so many doors, and closes a few.]
atom [+= val n] [
    n + val as val
]
[or maybe it doesn't close doors?]

[i should really consider this]
let [a 1 b 2]
[idk in what form though.]

[Wait a second...]
atom [func x y] fn [print [thing]]
[this may be possible if [fn] moves [args] to the right.]
[not very useful, though, since [fn] can't return anything...]

[still can't do this though]
0 then print x
[[print] needs to be evaled to move [args]]

[Sometimes, it's just ugly. I don't think I should go to such lengths just to avoid
[proc [] [] as [f]]]
[Death to syntaxic sugar!]
[Also, quoting non-evaluated strings is just better. No suprise there.]

[I could do this, though it's ugly.]
0 then 1 print x
[where]
proc [skip f] [
    [branching logic]
        f args
    += args skip
] as [then]
[could be worse]

[Remember to implement flipjump in the language.]

[I guess it's also a bit like vertical align: it's ugly but objectively better...]

[maybe I could have [proc] and [item]?]

[I doubt I could compile a procedure using the C interpreter, but I could probably do a scuffed
variant, one that write C code to a file, compiles it and then executes the binary.]

[I should have donut shaped code that prints donut as a demo.]

[My [env] stack should have standard CRUD operations, plus upsert.]

[I should make [bin-exec] as small as possible, i.e. ignore all the characters other than 0 and 1.]

[I realized something.]
2 print _ [outputs 2]
item [a] 2
a + 2 print _ [panic at a, because it is treating [a] as a procedure pointer.]
ch a + 2 print _ [outputs 4]
[guess [ch] makes a comeback.]
[btw, would've been classy is it was called [return] instead of [ch], but it's too long, and it
doesn't make sense in a lot of situations.]

[I should consider making numbers not special. So the simplicity is taken to the extreme. Like
functional, it needs testing.]

[Also, experiment with tabs for vertical align.]

[Should do tetris in C, then in this language.]

[I should mention, this language is procedural, yet it is still takes inspiration from lambda
calculus.]

[Don't forget to experiment with spaced variable names. I doubt I will actually use it in
production, but I want to see what it would look like.]

[btw, the way procedure calls are done, allows infinite recursion.]

[When I finally figure out how vim works, I will make Control+S wall.]

[Maybe [return] could assign the [_] of the outside scope!]

[Damn, procedure definition may be easier than I anticipated!]

[Should have procedures to manually push or pop a env.]

[1.0 will only release at the end of my life, after I will have thoroughly tested the language.]

[Recursion doesn't really work.]
proc [] [
    func
] as [func]
[How is it supposed to know that it's called [func]?]

[Probably will have to use [goto]]
proc [] [
    label [start]
    do-stuff
    goto start
] as [func]

proc [label] [
    item [start] position
]
proc [start] [
    item [position] start
] as goto
[I heard that [goto] is, like, literally Hitler, but this is the cleanest way to do recursion,
without doing recursion.]
[We're getting further and further away from functional programming...]

[I'm curious, just how different will the implementation turn out to be?]

[Wait, couldn't I just use [goto]? no need for procedures and all that – yeah, this language is
getting worse by the second.]

[If you want to redefine [eval] and use the new one, you can only do so by calling it on a [Quote].]
proc [code] [
    [do-things]
] as [eval]
eval [print [Hello, World!]]
[or]
read-file [main.txt] eval _
[You know what? The procedure notation is growing on me. I don't know how to feel.]

[Oh shit, I might have to manually [free] strings like in C, if I really don't want metadata...]

[Maybe I should use [mark] instead of [label]?]

proc [e] [
    print [%s\n] e
    exit 1
] as [error]
[where [e] is a pointer to a string. It has a unique id and error message!]
item [index-out-of-bounds] [Index %i is larger than the maximum %i\n]
throw index-out-of-bounds
[wait no]
proc [e] [
    item [err] e
] as [throw]
[It should do something like assigning to the super env. Like [return] but for errors, and instead
of using [_], we use [err] or [e].]

[Holy!]
item [code] [
    print [hello\n]
]
do code
[This looks good!]

[Recursive printing?]
item [x] [%\n]
print [%s] x 5
[prints [5\n]]

[I think I should really make separate procedures for [insert] and [update]...]

[Damn, I'm seriously considering adding metadata...]
1 + 1 print _ [Can't even do that!]
[Adding metadata would be exceedingly simple: just another field in [Entry].]
[... Yeah, I going to do it – Or at least try it, the same way I tried upsert.]
[maybe [let] for upsert, and [set] for update? Also, I could make it so both are insert in there is
no existing variable in either self or super?]
[No, there would be two upsert, but they behave differently: one first checks if a variable exists
anywhere, the other calls upsert immediately.]

[Perhaps I'm giving myself too much of a headache?]
item-in 1 [a] 42
[^ this assigns one layer higher.]

[what if [meta] is just a string to for code to be executed?]

[I shouldn't forget to implement library like numpy, sciki-learn, tensorflow, pyplot, pandas,
matplotlib, lodash; maybe some minimal js frameworks like htmx or alpine.js; i don't know. Anything
that seems pertinent. Oh and also things like SDL2 and/or raylib]

[I don't think I will do this:]
item [name] [World]
print [Hello, [name]!\n]
[Too much nesting.]
print [Hello, %!\n] name
[better]

[maybe a procedure [do-here] that doesn't push another environment?]

[Do I really need a [meta]? The only reason you might want it is because floats are weird, that and
nicer syntax. If you really cave in and add them, a lot of other doors open, which should remain
closed...]
1 + 1 print [%i] _
[^ this is equivalent to the earlier code; and it's what I do in C. This isn't Hitler or anything.]
[My goal is to make the compiler as small as possible, while still having the performance of C, and
the capabilities of Scheme. I should hold myself to higher standards.]
[This will be really awkward when I do decide to add metadata...]

[I need a [format] procedure for [print]. And I need to malloc and copy a string. I can't print
character by character, since when I encounter an error, it will have printed until the error.
Still, I makes it harder when you don't know the final size of it. Maybe malloc every time I
encounter a %?]

[I will probably put something like as an example, but I want to put it here because of how nice it
look.]
proc [x y] [
    print [Hello, World!\n]
] as [proc]

proc [name] [
    print [Hello, %!\n] name
] as [greet]
greet [World]

print greet [
    will output:
    [parse copy-token item [name] _ print [Hello, %!\n] name]
    and maybe:
    [iter [k] keys [parse copy-token item k _] free keys print [Hello, %!\n] name]
    also [do-here] to evaluate iter block without creating a new environment – or maybe I should
    instead do [item-in]?
]
[How many programming languages can you do that in? I mean the [item k _]; in C you could create a
hashmap, but I this language this is the default. I like.]

[[parse] and [copy-token] and the like should only be usable in a higher scope. Otherwise, things
get really messy. Further experimentation is needed.]

[Maybe I can have two different [do]?]
item [do] [stuff...]
do []
[^ need to do this to see changes.]
item 1 [do] [stuff as well...]
[the change is immediately noticeable, since the rest of the code is executed using this [do].]

[As scuffed as procedures are now, I can't make them in another way without adding metadata, but
adding metadata is worthless since I eventually plan to compile these things.]

[The more I think about, the more difficult compiled symbolic programming sounds. I suppose that why
it hasn't been done yet, in the straightforward I'm trying to do it, I mean. Or has it. Probably
some LISP dialect.]

[Fuck it. I want to simulate compiled procedures. I don't want to write [do] everytime, so I will
use metadata, but only for this specific case; and then, I will naturally remove it once I can
compile them. The only other alternative to using [do] is to write C files, compile them and run
them from the CLI – something I want to absolutely avoid.]

[I don't just want to make the interpreter as small as possible; I want to follow the unix
philosophy in general.]

[Damn, I make a lot of typos.]

[Wait...]
for 0 10 print [%i\n] it
[this could work because [for] remembers the start of [print]; once [print] finished executing,
[for] continues executing, and returns the pointer back to the start of [print].]
[I should really consider it, so I can avoid nesting as much as possible.]

[For using the REPL of this programming language like a shell, I would need a way to import binaries
and call them.]
load-bin [/usr/bin/]
bc [-e sqrt(121)]
[this should print 11]
[although, I might need quotation like in the shell]
bc [-e 'sqrt(121)']
[maybe I can also load individual binaries or entire folder accordingly]

[Do I say S-Statements instead of S-Expressions?]

[Just found out about realloc. Should use it to concatenate strings.]

[Shit, how do I malloc?]
item str [hello]
item-at 0 str [H]
print str [outputs Hello]
[Maybe it's no that difficult?]

[Man, being able to define procedures opens so many doors!]

[I can make a [format] procedure with the new concat function.]

[I should be [get] and [set]]
item [str] [Hello]
get 1 str print [%c\n] _ [outputs 'e']
set 1 str [E] print str [outputs 'HEllo']

[Should I have a special syntax for characters?]
[or maybe]
item [char] [x]
[if the value is a single character long, it just interprets it as a char? No need for malloc?]

[Still, I would have to be mindful when implementing string manipulation.]

[Wait a second...]
proc [] [
    + 1 repeat _ [parse 2] do
] as [?]
5 == 5 ? [] []
[^ an interesting way to implement if statements.]

[Numbers have to be treated specially, otherwise...]
item [a] 1 [throws error, undefined symbol]

[Should I make it so that [return] pops the scope?]
proc [i list len] [
    for [n] list [
        ch n == i ? [return 3 n] [++ len]
    ]
]
[Maybe something similar for [continue]? Like, it's equivalent to [goto 0], or something?]
[Perhaps break as well, but it returns nothing?]

[I'm starting to think that i need special notation for char.]
item [c] 'c'
[^ the string [c] is equal to the char 'c']
[I could make it so a string of length 1 becomes a character automatically, but right now, I don't
know.]
char [a] item [a] _
[^ maybe?]

[Just realized that my language simulates function currying.]

[For [do-here], I don't need anything special; just don't create a new [env], change the [start] and
[end] positions.]
proc [x y] [
    do-here func x y
] as [func]
func 1 2
[First call creates a new [env] because of [do], second+ calls do not.]

[Btw, [type?] is impossible.]

[Everything I say here will probably change once I actually compile the procedures, but whatever.]

[There no point to [then]/[else]]
1 ? [print 1] []
1 then [print 1]
[^ same length]
[I would have to rename [then] to something shorter.]

[Wait, [del] instead of [delete]]

[Create new scope should always be opt-in. So there should be a [do []] inside of all procedures.]

[I will probably have to figure out how to make procedures reference eachother.]

[Perhaps it should just be in [proc] that things are compiled, but everywhere. Like, every statement
is compiled first, then executed. [proc] just makes it so that every statement in the block is
compiled ahead-of-time.]

[Maybe I could take this to my advantage?]
for [][][] [
    print [Hello\n]
]
[you know, how quotes don't check if there're a space at the end?]

[What if the procedure needs the inputs as strings or to invalidate inputs depending on type? Then
you you the arguments to be assigned strings, and the procedures calls inside will manipulate those
string into the desired data.]

[I might need a macro key word that goes does process the parameters.]

syscall 4 [] [is good idea because:]
proc [] [
    syscall 4
] as [write]
write [1 [Hello, World!] 14]

[With my design, even when compiled, [1 + 2 + 3] is too instruction heavy.]
1 + 2 + 3
[is equivalent to ]
[atoi on '1', load into register x0]
[atoi on '2', load into register x1]
add x0, x0, x1
[logic for computing hash]
str x0, [memory location]
[repeat for '3']
[lots of unnecessary steps...]

[Wait]
proc [fd buf n] [
    syscall 4 [fd buf n]
] as [write]
item [str] [Hello, World!\n]
strlen str
write 1 str _
[[write] should not take a variable number of arguments.]

[Yeah, I'm not doing [+=]. Too confusing.]
+= x 2
[or]
+= [x] 2
[? Both are valid and invalid. I don't like it.]
[Well, in any case, it should be easy to define, if you insist on having it.]

[I wasn't initially interested in [defer], but after seeing an example of how [free] could have a
lot of repetition, I reconsidered it. I should try it, at least.]

[Man, I really dug myself in a hole with 64 bit unions. Now I have not way of doing [strcpy], or
whatever.]

[I guess this is a solution.]
load 1 str
stor 1 str 'c'

[I guess, it's also a [goto] vs [defer] thing. Though, people will absolutely hate [goto],
no doubt.]

[It should be the interpreter itself that assigns [_] at the end of a procedure call. The procedure
itself should not concern itself with that.]

[I should figure out how to stuff on the stack... for procedure calls and such.]

[[free] should keep track of what was freed and what wasn't. Avoid double free, basically. I mean,
[free] isn't actually a syscall, apparently. Let's take advantage of that.]
[Then again, it's also an overhead...]

[I can use the [ret] instruction to calculate the size of a procedure!]

[I suppose procedures should concern themselves with processing the tokens into data, and instead
just look at the stack?]

[I should build the disassembler in parallel to the assembler, as the code is basically the
reverse.]

[[proc-len]... hehe.]

[I could just use the args to define the header of a procedure?]
[Then, I just need to trim the header and stuff. I don't know.]

[So what if I shoot myself in the foot? I still have the other one!]

[I could probably create a capture type of mecanism with a different lookup that doesn't search
lower levels.]
[Captures to make code more pure.]

[I found a way to implement [goto] elegantly (said no one)]

[The language is like water: it can take whatever shape you want it to. And because it can take
whatever shape you want it to, you only need to change the behavior of the LSP to contain to shape
of the language. That way it can behave as if it had types, without actually having types.]

[Or not? I don't know. I will have to see when I get to implementing plugins.]

[I could maybe call the capture procedure [with]? maybe [using]? though the second doesn't sound
right.]

[I just realized how insanely difficult these error messages are going to be...]

[Yeah, I'll probably to postpone the implementation of proper errors, since when procedures actually
compile, it will probably change anyway.]

[Anyway, I had an idea: procedures should have a head, body and foot. When you chain calls in a
newly defined procedure, these things get removed. I don't know how I will implement errors with
that, but whatever. I'm going to resist metadata until it's no longer feasible.]

[This would be so much easier if I could just add metadata...]

[Right, iteresting idea as well:]
"\x1b[58;2;255;0;0m\x1b[60mcurly\x1b[0mnormal"
[instead of making my code read. But idk, couldn't make it work with printf.]

[[proc] should be a wrapping, a macro? a wrapping over something, that does define the head and foot
of a procedure, just by default, using some sort of algorithm.]

[So [proc] should be able to detect but ahead-of-time? Or the LSP? Because otherwise, everything is
runtime...]

[Maybe I should rename [quote] to [text] and [symbol] to [name]? but what about numbers?]

[prelude, interlude and epilogue? nah, I don't have to be so fancy. I'm not a haskeller.]

[My [goto]s are actually quite lame, aren't they?]

[Another reason for [meta]:]
item [a] [test]
item [b] [test]
a == b
[this works because the language knows the type and can decide whether to call it or push it on the
stack.]

[Also]
a b 1 1.4142135623
[these value should know be in the hashmap, with the key [_], they should be in the stack, back to
back. Though, I don't know how the procedure knows to access the stack. Oh wait!]
ldr x0, [sp]
[for latest? it has to be in asm otherwise you'll waste time searching the hashmap.]

[hmm]
let [a] = 5
[[let] pushes [a] in the stack, [=] upserts in the hashmap.]

[if the head of a procedure is a single instruction, it will be easy to trim. Something like [bl] to
a procedure called [push] that takes a number as arguments, and scans said number of arguments in
the source code.]

[shouldn't forget to add [proc-len] and [debug-proc].]

[at this point, why not just make it stack-oriented?]
1 2 3 4 + + + 10 == [true]
a b c d + + + [also works]

[i should really do asm instructions proc; they are stripped of the register saving instruction whem compiled]
mov x0 #5 [moves number 5 to register x0; saves register info on the stack for later use]
init-asm [saves all registers on the stack?]
quit-asm [pop all registers on the stack?]
proc [] [
    mov x0 #42
    mov x16 #1
    svc #0
] as [test-exit]
test-exit [works as intented, but no need to save registers.]

[also, inline proc that inlines stuff]
proc [] [
    inline test-exit
]
debug-proc _ [print the instructions of [test-exit] since there is no [bl]]
[still, that means that some procedures within [proc] get executed?]

[another reason to avoid meta: it encourages stack oriented programming... or is that a plus? the
stack *is* fast.]

[inline asm should be as easy as possible]

[creating a programming language is such a skill issue. meanwhile computing can write code in
binary. pathetic.]

[I need a raw [item-in] that is unaffected by [layer-offset].]

[Ah shit, it's because [repeat] does create a new scope – that's why!]

[I've been thinking a lot about loops (as you do), and isn't [goto] the simplest way of doing it? I
mean, damn. It makes me gag having to say (write) this, but recursion doesn't make that much sense
for this programming language. This... Yeah, I don't know where I'm going with this. I need to
implement the assembly first, then decide.]

[[proc] is basically a mini-compiler.]

[You know... I could actually do [str == [a string]] – and I mean why not right?]

[Maybe I should do [struct], just not the typed kind.]
struct [Car] [
    [make]
    [model]
    [year]
    [engine size]
    [price]
    [color]
    [is-electric]
]
Car::new [test-car] [
    [Tesla]
    [Model S]
    [2024]
    0.0
    79999.99
    [Red]
    1
]
print test-car.make  [outputs [Tesla]]
print test-car.model [outputs [Model S]]

[I guess [struct] defines the [Car::new] procedure? And [Car::new] does:]
item [test-car.make test-car.model ...] [Tesla] [Model S]

[And then, we have this]
test-car.delete
[which deletes all the fields. I also remembers to free the strings? I don't know.]

[or maybe]
struct [test-car] [
    [make]        [Tesla]
    [model]       [Model S]
    [year]        [2024]
    [engine size] 0.0
    [price]       79999.99
    [color]       [Red]
    [is-electric] 1
]
[which does the same as the above code]

[hmm]
struct [Vector3] [[x][y][z]]
Vector3 [test] [1 2 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[or]
struct [test] [[x] 1 [y] 2 [z] 3]
print [x = %i\n] test.x [outputs [x = 1]]
print [y = %i\n] test.y [outputs [y = 2]]
print [z = %i\n] test.z [outputs [z = 3]]

[...]
struct [Vector3] [[x][y][y]] Vector3 [test] [1 2 3]
struct [test] [[x] 1 [y] 2 [z] 3]
[the second one is clearly more terse, but that's only because this example only does it once.]

[I could do both, like:]
struct [] []
object [] []

[Alright. I'm going with this. It looks too sexy not to.]

[Oh, and I'm dropping the [::new]. Don't know why it was there. I felt right, I guess. Rust muscle
memory?]

[Also, if I am very much following the prototype-based route. No OOP here pls.]
[then again, is there any point in doing something like [Person.clone]?]
[and can I nest structure?]

struct [Vector2] [[x] [y]]
struct [Vector3] [[inner] [y]]
Vector2 [test1] [1 2]
Vector3 [test2] [
    test1
    3
]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]

[...]
struct [Vector2] [[x] [y]]
struct [Vector3] [[y]]

proc [name args] [
    get 0 args as [x]
    get 1 args as [y]
    get 2 args as [z]
    strcat name [.inner]
    Vector2-in 1 _ [x y]
    Vector3-in 1 name [z]
] as [Vector3]

Vector3 [test] [1 2 3]
print [x = %i\n] test2.inner.x [outputs [x = 1]]
print [y = %i\n] test2.inner.y [outputs [y = 2]]
print [z = %i\n] test2.z       [outputs [z = 3]]
[this is hella scuffed... doesn't even have [.delete]]

[well, I'll figure it out eventually.]

_.err?

[I guess I could also have this:]
test.meta
[which is a list of the fields?]
[and you know]
delete-struct [test]
[which iterates over [test.meta]]

[bitwise instruction disassembler?]
00100010 & 00000110 == 00000110 ? [[is mov instruction]] []
[(rough example)]

[I guess I should do the REPL in C then.]

[Maybe the max line width should be 99?]

[I need to do string manipulation before I can do the REPL. Otherwise, I will be too scuffed.]

[Damn, that's right. I can't rename [.intValue] to [.int] because C is a pain in the ass sometimes]

[Even if a procedure ends in an infinite loop, or jumps to another procedure to finish, I should
still have a [ret] instruction at the end. Otherwise, there is no way of calculating the length of
a procedure.]

[I should try implementing this thing (😂) eventually. I think it's called UTF-8?]

[Alright. So I thought about this stupid shit for a while now, and this [ioctl] thing is now really
what I want. Instead of banging my head against a wall, I'll just disable canonical mode...]
[Shit, I just found out that disabling canonical mode requires me to use [ioctl]. Well that's
embarrassing. I should probably remove this piece of text... Later. Too lazy right now.]

[I should have to do this]
1 == 1 as [b1] 2 == b && b1 ? [] []
[[b1] should have been pushed on the stack, and the result of [2 == b] as well. [&&] would have
popped them.]

[I should add the ability to memoize procedures.]

[I should, I should, I should... I should stop saying 'I should'.]

[I should write a vim like text editor, where in normal mode, the cursor hovering over a symbol
executes said proc. And when the procedure get executed, there is a cool effect with colors showing
that the code is being executed.]

[Instead of [item-in], I could do [=+]]
=    [pi] 3.14159
=+ 1 [pi] 3.14159
[whatever.]

[wait, could [_] be the stack pointer?]
[when you lookup a value, you should really be getting a pointer to it. you know [table + hash]]
[wait no.]

[Okay, so I took a shower, and thought a little: I want procedures to be compiled. If I keep
implementing features the interpreted way, it will become harder and harder to migrate; and
honestly, runtime procedure compilation is one of the main features of this language. I have to get
to it.]

[I think I'm going insane. I don't how symbol can override the outer value... And why printf not
print until a newline is shown??]

[Maybe for the editor thing, the cursor also move along. When finished, it's in position for you do
enter another command.]

[I'm adding features as I need them.]

[Jupyter notebooks?]

[Just as there is a [push arg-count], there's also a [pop size] that pops the stack for a value of
a defined size, and assigns it to [_].]

[Damn, I don't know how to add things to the stack with all these function calls...]
[I need to think.]

[This may be a long shot, but I thing I need to rewrite the whole thing in assembly... Wait no, I
can just use -S!]

[Okay... I have to spend a long time trying to understand and trim the assembly code.]

[Dear lord... This is so hard. The more I think about it, the more difficult it seems to be...]

[You know what? One problem at a time. I'll start by figuring out how to read a file and then print
it.]

[I won't be getting very far without knowing how define malloc and free...]

[I'm going to do assembly in the new directory I created, but I will also do the interpreted
version. Instead of using the actually stack, though, I will create my own. If I don't do that...
My progress may lag too hard...]

[A lot of procedure have optional arguments?]
compile main
compile: [executable-type mach-o] main
[or]
item [args] [executable-type mach-o]
compile: args main

[heh.]
1u64  [x16]
42u64 [x0]
4 + syscall _
[skip [push n]]

[I guess I don't really need a distinction between [i64] and [u64]?]

[Shit, I was talking about push n and stuff, but how do I do this??]
syscall 1 [0]
[I guess I just put the pointer on the stack, and inside the [syscall] procedure, I'm extracting
the info... But that had to be at runtime. Otherwise it will be too slow.]

[[syscall] should be a macro for inline asm.]
mov x0,  0
mov x16, 1
svc 0
[^ too short for a procedure call.]

[I have to actually think about numbers.]
FFF:x
1011_0010:b
0o777:o
543:d

2134:1
2134:2
2134:4
2134:8

.2134:4
2134.4:8
[Okay. I think that's good.]

[also]
255:1 == -1:1

[it kind of looks like a ratio... anyway, I like how it throws the syntax of other languages like
rust on their head:]
let n: u8 = 42;
item [n] 42:1

[Maybe I should also allow this:]
item '[' [...]
[I don't know... exactly how I'll implement this, but it sounds like a fun idea.]
[I can even do this!]
item ' ' [...]
[Muahahahaha!]

[[defer] should execute in the opposite order.]
[Maybe have a fraction struct?]
[I need [parse] to be more reliable.]

[I could do this:]
item [env.next] [print "New code\n"]
[So when EOF is reached, the app continues.]

ch [filetype mach-o]
compile: _ [print "Hello, World!\n"]

[I feel like I can just do arbitrary precision.]
item [x] 198412847120581251251209851281204981240912840192812057250129851029812308123409128
[can't I just divide this into multiple longs?]

[I should use i32 for default int, and f64 for default float, like rust.]
[I need to make my code libc independant...]

return 5 _

[Is there a way to make a syscall macro in C?]

proc [vector] [
    Vector3.y vector
    print "y = %i\n" _
]
[or maybe I just can't pass an struct to a proc?]
[or maybe i don't need structs, just arrays?]
[array programming?]

[btw]
print [Hello, World!\n]
print "Hello, World!\n"

item '"' [...]

get-at x 4 vec1

[The stack is increasingly more difficult without [meta].]
[These vrariable length types are impossible to work with...]
[I either do meta or things i push on the stack are the same length.]
[Maybe low level should be more stack oriented, while high level uses the hashmap?]

[Also, easy way to convert from one base to another.]
print "%i\n" FFF:x

[I should learn learn "vfprintf" and "strtox"]

[Inline asm should only be doable in a "do" block, or similar, like in a procedure.]
do [
    mov x0,  0
    mov x16, 1
    svc 0
]
[^ this works because the block is first compiled, then executed as binary.]
[while this doesn't:]
mov x0,  0
mov x16, 1
svc 0
[because the registers are messed around with before each procedure call.]

[sure, you could ldp every register before the call, and stp after, but that's such ugly solution
to the problem... just use a do proc at the top level. In a procedure, you don't need since
everything is compiled first.]

[Actually, stack-oriented programming may not be possible...]
1 == ret as [b1] 2 == ret && b1 ? [] []
[for this to work, it would need to not take any arguments...]
1 == ret 2 == ret && ? [] []

[The logical way to approach this, would be to convert the symbol to the pointers or values in the
hashtable.]
[But then I would be using the heap an awful lot...]
[That's probably it, for now. I need to focus on compiling, anything.]

[You know, everything was smooth sailing until I tried to compile. I made so much progress...]

[I wonder if you could implement significant whitespace using this:]
item ' ' [...]
[Just to be unnecessarily evil.]

[also]
proc [str1 str2] [
    print str1
    print str2
    print str1
    print str2
]
_ [Hello, ] [World!\n]
[it would be easy to malloc these strings, but they will on be used in this procedure...]
[wait...]
_ str1 str2
[so they should be pointers??]

[The ideal would be to neither put them on the stack, nor malloc them. I mean, they are already
loaded in memory: "token[start]"!]
[In other words, I should change print to not be null terminator dependant. At least for string
literals.]

[Then again... (I keep going back and forth) I guess I could also insert the string within the
procedure... Because, I mean, what if you have a procedure that returns a procedure? And the scope
of the procedure call gets popped? I need to make my procedures as portable as possible! And in any
case, I plan to make every part of my binary either executable/readable or writable/readable. Or
not? Maybe I should have the minimum? Whatever, later.]

[Okay, but about this?]
_ [Hello, ] [World!\n]
[where are the strings?]
[how should I always write a fixed number?]
[the [write] syscall doesn't check for the null terminator anyway. and I will need to length then.]
[In that case, I only need to push the pointer to the start of the quote on the stack?]

[Maybe I should data after [ret]?]
[If i don't put the string after [ret], i will have to [b]...]
[But how will I now to compile the data as well when compiling to an executable file?]
[Decisions, decisions.]

[Wait, if I malloc something, then mmap it, then free it, will it still be mmap-ed?..]

[Maybe I could push stuff on the stack, and then when I compile, I put the stack in a readonly
section?]

[Holy shit!]
label [n]
[is equivalent to]
adr x0, 0
[... I think.]
str x0, [x29]
add x29, 8
br x0
[hmm, needs testing]

[I shouldn't forget the idea that procedures never return, instead they call eval on the next
statement.]

[Really like this syntax.]
0 ~ print [%i\n] _

item ' ' end++
[I'm so funny aren't I?]

[prepend on item names?]
module [hello]
item [x] [Hello, World!\n]
[for other module]
hello.x
[this is really just string concatenations:]
module-name ++ "." ++ item-name
[something like that]

[Some instruction parse the arguments, then put on the instructions on the stack, others parse
arguments, evaluate them, then put the result on the stack. The former are procedures, the latter
are macros.]
[There really shouldn't be any syntactic difference between the two...]

[hmm]
1 == ret 2 == ret pop && _ ? [] []

[runtime compilation (lol)]

[The LSP throws an error when you're about to call a non-executable part of memory. The program
still runs though.]
[Do you bootstrap the LSP as well?]

do [
    proc [] [
        print "hello"
    ]
    defer [free _]
    _
]
[but you can't do that, because you're using mmap for this...]
[i should try implementing it anyway. some way or another.]

[Need macro push and pop]
push(int, value);
pop(int);

[I don't think I need [adrp] for c. I can trim it. Or maybe it's already trimed?]
[I should test [adrp] with inline in c.]
[[adrp] will be such a pain in the to deal with...]
[like how many bits is printf %x ptr?]

[The interpreter should avoid [malloc] as much as possible.]
[I'm still amazed I'm writing a lisp without really knowing lisp.]
[...]

[I could just chain procedures and never assign the first one, in the top scope, for lambdas; [as]
within second proc.]
[Maybe the next push pushes to _, but before that pushes whatever _ had to the stack?]
[I'm thinking I really need to consider a size value attached to a variable...]
[Maybe I don't need ''.]
item [c] [Q]
[what if [c] is a pointer where token[start] == 'Q'?]
[maybe i don't need to malloc a new scope (it would make error messages so much easier if yes]

[In the asm interpreter, I could just store globals in the stack and access them whenever I want,
but for the C interpreter, I need a weird workaround.]
item [str] [Hello, World!]
do [
    ch str & 0xFFF
    movz x1 [_ 0]
    ch str >> 12 & 0xFFF
    movk x1 [_ 1]
    ch str >> 24 & 0xFFF
    movk x1 [_ 2]
]
[something like this?]
[but I need to change the notation...]

[hmm]
mov x0 3
bl PUSH
[is equivalent to]
mov x0, arg1
mov x1, arg2
mov x2, arg3
[?]
[so]
mov x0 3
bl PUSH
svc 0
[is all you need?]

[okay, what is the notation?]
mov [1] [3]
[move x3 into x1?]
mov [0] 77
[move #77 into x0?]
mov [0] [77 1]
[move #77 << #16 into x0]
mov r v
[move value with possible shift pointed to by symbol [v] into register pointed to by symbol [r]]
mov r [v s]
[move value [v] with shift [s] into register [r], each pointed to by symbol]
[i guess this works]

[i still have no idea how I will do arguments...]

[I could also do]
item [x0] [0]
item [x1] [1]
[you know, to make it more like actual asm]

[wait]
mov [0] [[1] 1]
[i guess that works]

[I think I'm giving myself too much of a headache. A lot of these are aliases. movz will never move
from one register to another.]
[In other words, I can just use integers as inputs.]

[There's a variable called this.]
print this [prints the entire code of the first file.]
item [this] [] [does nothing]
item-in 1 [this] [] [breaks the program, because the source code got deleted]

[oops, just remembered there is w0 and x0.]
[maybe]
movz 0:4 2
[?]

[wtf, why do you need w0? you're moving a halfword??]

[Maybe I should always use exponential sizes?]
1:0 [char ]
1:1 [short]
1:2 [int  ]
1:3 [long ]
[2 ^ x * 8 = number of bits]

[i shouldn't forget about this]
printf("%.5s\n", str);

proc! [] []
[instead of]
macro [] []
[? well, it's the same length so whatever.]

[There should probably be a register reserved for the [token] value.]

[Also, nvm for "", I need to be better than this.]
print "Hello, World!\n"
[...]

[wait a second]
[a] = 2
[I can do this because the quote is ignored, and [=] can backtrack... but do I want to? probably
not.]

[Okay.]
proc [text len] [
    write 1 text len
]
proc [fd buf nbytes] [
    movr 9 0

    ldr 0 9   [fd]
    sub 9 9 8
    ldr 1 9   [buf]
    sub 9 9 8
    ldr 2 9   [nbytes]

    movz 0 fd
    movz 1 text
    movz 2 len
    movz 16 4
    svc 0
]
[or [ldr] with offset. idk]

[Do you like driving without a seatbelt? Do you like being a menace to society? Well this is the
language for you! No rules. The only limit is your imagination, and your ability to avoid law
enforcement...]

[maybe I should have a stack for executables?]

[pop]
0 < val 65535 > val . && _
0 val < 65535 val > &&
[it's either [^] or [.] or whatever else]

proc [] [
    0xf9400508
]

[need a [debug-stack] procedure.]

[I can actually implement dependent types... I mean, I just learned zig has them with comptime
right? Like damn.]

[Then again, maybe I want more than that? Because some search algorithms need sorted list as input,
but what, I need to check whether the list is sorted everytime? If it's a runtime check, it becomes
expensive real quick... Since there is no way to attach the fact that list is ordered onto a
symbol, I can't prove that a procedure will always work. Not without types.]

[Also, I really like the fact that you can write proofs with dependent types. It's so fucking
cool!]

[Then again... 'Ordered' could just be a wrapping over a List. You can't pass a List instead of an
Ordered argument, but you can pass an Ordered to a List... I guess List is the wrapping here.]

[Honestly, I will probably implement [meta]. Doing [get-at pos size from] is too long. But again,
I'm going to try to make as far without it as possible. I need to see what it looks like.]

[Alright, suppose I do have to implement types:]
item [x] 12
typeof x print [%s\n] _ [outputs [Number]]
type [Number] [u8 u16 u32 u64 i8 i16 i32 i64]

[but how do you express fixed size lists?]
array [x] [1 2 3]
typeof x print [%s] x [outputs [Array Number 3]]

[So I guess]
x == [
    [value] [1 2 3]
    [type] [Array Number 3]
]
[[type] doesn't have to be a string. It can be pointers to strings, and depending (lol) on the
pointer, the size of [type] can vary. But how do I know which types take in arguments?]

[wait]
type [Array inner-type length] [Array inner-type length]
[it seems redundant, though.]

[but then you have to say everytime a procedure uses IO and stuff...]
[and what happened to this]
u32 [x] 11

[A big reason to have types, that it makes operating on fractions so much easier.]

[Need to think about this.]
[So, in [proc], the procedures have something like [reduce] called on them, and the instructions
are pushed on the stack without being evaluated. On the top-level, they are pushed as well, but
popped and evaluated afterwards. Okay. But what instructions are pushed on the stack? If you define
[write] for example, the instructions that are pushed on the instructions pushed on the stack are
the instructions  for taking arguments, and then pushing instruction again with thoses arguments
hardcoded to push on the stack as well. So when [write] has taken arguments, you now have a
procedure that pushes the same thing on the stack everytime, and you can evaluate thoses
instructions or insert them inside another procedure. Because you can insert them inside another
procedure, you can't just push the data at the end of the procedure (after ret). You need to
hardcode it as mov instructions or mix code with data, do a ldr offset from pc where you put some
data, then jump the data with a branch instruction... This is going to be hard to implement. Not
just for [write] but for everything.]

[Okay. I wrote a lot.]

[You know, it's a little funny to think about safety in a language that, a its core, is more unsafe
than [strcpy].]

[If I do something like Elm, I will probably remove h1, h2, etc. And just have text... Then again,
accessibility and all that...]

[Depending on the types, a procedure can have a different number arguments?]
[Types should really be string, a least at first.]

[Functional programming is, to my dismay, seeming more and more appealing.]
&& < 0 val > 65535 val          [functional]
0 < val as [b] 65525 > val && b [current model]
0 < val 65535 > val . && _      [current with pop]
0 val < 65535 val > &&          [stack oriented]
[functional and stack oriented are the clear winners here]

[I understand that I want to make this programming low-level and such, but some things are
objectively better than others. Once I finish implementing a working procedural model, I will try
types, then funcitonnal, and compare the implementations.]

swap str + 1 str

[Another good reason to have types: errors are so much easier to do.]

[The language has to be built from the ground up with [x] feature, otherwise a plugin would be too
awkward.]

[Should I make it so that it only compile after the first use? That might solve the recursion
issue.]

[In functional, I could use [_] as a discard:]
_ write 1 [Hello, World!] 13
[write doesn't return anything this way.]

[Division by zero should equal zero, like in [Gleam]]

[Maybe I can do everything lazy, and where it only compiles when function is called?]
item [f] [print [Hello, World!\n]]
print [%s\n] f [outputs [print [Hello, World!\n]]]
[Of course, [item] does not malloc the string like before. It only get a pointer to the start of it
(token + start).]

item [f2] [f f]
print [%s\n] f2 [outputs [f f]]

[but]
f2 [will compile [f f] and therefore [print [Hello, World!\n]] as well]

[also, when printing a function, you won't just be getting the function body. you still need to do
the argument logic, and all that.]
[and let's not forget]
func [f x] x
[is equivalent to]
item [f] fn [x] x

[still, that means that everything starts of lazy?? this might not work, since we need intrinsics
to define the rest... damn, thought I figured it out for a second there!]
[maybe recursion will forever be off the table...]

(define [f x] [
    print [Hello, World!\n]
])
[maybe I should just give up and do it like this... seems cleaner at this point.]

(print [hey])

[wait, what about function with not arguments?]
(if (< 4 10)
    [f1]
    [(f2)]
)
[i suppose that works.]

(define [f x] [(
    print [Hello, World!\n]
)])
[lol, this is worse than lisp.]

[no, a thing I really like about my language is that I can [scan-token] and [copy-token] and
[parse] or none of the above, without any reservation about what actual arguments the caller gave
you. in lisp, you're pretty much forced to take the arguments within parentheses. it's a tradeoff
with its merits and demerits, but I prefer it.]

[Suppose I implement the functional style, variables should also be functions with no arguments,
that always push the same value on the stack.]
item [f] lambda [x] [print x]
func [f x] [print x]
[ah, that brings back memories. right, if I do this]
item [str] [Hello, World!\n]
[how do I know that it's a string or function?]
[and so one of the big reason to have functional style is thrown away just like that.]

[i guess i could be more lispy?]
define x 5
define [f] 5
print x [outputs 5]
print f [outputs 0xffffffff (pointer to function)]
[wait, how do you call?]
print (f) [outputs 5]
[hmm, so like the outer scope doesn't need a parentheses?]

print f [outputs 5]
print ptr [f] [outputs (pointer to 'f')]

[wait]
(define [f x] [
    print [Hello, World!\n]
])
(f 5) [outputs [Hello, World!\n]]
f [outputs [print [Hello, World!\n]]]
[but how would that work?]

[no]
(define str [Hello, World!\n])
(define [f x] [eval x])
(print str) [outputs [Hello, World!\n]]
(f [print str])
[I have no idea.]

[I don't even know why I'm exploring this shit... Man, it was so much easier when I was just interpreting.]

[Maybe I could invert it?]
define str [Hello, World!\n]
define [f x] [eval x]
print (str) [outputs [Hello, World!\n]]
f [print str]
[somehow, that's kind of nice?]
[although]
print $str [outputs [Hello, World!\n]]
[no reason to use parentheses when it's not a list]

[or]
define str [Hello, World!\n]
define [f x] [eval x]
print str [outputs [Hello, World!\n]]
f [print str]
print ptr [f]
[every symbol is a function]

[I like how I'm basically pushing the problem from one place to another.]

[parentheses will never be an option, because they will always be more verbose than procedural,
losing the motivation to go for a functional style.]

[The only serious alternative is]
print + 1 2
print ptr [+]
[against]
1 + 2 print _
print +
[I see. Procedural can be much shorter.]

[The really beautiful thing about procedural is how you don't need an AST; everything is just
text.]
[But also, how you can actually implement functional in procedural.]
[I feel like implementing procedural in functional would be a pain though.]

[maybe]
func [] []
proc [] []
[each parsing arguments in different ways?]
[but the inconsistency could drive you mad...]
[but it's similar to [macro] too?]
[...]

[no, [func] requires type metadata; [proc] does not.]
[or rather, the way variables work would have to change for the two, and the only way to make the
behavior consistent is to have metadata on variables.]

[In the long run, functional may be more useful. And I also, need types. The key thing is to still
use the procedural model, but parse stuff differently. I want [scan-token] and the gang.]

item [x] [hello]
item [x] fn [] []

[I guess [fn] does compile, but only partially, and it compile the instructions to compile the rest
of itself?]

[but then again...]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[one is longer, sure, but it makes more sense.]
[the other is simply not text based.]

[for god's sake! this is such an impossible problem!]

[another reason not to fully compile everytime, is faster runtime. otherwise, you would have to
compile every imports everytime you run the app. this makes it so you only compile the things you
actually use.]

[Is recursion even possible without types? How can you tell it's the end of an array?]

[I should create an actual lisp]
[Probably built on top of python this time. See how far I can get.]

[I should probably put the compilation on hold so that I can implement the rest of the language, so
that I can then objdump the assembly and have a better idea of what to do. Also, I need to avoid
using the standard library.]

[Just had an idea:]
rand-proc-call as [val err]
[so like, instead of having [rand-proc-call] define variables that could clash with the lower
scope, we just put the stuff on the stack, and [as] can assign multiple values from the stack.]

[I should try to do C structs without [struct].]

[I should try something like [do-set]:]
proc [] []
[here [_] is know a pointer to an executable part of memory that will call [do-set] on the start of
the procedure block, compile it and reassign [_] the compiled code.]

malloc Vector3
[[Vector3] is the size of the structure.]
[wait no]
malloc Vector3.size
Vector3 [1 2 3]

[Functional may make more sense.]
func [x] [print x] [input]
proc [x] [print x] _ [input]
[like what? does procedure assign [_] as well? Was it not supposed to be in the stack?]
[no, this is small]
proc [x] [print x] as [_] _ [input]
[or]
proc [x] [print x] . _ [input]
[as always, very verbose.]
[still I need return values to be on the stack as that is so much easier to work with for multiple return.]
[or maybe]
proc [x] [print x] ; _ [input]
[I kind of like it?]

extract [_ err] sp
[similar to [as] but takes pointer?]

[when I do the documentation, I really need it to start with:]
exec 16 [very-long-hex]
[which of course prints [Hello, World!\n]]

[maybe meta is just a long, but that long can be anything, and the procedure decides?]
[[size], [meta] and [value]:
if [meta] is 0, then the symbol is an int, float, or whatever;
if != 0, then it's a pointer to something and meta is size of [something]]

[no, int for size and int for meta, to 64 bit total]

[i should implement a meta circular evaluator.]
[just to remind myself why I created this language,
fix in lisp: right-to-left, parentheses, abstraction, nesting]

[i need to list what types to implement, and features those types allow.]
[like every variable has metadata to improve errors, and a size for the value, and a nullable size
for referenced memory, with maybe whether or not that memory is executable?]

declare [val1] [int]
declare [val2] [Array int]
[i don't know.]

[the reason no one made this language is because of how unsafe it is...]
[i think i read somewhere that mmap allocates an intire page every time? in other words: it's
extremely inefficient...]

[There's a sort of shit to my language, that wasn't there when it was just interpreted.]
proc [] [
    1 + 1 ;
    print [%i\n] _
]
[how the fuck do I translate this to machine code, and how the fuck do I remove the need for
symbols? like what, I lookup a hashtable in compiled/optimized code? I need to be better than
this.]

[Maybe I should drop the hashtable? I mean, the only reason I use it is because chatGPT said it's
typical? But then [malloc] is bad. Also, I now have the stack and want to use it to put values in
it.]

[Also, I really need to learn the io programming language. I'm really thinking objects to the
language, because with types, it's just a waste not to have objects. And we can have stuff like
this:]
object [String] [
    [ptr] 0
    [len] 0
]
new String [str] [[Hello, World!\n] 14]
[... so awkward. need to think this through. Also, still not set in stone that I will use types and
objects. I will resist it till the end!]

[I can't continue programming until I figure this out:]
proc [] [] _
[vs]
proc [] [] ; _

[wait a second...]
proc [] [
    ch [hello\n]
    print _
]
[this isn't a hard problem? ... I just do as normal, but when it actually compiles, [print]
compiles, it doesn't compile with [_], but with the absolute value that of [_]. Am I for real? Is
it really that easy? Am I missing something?...]

[Also,]
proc [] [] _
proc [] [] as [val err]
[are both valid?]
[wait, no. [proc] needs to have a call that assign [_] at the end. like [return] or something.]

[I suppose [ch] does not compile, but is already compiled? That's why I don't have to worry about
it?]
[Still, that means that [push] needs to work differently...]

[If I do modal programming, I could do it where things are both pushed on the stack and on the
hashmap? I call the same procedure, but the procedure behave differently depending on the global
state.]

[Also, I feel like I can still do currying. Everytime I take an argument, I push something on the
stack, and stuff, except the thing that I pushed is a procedure that take the remaining arguments,
and then returns the actual body of the procedure.]

[Types, types, types!]
my-list to-iter
[make like rust iterables? [.next] I mean. And more importantly, lazy and infinite.]
0 -1 iter [is an infinite data structure?]
map [x] [x * x]

proc [] [type _ == [Vec 8] ? [logic] [Iter]] as [a-way-to-do-overloading]

[The two most basic types are Code and Data. All other types are derived?]

fork ? [] [
    print [Hello, Async!\n]
    exit 0
]

[Reference type]
item [str1] [hello]
item [str2] [hello]
str1 == str2 [true]

ref str1 as [str1]
ref str2 as [str2]
str1 != str2 [true]

[Everytype is by value by default?]
[Like, we have arbitrary sized integers, but with strings too. Strings are just very, very long
integers. So they should behave the same.]

[I should find a way to do a hashmap without malloc... Or just put everything on the stack?]
Variable :: {
    name : String
    type : String
    size : i32
    value: Any
}
[I don't know...]

struct [Variable] [
    name String
    type String
    size Number
    value Any
]
[Type could also just be [Structure]]
[I guess [item] should then push this on the stack?]
[Also, how do lookup in the outer scope? Also also, I guess I can't do [item-in] any more...]
[No, the first variable of a scope is basically just metadata about the outer scope.]
[Wait, I don't even need [item-in]! When the scope is gone, all my variables are still there! I
just write over them, or be clever and write them where they should've been to begin with!!]

[Okay. This is one of the most interesting ideas I've had in a while.]
[I don't even think it's that much slower than a hashmap, despite being linear and stuff.]

[But happens here?]
1 + 1 dbg
[is [name] equal to null?]

[Also, an [env] could just be another variable on the stack, except its size is the size of every
other variable combined?]

a = 2 [is possible because] push a [is equal to]
Variable [a] [Undefined] 0 []
[or something like that]
[and then, we simply reassign the value to 2.]

[also, when we lookup the stack, we go from the of the stack.]
[Damn! Just realized how easy looking up into multiple environments is with this model! Damn I'm smart!]
[Also, if there is a [stack] variable, it is in the bottom of the stack everytime.]
[Also also, shadowing.]

[Honestly, it's probably nowhere near as fast as a hashmap... thinking about it for real, the
bigger the application (and they get pretty big), the slower it will get, exponentially.]

[Still, unlike a hashmap, I can define variable length values – scrath that. In a hashmap, I can do
it as well.]
[Wait, what about pushing pointer to the procedure you will use a lot in the start of a scope...]
[No no no. Before that, isn't it the job of the programmer to ensure that the stack has no bloat
that make the linear search take forever?]
[Even before that! Procedures are compiled to begin with, so it should take that long?]
[... Or maybe I should have multiple stacks?]

4
[==]
Variable [_] [Number] 3 4

[[Mutable] and [Immutable] types?]

[Maybe [import] is a procedure that returns variables on the stack?]

[If the language become so stack centric, should everything be a function that return their value
to the stack? Even variables?]
[^ Functional refuses to die.]

i32 [name] 1
[is equivalent to]
Integer [name] 2 1
[where 2 is the size]

[don't forget]
malloc(typeof(Entry) + entry.size)
[or something like that.]

eval fn [] []
[maybe [_] is latest stack variable?]
[damn, don't even need [return]]

[since every variable has a type, you don't need to "call" a variable. but the syntax makes it look
like you do.]

[both item and as work for declaring a function]
let [f] fn [] []
fn [] [] as [f]

[discard]
let [] func-call

[[eval] is called on the arguments of a function...]
[I should give crafting interpreters another chance. The type system is a real pain in the bum.]

[overloading]
fn [arg1] [
    string? arg1 ? [stuff] [
        throw [Unsupported type: %] type arg1
    ]
] as [overload]
fn [arg1] [
    number? arg1 ? [stuff] [
        overload arg1
    ]
] as [overload]

[I don't even need [item-in]...]
[type [Struct Vector]?]
[objects and templates? or prototypes?]
[but a prototype is just another object...]

item [val] do [1 2] as [val2]
item [val] do [1 2] next [val]

[maybe every variable should have a padding, to allow for arbitrary sized values?]
[you can call clone on any object?]

[damn, i can do] var . proto . type
value size [where [size] is just another overloaded function that check the type of the value in the stack?]

[this just doesn't work]
a == b || b == c

sqrt 9 [returns special type? like an [Or] type that means the value can be any of the list]

[has to be + a b for constexpr]
let [VALUE] + + 1 2 + 3 4

[interesting: using this model, there is no mutation from inner to out block...]
[or not? how do I do globals?]
[maybe I should let and set like other programming languages?]

[oh shit i can do static methods...]
Object [
    [name] [test-object]
    [func] fn [] [
        print [This works!\n]
    ]
]

[eveything is not a function, but everything behaves like one, syntaxically]
[everything is a "function", including types]
[I should do [functions.c]]

[Maybe there shouldn't be a distinction between code and data... You're gonna have to call a
function anyway, to push the data on the stack and stuff...]
[memcpy and stuff.]
[everything behaving like a function but not really being one could be the best way to implement
lambda calculus on a computer...]

[I may be giving up on [proc] too quickly. I feel typeless is pretty much dead now, tough.]
[Still it is a fact that procedural made me agonize over a few things. – Honestly, I should be more
open to experiment with shit, even if it's not going to bear any fruit.]

let [ret] func-call
ret match
    [Some a] [print a]
    [None  ] [throw [Failed to unwrap monad.]]

length list
clone vec

[Initially, I wanted functional. I should try it. If it doesn't work, then too bad.]

let [C] import [libc]
let [main] fn [] [
    let [a b] i32 3 i32 4
    let [result] C.add a b
    print [% + % = %\n] a b result
]

let [true ] fn [x y] [x]
let [false] fn [x y] [y]

[I should have a function that takes piece of code and debugs it step-by-step]
debug [
    print [Hello, World!\n]
]
[Similar to a GDB or LLDB breakpoint, it halt the execution of your code to enter a TUI debugger
for the requested piece of code.]

let [func] []
do [
    set [func] fn [] []
    defer [munmap ptr-to [func]]

    [fine]
    func
]
[will segfault]
func

[do I really need fexpr?]
[I mean, I just need to pass in a string to a normal function. No... Every function is an fexpr
(or macro) by default; they just choose to always evaluate the arguments. And you can still use
[macro], but it's like really deep in the language, and not idiomatic, I guess.]

let [c] char [🤓]
             [  ]

let [a] 123
let a = 123;

let [a] i32 123
let a: i32 = 123;

let [io] import [System/IO]
io.print [Hello, ]
use import [System/IO]
print [World!\n]
use [
    import [System/String]
    import [System/Syscall]
]
import [System/String] as [text]
print text.reverse [Hello, World!\n]

[I should probably make it so that everything in the language follow this form:]
let [symbol] [something]
[like this]
let [number] 4
let [string] [Hello, World!\n]
let [function] fn [] [
    print string
]
let [person] Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
let [person2] clone person
let [person2.name] [Jane Doe]

[also, I just had a brilliant idea for objects:]
let [sys] import [System]
[is problematic because [import] returns an object, and how is [sys.something] defined then? Well,
[let] manages that. It checks if the value of the assignement is some sort of object, and if yes,
does seperate assignements for all the fields. Clever, right? Right??]

[wait a second.]
let [] import [System/IO]
.print [Hello, World!\n]
[right?]
[no, it shouldn't work like that...]

[Maybe take the zig route?]
let [std] import [std]
let [print] std.debug.print

[Still, I wanted [import] to work a bit like [load]]
let [lib] load [lib.txt]
let [sys] import [System/]
[or something like that]

let [Vector3] fn [x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [vector] Vector3 1 2 3
println vector.x

[I should try to implement dependent types, since this language already blurs the lines between
compile-time and runtime. Also, it's a good way to learn.]

[By the way, this language probably won't have any tuples, since those are basically just
structures.]
let [tpl] tuple [1 [Hello, World!\n] 1/3 Vector3 1 2 3]
let [tpl] Object [
    [0] 1
    [1] [Hello, World!\n]
    [2] 1/3
    [3] Vector3 1 2 3
]
println tpl.1 [outputs [Hello, World!\n]]
[then again... they are objects, but [tuple] could just be a shorthand (macro or function) to avoid
naming things inside the object]

[Also, enums]
let [] enum [
    [Monday]
    [Tuesday]
    [Wednesday]
]
println .Monday [outputs 0]
[I guess this is similar to a tuple. That is to say that it's just some macro for shorter object
initialization.]

[People talking about arbitrary compile-time execution; I talk about arbitrary runtime compilation.]

let [func] fn [] []
let [func] ptr-to [func]
let [func] val-of [func]
func [works]

print type-of Object [
    [name] [John Smith]
    [date-of-birth] Date [4-7-1969]
]
[will output:]
[Object [
    [name] [String 10]
    [date-of-birth] [Date]
]]
[or something like that]

[I should do Elm style, that also compile to html/css/javascript]

let [n] 10
let [test-fn] fn [n] [
    while -- [n] [
        println n
        n
    ]
]
let [factorial] fn [n] [
    as [arg1 arg2]
    while != arg1 n [
        * arg1 arg2 as [arg1 arg2]
    ]
]
test-fn n
factorial n

[hmm.]
[maybe everything should be an S-expression...]
let [test] ? condition [
    do-something
] [do-nothing]
[yeah, this code is impossible with the old model.]

let [condition] or = 1 2 ≠ 2 2

[Maybe I should just use a VM. The only difference is that the vm is for arm64 assembly?]
[Man, I wouldn't have this headache if the OS just allowed me to make things for writable and
executable.]

ls | sort-by [size] | reverse
[is there a way to implement this?]
[maybe I should reconsider the very first approach]
reverse sort-by ls [size]
ls push [size] sort-by reverse
[no, if I wanted multiple return values, I can't]
let [value1 value2]
    reverse sort-by ls [size]
    where ls [> size 1kb]

[maybe it's just a macro?]
ls | sort-by [size] | reverse
[is equivalent to]
ls ; sort-by _ [size] ; reverse _

[Maybe there is a stack type and a heap type?]

[Pattern matching?]
if let [value] dup func-call [
    debug value
]
[[dup] for duplicate... or should I overload [clone]?]

[[mut] instead of [set]?]
[because [set] was paired with [get] for array assignment and retrieval.]
[or [set] could just be overloaded.]

2.0
let [number] print [number: ]
println number [outputs [number: 2.0]]

[I guess floats should have a precision field so it actually prints [2.0] and not [2.000000]]

clone value
length value

[I forgot: modal programming!]
ls | reverse
[[ls] pushes an array of characters onto the stack. [|] changes the mode to [Piped]. [reverse]
looks at the mode first before executing.]
[Then again, maybe every type can become piped?]

let [_] last-stack-item
[special type?]

[[=] vs [==]]
[value vs reference]
let [str1] [test]
let [str2] [test]
println =  str1 str2 [outputs [false]]
println == str1 str2 [outputs [true]]

printl [vs] println [?]

[Oh mother fucking shit!]
compile opt [
    [filename] [Terminal]
    [filetype] [ELF]
] [main]
[^ an [Options] type!]

[I will probably still have a [return] function.]
let [print-unsigned] fn [number] [
    if < number 0 [
        return Error [Number too small.]
    ] []
    printl number
    return []
]
let [e] print-unsigned -1
if != e [] [
    throw e
] []

0 ~ print [%i\n] _
0 ~ print [%\n] _
print [%\n] ~ 0
print ~ 0

if condition [
    func-call 1
] [
    func-call 2
]

print 1 \n
let [\n] fn [] [
    print [\n]
]

print [\%] [outputs [%]]

[zig is great, yeah, but I feel like I want this language to take more after jai]
let [items] Array [
    ptr-to [print]
    ptr-to [let]
    ptr-to [\n]
    ptr-to [ptr-to]
    ptr-to [Object]
]
for items [print it \n]

[hmmm, [[]] made sense before, when I had [item-in] for return values, but now, not so much.]
let a 2
let str [Hello]
let [push-str] [[ world]]

[become more lispy by the second. wait till I add this revolutionnary feature called
((("parentheses")))]

[lispy formatting]
let [render] [
    fill-rect proj-rect proj-x proj-y
              unpack-color PROJ-COLOR
    fill-rect bar-rect
              unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
           fill-rect target-rect it
                     unpack-color TARGET-COLOR] []]
]

[this might be better; more consistent with the [for] loop's format]
let [render] [
    fill-rect proj-rect proj-x proj-y
        unpack-color PROJ-COLOR
    fill-rect bar-rect
        unpack-color BAR-COLOR
    for targets-pool [
        if ! it.dead [
            fill-rect target-rect it
                unpack-color TARGET-COLOR
        ] []
    ]
]

[or all in one line; but hard to read]
let [render] [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool [if ! it.dead [fill-rect target-rect it unpack-color TARGET-COLOR] []]
]

[I suppose lispy formatting will eventually grow on me, like vertical alignement, but right it's
either the second format or all in one line. For all in one line, I could just assign to a variable
if it gets too long. I believe this is the pythonic way of doing this.]

[Also, I don't have to worry about readability like before, since with the new type system, syntax
highlighting will be much better, probably.]

let [func] [
    func1 func2 func4
                func5
          func3 func6
                func7
]

let [func] [
    func1 func2 func4
            func5
        func3 func6
            func7
]
[yeah... the second one is hella ambiguous.]
[as ugly as it looks, the first one is objectively better.]

[no, if I multi-line a function call, I do it the C way.]
func-call
    func-call
    variable
    func-call

func-call(
    func-call(),
    variable,
    func-call(),
);

[The formatting problems only occur when I push the first argument on the same as the function
call. If I don't do that, then all is good.]

[[dup] vs [clone]]
[dup: pushes a copy of the value attached directly to the symbol; like numbers, floats, and
pointers.]
[clone: clone value being referenced by symbol; like Arrays, Objects, Strings, and things pointed
to by pointers.]

[another reason to do it like this]
let a 2
++ a

[what about reassigning [let] and [++]?]
[I suppose I just have to not use them for the reassignment? Like how [let] and [++] where
initially assigned?]

[It's basically recursion vs easy overloading...]
[But the minmax algorithm is a pain in the ass without recursion...]

[The same way a function gets called when [do] is called with it as an argument, should an [Object]
expand to just the fields?]
fn [x] [print x \n] [Hello, World!] [outputs [Hello, World!\n]]
Object [func fn [] [print [Hello, Again!\n]]]
func [outputs [Hello, Again!\n]]

[Wait, this may be a way to do multiple assignment?]
Object [
    [var1] 1
    [var2] 2
    [var3] 3
    [var4] 4
]
print var2 [outputs [2]]
[Interesting. I should consider it seriously.]
[Granted, you can no longer do this:]
fn [] [] as [func]
[But so what? You're not supposed to anyway.]

import [System/IO]
print [Hello, World!\n]
let [io] import [System/IO]
io.print [Hello, Again!\n]

[holy fuck, I don't even have to use [use]!]
let [func obj] [
    print obj.var-within-obj
    obj
    print val-within-obj
]

[Damn, nevermind. There's a discrepancy between returning an object and exposing it's fields.]
let [func obj] [
    print obj.var-within-obj
    use obj
    print val-within-obj
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[There also another problem...]
let [arguments] [
    1 2 3
]
Vector3 1 2 3
[vs]
Vector3 arguments
[vs]
Vector3 arguments [] []

[that is to say, should a function know how many arguments an argument actually is?]

[maybe it's not that bad? it's a question of [use] vs [return]...]

[imports]
use import [System/IO]
import [System/IO]

[Object initialization]
let [Vector3 x y z] [
    Object [
        [x] x
        [y] y
        [z] z
    ]
]
let [Vector3 x y z] [
    return Object [
        [x] x
        [y] y
        [z] z
    ]
]

[multiple variable initialization]
use Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]
Object [
    value1 [Hello, World!\n]
    [func x y] [
        print x
        return y
    ]
    value2 Vector3 1 2 3
]

[and functions]
do fn [x] [print x] [hello]
fn [x] [print x] [world]

[I guess function returns are not exactly related to Objects returning...]

[oh shit. suppose functions do have meta data concerning argument count.]
let [func] print [Hello, World!\n]
let func print [Hello, World!\n]
[the first one is lazy, the second one is eager.]

[maybe I can use that to mix in eager and lazy in a function?]
let [func x] do [
    print x

    [this has to be function, since [x] is not known yet.]
    let [value] + x y

    [this is basically function composition.]
    print value
]
[it returns a string if I don't put [do]?]

[I should consider function metadata more seriously.]
for items print it
for: item items print item

[I guess macros, which is what all functions are built off, would need to figure out the function
metadata.]

let [fib n]
    if or = n 0 = n 1
       n
       + fib - n 1
         fib - n 2

let [fib]
    : : 1 1 zip-with [+] fib tail fib

[I guess I should do function overloading? But instead define types that are comprehensive enough?]

[need [println] if I want single line functions]
let [say-hello] println [Hello, World!]

[I don't know; I've been implementing features to get syntax I want, not for consistency...]

let [say-hello] println [Hello, World!]
let ptr ptr-to [func]
val-of [ptr] [outputs [Hello, World!\n]]

[Dude, haskell is insane: I looked up how to implement a [Vector3] object or similar in it, and was
extremely shocked! Gasp!]

data Vector3 = Vector3 { x :: Int, y :: Int, z :: Int }
    deriving (Show, Eq)

main = do
    let v = Vector3 1 2 3
    print $ x v

[this is fucking insane. I can't believe haskell implemented the stupid idea I had! And weirdly too! Since you can't overload [x]...]

[By the way, [import] opens a file, reads it, executes it... then what? how is it turned into an object?]
[I guess, maybe, it somehow convert the [env] into one?]

[Shockingly, typescript is the most similar to what I envision the final implementation could look
like... Well, not syntaxically of course. You know, the prototypeness, structured types and stuff.]

[Should the language require to specify mutable input?]
let [func mutable-input constant-input] do [
    set mutable-input constant-input
]
[something like that?]

[Should an array be an object?]
[I should have an [Object.Field] type]

[how do I insert the fields of an object in the initialization of another object?]
let Person Object [
    name []
    age  []
]

let Citizen Object [
    Id  []
    use Person
]

[but then, there is no way I could make the name field non quoted...]

[typescript's way of combining types with [&] is really nice and elegant! I should take notes.]

[Maybe I should make the stack have a variable length? Like, I [calloc] when pushing makes the
stack too big? Or maybe not? I mean, when variables have a symbol associated with them, they are by
default on the heap, in a hashmap... There limited cases where this is useful.]

[Also, I should the functional implementation with a very simple version of [let]. None of that
fancy syntaxic sugar please. Though I will implement it eventually, and see how good it is.]

[I'm just gonna use [use] too, at the start at least. Again, I will try a lot of things.]

[Is it possible to make the language fully functional in syntax, but it actually mutates a lot?]

[I'm going too far down the functional rabit hole...]
object [] as [Vector3]

proc [x y z] [
    object [
        [x] x
        [y] y
        [z] z
    ]
] as [Vector3]

[I'm feel like I should only symbolic programming, but quoted symbols are basically pointers...?]

let [Vector3 x y z]
    Object [
        x x
        y y
        z z
    ]

[functions have arguments in type, macros do not]
[function types is according to first use?]

let test-macro macro [print next-token]
[wait – no no no!]
let [test-macro] print next-token
[macros are just functions without arguments!]

[maybe true and false are macros?]

print type-of [Vector3] [Function 3]]
[for 3 arguments]

[wait]
for 3 printl it
[?]

[hmm.]
let [Vector3 x y z] todo
let Vector3 x y z = todo

[[Object] should be capitalized like [Vector3]]

[complex numbers]
let z + 3 4i
[or]
let z 3+4i

[I talk about inconsistency, but what about [[]]? How do you return a string?]
[I guess a string is basically an array?]

let [ret-str] do [
    String [Hello, World!\n]
]

let value Pattern [1 5 25 125 625]

[[Alias] type?]

[I should figure out how to infer function types without arguments. Like, you have macros, but the
macro behave exactly like a normal function, except it's written like a macro just because. And I
should still be able to infer the type (not the implementation though)]

[oh shit]
load-bin [/bin/]
mv [path1 path2]
type mv Function [String String []]
mv path1 path2
[maybe?]

[I think I will still do [let-in], otherwise, some macros can me a pain in the ass.]
[I could make it so the type of a function is infered from it's first use; that or pretyped.]
let [func1 arg] arg
func1 123
[or]
type func2 [Function String]
let [func2 arg] arg
print func2 [Hello, World!\n]

[Then again, no. It should be infered from usage. Like duck typing.]

[I was thinking that arrays could be objects, but why not the reverse?]
let "vector3" [1 2 3]
println get vector3

let ["func" "arg1" "arg2"] func arg1 arg2
[This is weird. I don't like it. Still, the Haskell way, of not really having object should be
explored.]

[maybe [+] is overloaded for objects?]
let [Person name age] Object [
    [name] name
    [age ] age
]
let [User name age] + Object [
    [id] random 0 ^ 2 64
] Person name age
print User [test-name] 123
[outputs:
    [
        [id  ] 123857120581204
        [name] [test-name]
        [age ] 123
    ]
]

* 100 - .5 random

[It makes me gag, but every value should be an object. Well, a tagged union to be exact?]
let [val] 123
debug val
[outputs
    [
        [type ] Integer 32
        [value] 123
    ]
]
print val.type [outputs [Integer 32]]
print val [outputs [123]]

let [obj] Object [
    [name] [test]
]
extend [obj] [age] 43
print obj
[outputs
    [
        [name] [test]
        [age ] 43
    ]
]

[maybe special syntax?]
:= variable field

[I should add named arguments...]
let [test] [
    let token next-token
    if == [-] * token
        match token [
            [-o] set output-name next-token
        ]
    let file next-token
]
test -o main main.txt

let [func arg] print arg
let [func] print eval next-token
let [func] print next-arg

[doc function]
doc [print] [
    prints formatted output to stdout.
    automatically call [to-string] on non-string inputs,
    and [format] on string inputs.
]
help [print]

[functions are colored but only for the linter? like, a symbol will be orange is if it is unsafe?]

[[;] for eval?]
print [Hello, World!\n] [Hello again.\n] ;
print [final hello\n]

[no, remember. a function that an infinite number of arguments. only, it call the functions passed
to it. and the next statement is just that, an argument passed to it, that never returns because it
also calls another function.]

[huh. so i guess you can just do this]
+ 1 2 3 4 5 6
[no, it doesn't work.]
+ + + 1 2 3 4

[LISP has parentheses, I have types.]

[A big reason for function compilation to be lazy, is inter-recursion. I'm pretty sure I saw it in
the 'C programming language book', but there are case where functions doing recursion one after
another makes sense.]

[maybe "" is pushed on the stack, [] is not? and that's the only difference?]

[I should let go of the old object system, and instead have prototypes and instances, where the
object itself is just a macro taking a symbol, and matching it with stuff.]
let [test-obj] do [
    let [token] next-token
    match token [
        value    5
        function do [
            printl [Hello, World!]
            do next-token
        ]
    ]
]
print test-obj value
test-obj function print [rest of the application]
[vs]
print test-obj.value
test-obj.function print [rest of the application]

[hmm]
my-list iter filter fn [item] == item id 132 collect
collect filter fn [item] == item id 132 iter my-list
[btw, this can't be done with [my-list.iter]. you need () function calls and actual [.] syntax.]

[while this is technically the same, it isn't. One requires function overloading, the other
doesn't, and can be done using macros and functions.]

[more importantly, the initial way I had planned to structures was to just take a slice of an array
using [get-at], but it sucked. Still, if I just have the same behavior, but with pre-built
functions attached to a macro object (yeah, just came up with this name). Still, doing mutation is
now kind of hard...]

[also, this model allows for prefix, postfix and infix functions in a more natural way.]

[no. how does [my-list iter] know whether to call the next token, or to just return an iterable?]
let my-iter-list my-list iter []
print my-iter-list filter fn [item] == item id 132 collect
[nah, prefix syntax is just simpler and better.]

my-list iter [filter fn [item] == item id 132 collect]
let my-list my-list iter []
my-list [filter fn [item] == item id 132 collect]
[maybe?]

[it's not that difficult when compiled, but when prototyped...]
let [test-func1] printl eval next-token
let [test-func2] test-func [Hello, World!]
[this should work, since macros and functions are equivalent... but it probably won't be that
simple.]
[I guess [test-func1] is a function taking no arguments, and that's it. But then, they aren't
equivalent...]
let [test-func text] printl text
let [test-func] printl eval next-token
[to make them equivalent, I need to check if [next-token] is called, or just use [] for nesting
everywhere...]

[Even if I don't actually compile, emulating the compile once, then execute every other time is not
that hard.]
[Or should I just start of with proper compilation?]

for range 0 10 printl it
for-in i range 0 10 printl i

fill 255
fill rgb 255 0 0
fill rgba 255 0 0 255
[since object are also functions/macros, this is possible]

do-version file [./main.txt]
do-version 2.5 code [
    printl [Hello, World!]
]
[[file] and [code] both just change the type of a thing.]
[or maybe it should be [cast File [./main.txt]]]
[or just [
    File [./main.txt]
]? That is to say, capitalized.]
[in any case, [do-version] is basically just a function that can execute any version of the
interpreter. perfect for backwards compatibility.]

let [test-func obj] printl obj.name
test-func object [
    name [John Smith]
    age  34
]
[should age also be passed to test-func? or is this equivalent to this:]
let [test-func name] printl name
test-func [John Smith]
[are objects just syntaxic sugar to avoid have 100 arguments to a function?]

let [func n]
    if == typeof n [Number]
        printl n
        overload func n
[basically explicit overloading. the overload function basically just calls the initial version of
the function (throws if it doesn't exist) and doesn't do recursion.]
[I either do OOP/Prototypes with [this], or overloading. There isn't really any reason to do both.
I guess I could, but prefix syntax for everything seems cleaner.]

[I should avoid putting methods in structures.]

let [f x] - 1 * 0.5 x

let value do [
    let val1 69
    let val2 420
    let val3 + << 69 3 420
    val3
]
printl value [outputs "69420"]

[i should have a function called [delete-computer]]

[then again, I guess I could try some form of implicit function overloading?]
[i mean, there's no real reason redefine a function and remove the initial definition, right?]
[and overloading will be everywhere, so I should make the syntax as simple as possible]
[i should use the terminology [overloading] and [overriding] to make it easier to talk about.]

[should I force the use of [return] inside a [do] block?]

[[alias] vs [new-type] vs [ref]]

[[loop] is the only thing you really need.]
[I can't buil [for] and [while] loops using recursion unless I figure out the performance issue]
let i 10
loop [
    print "Hello, World!\n"
    if ! -- i break []
]

let [for] do [
    let [init] get-arg
    let [cond] get-arg
    let [incr] get-arg
    let [body] get-arg

    init
    loop if cond do [
            body
            incr
    ] break
]
for let i 10 != i 0 -- i print "Hello, World!\n"
[I might need some seperators...]
[But anyway, [loop], or at least [goto] needs to be a built in construct]

[I guess I could have a [optimize] function that copies all the function that where defined packed
together, then unmaps the old memory, then continues running with the new memory? Then again, all
the pointers will be wrong. And it will be a pain to change them all...]

[macros will work if we first define the type before defining the function?]
type add-macro Function [i32 i32] [i32]
let add-macro fn [] [
    return + next-arg next-arg
]
let [add-two n] add-macro 2 n
[[return] is of course optional]

[this language does have implicit return, but it's not for use all the time. only when it makes
sense.]
let value if condition 5 0
[right, [return] also exits a function, so that should be kept in mind.]

[I should just have () in case someone wants to be more explicit with their code?]
[But I just don't ever want people to use it.]

[[Quote] and [String] types should be different. A quote can become a string, but it can also
become a array.]
[Like [Number] can be either [Integer], [Float] or [Fraction].]

[There should be multiple ways to construct a [String].]
let my-str String 4
set my-str "hello" [Error: Type mismatch, String 4 -> String 5]
let my-str String "hello"
print type? my-str [outputs "String 5"]
let my-str "hello"
print str-len my-str [outputs 4, because [str-len] is overloaded to take both [String] and [Quote]]

[Just realized that I don't need to make [String] a struct/object because the length is stored in
the type!]

[Wait. So you can do this?]
type my-str "String 5"
set  my-str "Hello"

[Also, characters]
let my-char 'b
[No need for two single quotes. It's probably just a shorthand for this:]
let my-char Char [b]

[I don't do this anymore, but I used to.]
for [let i 0][< i 10][++ i] [
    printl i
]
[If "][" was ";", I could do this]
for [let i 0; < i 10; ++ i] [
    printl i
]

[Hmm, maybe types are variables?]
[Like enums, I mean. Everytime a types gets created, a number is assigned to the symbol.]
let [MyNewType] String
type my-str MyNewType
if == type? my-str String then [
    printl "They are the same type!"
] else [
    printl "They are not the same type!"
]
[where]
let [then quote] do quote
let [else quote] do quote

[but then, I would need to...]
let my-str new String 5
let my-str new String "Hello, World!\n"
[where new is overloaded... but then again, how?]
[[String] is always of type [Type]!]
[Maybe I need two namespaces for types and strings, but I don't like the idea of that.]
[What if I want to pass a type to a function?]

[But then again, if the value a type is a function pointer... I could make this work.]

[[type?] vs [meta?]]
[[type?] gets the first part of the type string, a symbol, then returns its value.]
[[meta?] gets the latter part of the type string; basically the dependant/refined type metadata
like the length of a string/array.]
[don't know about the question mark]

[What happens if...]
let [String] Integer
[I imagine the other types that depend on [String] change not, but about these?]
if == MyNewType String
    print "Yay!\n"
    print "Nay!\n"
[I imagine it shouldn't break older pieces of code like this.]
[If it does, you call that dynamic scoping, and that's bad!]

[actual, [println] is good! that way I won't feel any obligation to use it!]
[Wait no. I just need [\n] as a function.]
println 123
print 123 \n
print "%\n" 123
[equivalent to this in scheme]
(display 123) (newline)

[I should give tail recursion a real try. If I can successfully implement it, it will make looping
so much nicer.]

[Casting from value to pointer should be done implicitly, or not?]
let obj Object []
let [test-func obj] do [
    set obj "Hello, World!\n"
]
[Then again, no?]
let obj ptr-to Object []
let [test-func obj] do [
    set obj "Hello, World!\n"
]
test-func obj
print obj [outputs "Hello, World\n"]
[^ now this works?]
[is the pointer/value overload implicit?]

[[type] to declare things is a little silly. [let] should always be used with default
constructors.]
let str String 10
set str "Hi!\n"
[but is it on the stack or on the heap?]
[wait, [String] allocates space? It doesn't just change the type?? Damn, that change things...]
[Or is it only being reserved? And only actually being allocated when being assigned... Then again,
it's also probably just static memory. You can get the string in the source code, after all.]

[[var] vs [let]]
[Yeah, I need immutable data. Probably a type thing. Maybe every symbol has it?]

[[Float] and [Integer]]
[When you don't want to think about the size of a value, or it's just not important, there should
be a way to not have to specify it.]
[
    Float
    Float 32
    Float 64
    Integer
    Integer 8
    Integer 16
    Integer 32
    Integer 64
]
[[Float] and [Integer] just default to 64 bits. When you use them, you're telling other it doesn't
matter.]
let n Integer []
[but you usually just use inference I guess.]
[Hmm, it's faster to just assign it to zero.]
[But what if you want it undefined?]
let n []
[can be used later.]
[wait, should I use i64 and int and such?]

[Maybe I should add syntax?]
let a 2
let a = 2;
[The latter is more verbose, but it's clearer what's happening.]
let [add a b] + a b
let add a b = + a b;
[The great thing about the latter, is that variables and functions do behave the exact same way.]
add 1 2
add 1 2;
[I guess I don't really need the semi-colon.]

[But if I add syntax, I would rather go the Jai route than the Ocaml route.]
add a b :: + a b
[Nevermind. It sucks. You can see why.]

[By the way, how does Ocaml do inference?]
[Holy fuck! ChatGPT tells me it look into the body to figure that out!! That's what I was trying to
do!!!]
[Damn, this is interesting. So I guess I could make the language look dynamic without actually
making it so.]

[I should dynamically load [printf] from libc just as a proof of concept.]
let value = 123
printf "My value is: %i\n" value

[[symbol] could a be a function that returns the symbol of an argument before it was passed to a
function?]
let macro a = print symbol a
macro hello [outputs "hello"]

(define (reverse-list lst)
    (let loop ((prev '()) (current lst))
        (if (null? current)
            prev
            (loop (cons (car current) prev) (cdr current))
        )
    )
)
(display (reverse-list (list 1 2 3 4)))
(newline)

let [reverse-list lst] do [
    let [loop prev current]
        if null? current
            prev
            loop cons car current prev
                cdr current
    loop [] lst
]
println reverse-list [1 2 3 4]

[I naturally took some liberties. My language having a rich type system, it doesn't actually need a
[list] function (though it of course can be added). Also, [let] behave like [define], and could be
more accurate if the original version of the code was written use it... Still, shockingly enough,
the parentheses make it easier to read. I guess you need a pretty good LSP for this language. I
guess I also don't really need [null?] – in either of the codes, too! Nevermind, just tried it and
['()] is not falsy. Shame on you Scheme! So yeah, advantage for my C-like language.]

let [reverse-list lst] do [
    let [loop prev current]
        if current do [
            loop cons car current prev cdr current
        ] else [ prev ]
    loop [] lst
]
println reverse-list [1 2 3 4]

[do/else is probably better than then/else.]

let [reverse-list lst] do [
    let prev []
    let current lst
    while current do [
        set prev cons car current prev
        set current cdr current
    ]
    return prev
]
println reverse-list [1 2 3 4]

[As usual, imperative is so much easier to read.]

let [add a b] Function [int int int]
let [add a b] + a b

let [greet] Function [void]
let [greet] print "Hello, World!\n"

[Not too bad, but it doesn't work. Because types are values, [greet] essentially just returns a
type.]

let [StringAlias] ptr-to [String]
[vs]
let [NewStringType init] String init

if == ptr-to [StringAlias] ptr-to [String]
    print "The types are the same!\n"
else
    print "The types are not the same, but they behave the same!\n"

[The language doesn't have name arguments, of course.]
[Instead, you do it like JavaScript, where you pass in an object with all the options as fields.]

[For multiple return values...]
let [test-func value] do [
    if some-test value do [
        return [value []]
    ] else [
        return [[] Error [Value is incorrect.]]
    ]
]
let result test-func 123
print get 0 result [outputs 123]
[Hmm, the syntax is ambiguous. What if I want to return a string? Anyway, that's how – or at least,
something like this – that I will use to do multiple return values.]

[But then...]
if tail result do [
    let e tail result
    eprint e.msg
    exit 1
]
[I can of course shorten it...]
if tail result throw tail result
[Or just this?]
throw-if tail result
[It's probably safer since it check the type to see if it's actually an [Error].]

[Still, should I have something like this?]
print get-field [msg] e
[equivalent to?]
print e.msg
[the former is more verbose, but probably better because...]
let print get-field [print] import [System/IO]
[but then...]
let io import [System/IO]
io.print "Hello, World!\n"
[vs]
do get-field [print] io "Hello, World!\n"
[I guess I need both?]
[Wait a second!]
let print get [print] import [System/IO]
[Because of course [get] is overloaded!]
[I could even do this!]
let-get [print] import [System/IO]
[But what about this?]
let-get [print read] import [System/IO]
[I don't see why not?]
let-get print import [System/IO]
[This too?]
[Hmm, isn't this basically destructuring?]
let [test-func n] Result [n []]
let-get [value error] test-func 123
[I guess I could also overload [let-get] to work on arrays?]
[Maybe I should call it match?]
match [value error] test-func 123

[What if [.] was a shorthand for [quote] like [']?]
iterable .next
[Nevermind. It's ugly.]
[... Just like parentheses. But damn! Parentheses make so many things so much more simple.]

[I should have overloading for things like sorted and unsorted lists.]
let [element-of-set? x set] Procedure [Any Ordered[Any]] Boolean
set [element-of-set? x set] cond [
    null? set    #f
    = x head set #t
    < x head set #f
    #t element-of-set? x tail set
]
[Damn, this is hard to read.]

let numbers [42 17 93 8 56 27 91 35 74 3 88 65 12 39 81 53 18 99 47 23 77 6 50 28 96 84 31 62 11 4 90 48 66 14 19 87 45 78 25 70]

let [quick-sort ls] do [
    if null? ls [] else [
        let pivot head ls
        let rest  tail ls
        let smaller filter lambda [x] <  x pivot rest
        let larger  filter lambda [x] >= x pivot rest
        append [quick-sort smaller pivot quick-sort larger]
    ]
]

print quick-sort numbers \n

[macro?]
#type Procedure [Any List[Any]] Boolean
let [element-of-set? x set] cond [
    null? set   #f
    = x car set #t
    #t element-of-set? x cdr set
]
#type Procedure [Number Ordered[Number]] Boolean
let [element-of-set? x set] cond [
    null? set    #f
    = x head set #t
    < x head set #f
    #t element-of-set? x tail set
]
[where]
let [#type] do [
    let type next-arg
    if ! = next-token [let] error "Invalid syntax:\n\n%\n" next-expression
    create-procedure type next-expression
]
[Honestly, I like it. I should mention that you can still do overloading without explicit types,
but it will probably not be as smooth.]

[I should postfix change changing procedures without [!] like in scheme.]
let msg "Hello, World!\n"
print msg [outputs "Hello, World!\n"]
let [change-nothing] let msg "Goodbye, World!\n"
print msg [outputs "Hello, World!\n"]
let [mutate-state] set! msg "Goodbye, World!\n"
mutate-state
print msg [outputs "Goodbye, World!\n"]

[By the way, [let] is an expression.]
let val1 let val2 do [ 123 321 ]
print [val1 val2] \n [outputs [123 321]]
[[let] evaluates the expression then assigns the value at the end of the stack to itself.]

[Also, [List] can be an [Array] or a [LinkedList] or a [Tree] or whatever like that.]
[Though I guess it would need to flatten the tree?]
[What about B-trees?]

[Maybe I should add some syntax that isn't really syntax?]
append [quick-sort smaller  pivot  quick-sort larger]
append [quick-sort smaller, pivot, quick-sort larger]
[These two things are equivalent. the commas are just syntaxic sugar to make it easier to read.]
[Yeah, I'm pretty sure this is a step in the right direction. It's as simple as considering it
whitespace. [;] would probably also make the list.]
let a 2  let b 5
let a 2; let b 5
[I guess I'll call them "syntax" characters? Similar to whitespace, but added to give the language
syntax to make it easier to read. It's of course optional, but was judged necessary still.]
['(' and ')' will probably also make the list.]
print (quick-sort numbers) \n
[I don't know about [:] though... I wanted to use it in names and such...]
for range 0 10 print it
for: n range 0 10 print n
for-in n range 0 10 print n
[I guess I mostly wanted [:] for options and such, but I guess I dont really need it.]
[I can always use the type [Option] as the first argument if I really need to.]
let opt Option [with: "newline"]
print opt "Hello, World!" [outputs "Hello, World!\n"]
[Not the best example, but you get the gist of it.]
[Anything else? Can't think of anything.]
[I don't think I will do [=] though.]
let a 20
let a = 20
let a: 20
[Main reason: it just doesn't look that good.]

[Basically: '(', ')', ',', ';', ':', '"' ]
[Maybe ['] should be a short hand for ['a => Char [a]]]
[What about [{] and [}]? Can't think of anything.]
[What about...]
let [a b] {1 2}
let {a b} 1 2
let {a: 1, b: 2}
[... some sort of special destructuring syntax?]
[What if it's still a quote, but there a way to tell what kind of quote it is?]
print type? [] [outputs "Quote [Bracket]"]
print type? "" [outputs "Quote [String]"]
print type? {} [outputs "Quote [Curly]"]

[I should use these things in moderation. And on second thought, I don't mind adding 'syntax', but
it should remain fake, otherwise the language will become bloated very quickly. So I'm dropping the
{}; I just don't need them.]

[Should [Char] really be a type? Or just an [Integer]?]
print Char [a]       [outputs 97]
print type? Char [a] [outputs "Integer"]
[I think this should be the case, at least for now.]

[Holy shit.]
let obj Object [
    name: "John Smith",
    age: 32, #tag [Ignore]
]
[What ever [Tag [Ignore]] means, I don't know. Anyway, because the [Object] procedure is smart, it
will be able to see that there is an item of type [Tag] and not add it to the object as some field,
as well as add it to the metadata, or where ever the fuck. I can even something like [Private]!]

[Also, I guess it doesn't matter where the [Option] is passed?]
let opt Option [with: "newline"]
print opt "Hello, World!"
[is equivalent to]
print "Hello, World!" opt
[Because if [print] is responsible for executing the rest of the application, then it will have to
check the next argument regardless.]
[And I can have an implicit field in [Context] or [Environment] where I can extract the options
from.]

[I know I said no syntax...]
let a 2; let b 3
print "a b" [outputs "a b"]
print [a b] [outputs [2 3]]
[I mean I should right? Otherwise, it will become insanely verbose. And Scheme's printing of lists
is so nice to work with! I want some of that!]

[[xyz] is parsed as a string and matched to the symbols [x], [y] and [z]?]
swizzle vec xyz

[[=], [==] and [!]?]
print ! =  1.0 1 [outputs #f]
print ! == 1.0 1 [outputs #t]
[I don't know. I guess [=] is a 'loose' equal, while [==] is a 'deep' equal.]

[I guess it should be [#opt]?]
let file open "./random-file.txt"
print "Hello, World!"
    #opt [with: "newline", without: "format", output: file]
[I guess this is important also because a procedure can take a type of [Option] the normal way.
This is just a way to make sure the [Context] captures the options.]

[I should maybe go back to calling things [Word] and [List], because I'm struggling a little with
[Expression] and [Statement] (which is which?).]

[[import] returns a value of type [Module] which is overloaded with [do] to expand.]
import [System/IO]
print "Hello, World!\n"
[or]
let io import [System/IO]
io.print "Hello, World!\n"
[or]
let io #import "System/IO"
io.print "Hello, World!\n"
[because [#import] is actually a macro that expands to]
let io Module [
    let [print fmt] do [
        [INSERT PRINTING LOGIC HERE]
    ]

    [INSERT ALL THE OTHER IO PROCEDURES HERE]
]
[maybe?]
[I certainly prefer the [#] and ["] syntax.]
#import "System/Syscalls"

[Also, I need an [Or] type. For polymorphism or whatever.]
#type : Or [Number, String, Object[Any]]
let item proc-call-that 123 "will return" Object [random: "value"]
[Or should it be an [Inherit] type?]

[[#] is a prefix for procedures that modify the usual execution of procedures.]
[[#import] for example is a modification on [do].]
[[#type] is a modification on [let].]
[[#tag] is a modification on [Object].]
[[#opt] is a modification on every procedure, and their implicit [Context].]

["" (String) and [] (Quote) are both the same, in that they stop the normal execution of code, but
they are different, and procedures may overload them accordingly.]
[Or should I say [List] instead of [Quote]?]

[I guess I could just do [inline].]
let [square x] inline [
    * x x
]
square 4
* 4 4

[Maybe I should put the [#type] modifier after the assignment?]
#type Proc [Number, Number] Number
let [add x y] + x y
[vs]
let [add x y] + x y
    #type Proc [Number, Number] Number
[Nevermind, it's ugly.]

[Hmm.]
let [say-hello] do [print "Hello, World!\n"]
let [a b] [1 2]
print a \n [outputs 1]
print b \n [outputs 2]
[Damn!]
let list [1 2 3 4 5]
let [x y] list
[But no, it doesn't really work.]
[But I can figure this out! It's doable.]

[I guess this is better right?]
let [element-of-set? x set] cond [
    null? set : #f
    = x head set : #t
    < x head set : #f
    #t : element-of-set? x tail set
]

for 0..10 as i print i
[Damn, I just remembered why I decided to implement [println].]
[Anyway, I thought that I could've a [..] special notation for numbers but...]
let N 10
for 0..N/2 println it
[Yeah, that's illegal.]
[Anyway, big idea! [as] macro that changes [it].]
let [as] inline [
    let next-token.......
    next
]
[Fuck. I can't do it.]
[No wait. I can't give up.]
let [as] inline [
    assign next-token it
    delete it
    next-arg
]
[Something like that?]
for range 0 N as index println index

[I should use [print\n] instead. Just for shits and giggles.]
for range 0 N as index print\n index

[But...]
str1 :: "Hello, World!\n";
str2 :: "Hello, World!\n";
if str1 == str2 print true;
else print false;
[^ this will be true, because it's a strcmp, but...]
if &str1 == &str2 print true;
[this is the standard C [==], which frankly speaking makes sense... That being the case, do I
really need a loose equal?]
let str1 "Hello, World!\n"
let str2 "Hello, World!\n"
if == str1 str2: print "true"; print "false"                   [outputs "true" ]
if == ptr-to [str1] ptr-to [str2]: print "true"; print "false" [outputs "false"]
if = str1 str2: print "true"; print "false"                    [outputs "false"]

let new-print [print]
new-print "Hello, World!\n"
[this should work because there is a difference between quoted and a string, probably.]

[should be like this instead.]
#type [Proc Number Number Number]
let [add x y] + x y

[I guess [] can turn a procedure into a value?]
print add 1 2 [outputs 3]
print [add]   [outputs [outputs 0x1aebeff453 something...]
[no, it should print [add].]
[you can still call it. I just need to not forget the value-symbol-pointer relation.]

#type [Real Number]
[^ if a function takes any number type, then it first check the first type, then it checks the
second, until it either finds it or throw and error because this function does not this type.]
[basically this]
cons [Dog] cons [Mammal] [Animal]

[By the way, I'm reading SICP, and the Scheme way of doing dynamic dispatch is so interesting.]
[[#type] should be a macro for that.]
let [#type] inline [
    assign do [
        let type next-token
        if = next-token "let" do [
            error "[#type] only works on [let] procedures."
        ] []
        let name next-token
        let body next-datum
        put global.overloads name type body
        return [name (get global.overloads name type)]
    ] do-nothing
]
[something like this?]

[I guess I should be able to do something like this?]
map [+ 1] [1 2 3 4 5]
[and]
let test [print "Hello, World!\n"]
test
[^ this works and so does this]
return test
[but this is delayed?]
return [test]
[I guess [] is more of a delay than a quote?]

[Honestly, fuck it.]
cp -i file.txt folder/file.txt
[This should be valid code.]
[Okay, no. Too much.]
cp -i "file.txt" "folder/file.txt"
[Now this should be valid code.]
[But then again...]
cp "file.txt" "folder/file.txt" #opt -i
[I guess I change nothing.]

[Wait a second...]
let [add x y] + x y
[this is multiple assignment on one like...]
add, x, y = () => x + y, 1, 2
[it is just that the x and the y are delayed?]
[but how do I use this knowledge? If I think of this a currying, then this could become extremely
elegant.]

[All strings are delayed evaluation.]
[[extract]? [let-for]?]
[[+] is both a symbol and a pointer until it is used?]

[Moral dilemma: strings are procedures, at least on the surface.]
let add [+]
[vs]
let [add] [+]
[vs]
let add lambda [] [+]
[one should return a string/function, the other should be a function.]
[equivalent to this:]
(define add +)
(add 1 2 3 4 5)
(define (add) +)
(add) => #<procedure +>
[similarly]
let add [+]
+ [1 2 3 4 5]
let [add] [+]
print add [outputs "add"]
[since procedures are strings. strings need indirection to not be evaluated as strings.]

[I need to sit down and figure out the essentials. The language is a mess right now.

[List of things that will not change.]
    print "Hello, World!\n"

[List of things that may change.]
    let say-hello [print "Hello, World!\n"]
    say-hello [outputs "Hello, World!\n"]

    let [hello-str] "Hello, World!\n"
    print hello-str [outputs "Hello, World!\n"]

[I have no need for [#type [Proc Int Int Int]], just put all the arg types and the final type is a
procedure. For variables, just have the return type and nothing else.]
#type [int int int]
let [add a b] + a b

[Maybe a [#mutates] which marks a procedure call that mutates the global state of a program? To
help find bugs?]
[I should name asm instructions [move-register], [move-immediate], and some such. It's longer, but
clearer.]

[It sucks, but I should explicitly overload functions like in Odin.]
[Or not? What if procedures are either polymorphic or overloaded?]
[If I don't put an explicit type, they become generic, not dynamic?]
[So [sub n] and [sub x y] are overloaded without the need for a [#type]?]
[Nevermind, I can't do that.]

[What if [Text] is the most fundamental datatype?]
[This always always returns a string or [Text], but the receiver can parse it however they want...
but how does it capture variables?]
return [something something-else]

let val [print]
[calls [do] on [print] which makes it return a procedure pointer, but]
let [val] [print]
[calls]
let val lambda [] [print]
[which calls [reduce] or something which doesn't return a procedure pointer.]

[No, a procedure is always both a string and a pointer.]
let say-hello [print "Hello, World!\n"]
say-hello [outputs "Hello, World!\n"]
print [say-hello] [outputs "say-hello"]
print "say-hello" [outputs "say-hello"]
print ptr-to [say-hello] [outputs 0x(random pointer)]
print val-of [say-hello] [outputs "print "Hello, World!\n"]
print say-hello [outputs 14 (or strlen "Hello, World!\n")]
[I don't know. It's nice. I think I like it.]

[When we import binaries...]
load "a.out"
a.out ["Hello, World!\n"] [outputs "Hello, World!\n"]

#type [int]
load "a.out"
let n a.out []
print\n n [outputs "Hello, World!\n14\n"]
[or not. I think I had an idea, but I lost it.]

[Maybe I shouldn't bother with special function declaration.]
let add [
    let [arg1 arg2] next-arg next-arg
    + arg1 arg2
]
[no, even beyond that...]
let add [
    [[args] is the program code + offset for the current part of the program.]
    let [x y] args
    [which is equivalent to [let [x y] [1 2]]]
    + x y
]
add 1 2
[I actually really think I'm onto something here.]
[In LISP, it's all about linked lists, in this languages, it's all about strings.]

[Holy, fuck. [args] is a string, so it gets executed!!!]
let [print-2-words] [
    let [x y] next [args], next [args]
    print "%, %\n" x, y
]
print-2-words Hello World! [outputs "Hello, World!\n"]
[Also, [let] can go back to always being quoted... But isn't that a problem?]
[By the way, does [let] consume when doing [let [x y] args]?]
[No, it consumes when it's being run.]

let two + 1 1
let add [+]
let [str num] "Hello, World!\n" 123
[Whatever, I guess I'm keeping the non quoted [let].]
[You shouldn't be doing multiple function declarations anyway.]

[Hmm.]
let [str num] "Hello, World!\n" + 1 2
[What if num equals [+] and not 3?]
let [new-print] print
let new-print [print]
[equivalent?]
[I know this:]
let val + 1 2 [=> 3]
let val [+ 1 2] [=> + 1 2 (lazy)]
let [val] [+ 1 2] [=> "+ 1 2" (lazy)]

[Wait, I know.]
let [str num] "hello" 123 [str == "hello", num == 123]
let vals ["hello" 123]
let [str num] vals [str == "hello", num == 123]
[Imagine [vals] getting evaluated, and it being replaced with the first example because the braces
have gotten removed.]
let [vals] ["hello" 123]
let [str num] vals [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == [str == "\"hello\" 123", num == ...]]]] You get the gist of it.

[Anyway don't think [+] should get evaluated. But I don't know.]
let [str num] "Hello, World!\n" + 1 2

let [read write] #import "System/IO"
[Then again... It should otherwise this isn't possible.]
[And honestly, there's not much point in it not executing...]
let io #import "System/IO"
#import "System/IO"
[These 3 should be valid always.]

[I guess I can't do this.]
let [obj2 obj1] obj1 obj2
[It will destructure obj1 otherwise.]

let test-proc [
    for args print it
]
[Honestly, wow. I really hope I can work this out, because fucking hell!]

[but what does [#import] return specifically...?]
[something like this?]
[
    read  [...]
    write [...]
]
[Maybe I really should have something like a distinction between strings and lists... That would
make it easier.]

let #import [
    let full-path (+ global.modules-path args)
    let file (read-entire-file full-path)
    return (reduce file)
]
[No, this is wrong.]
[I think I got it!]
[What does [#import]? Nothing, that's how I'll do it!]

#import "System/IO"
[is equivalent to]
let read  [...]
let write [...]
[maybe [...] should be the [error Not-Implemented] call?]
[anyway]
let io #import "System/IO"
[is equivalent to]
let io [
    let read  [...]
    let write [...]
]
[but that means you should be able to do this for every assignment?]
let val [
    let a 123
    let b 321
    + a b
]
print\n val.a
[Wait... Did I accidentally come up with a clever ass way to do objects?]
[The problem is this.]
let [read write] [
    let read  [...]
    let write [...]
]
[But I guess it's fine. Literals should not be destructurable.]
let pkg [
    let read  [...]
    let write [...]
]
let [read write] pkg
[this works!]

[Now that I think about it, I already had this idea for objects a long time ago.]
obj :: {
    a :: 123;
    b :: 321;
}
[Yeah, I didn't even use square brackets yet. It was that long ago. Before I even decided to
conceive this language.]

let obj1 [let name "John Smith"]
let obj2 + obj1 [
    let age 23
]
[and they even double as constructors.]
let new-obj [
    let field1 args
    let field2 args
]
let obj (new-obj 1 2)

[Wait!]
let test [
    return [1 2]
]
let result1 test
print result1 [outputs "1 2"]
let [result2] test
print result2 [outputs 1]
[That's how I do multiple return values.]

[The equivalent in Jai:]
result2 :: test();
print("%", result2); // outputs 1
[Actually, there's no real equivalent... You can return arrays in Jai, but I don't think you can
casually destructure an array like I did.]

let #import [
    let [module-name] args
    let file (read-entire-file (+ modules-path module-name))
    inline file
]
[Should it really be that simple? Seriously?]
[No, there's a bug somewhere.]

[For one, this is scoped, so the top level full import is discarded.]
let #import [
    let [module-name] args
    let file (read-entire-file (+ modules-path module-name))
    return file
]
[Wait, I changed it to a return randomly, but that actually makes sense!]
let io #import "System/IO"
[Now [io] runs the file everytime it is called.]
io
[nothing happens, but if the module had top-level prints, or it returned something, then that
would happen.]

[But no... I need to think about this harder.]
let f1 [
    return [print\n "hello"]
]
f1 [what happens?]
[I don't know. So I'm going to assume that it executes the text because that's what would make
[#import] work easier.]
let f2 [
    let g [print\n "hello"]
    return g
]
f2 [This also should evaluate.]
let f3 [
    let [str] "print\n \"hello\""
    return str
]
f3 [and this]
[When it becomes different is with [let].]
let ret   f1 [== [print\n "hello"]]
let [ret] f1 [== print\n]
[Ahh... This is becoming a bit of a pain. But I really need to figure this out.]

[Wait, [f2] returns [] or void. [g] is eager, so it gets evaluated.]
[Okay, I know. The thing I said about [f2] still stands.]
[[f1] also. For [f3], it's equivalent to this.]
let ret f3
ret [outputs "hello"]
let [ret] f3
print ret [outputs "print\n \"hello\""]
[which is of course equivalent to]
let ret   "print\n \"hello\""
let [ret] "print\n \"hello\""
[Wait, but how does the receiver know how the string was returned?]

let [str1] [print "hello"]
let str2 str1 [I guess this just doesn't get evaluated.]

[There should just be 3 ways for strings to be parsed, then again. Otherwise, is this a procedure
or a string?]
return [print\n "hello"]
return [1 2 3 4 5]
[God, then return value things are so damn confusing!]
[There are so many goddamn layers to it! It's never ending!]

[I wonder if I should make it so it's impossible for the language to error?]
[Probably not, but I could right?]
[No, some things need to error.]
tail []
[for example.]

[maybe?]
let imports do [
    #import "System/IO"
    [...]
]
[I guess I could also do this if I had "" and [] as different types.]
let imports #import [
    "System/IO"
    "..."
]

[Actually, I decided to create a file in which the list of things that will not change will go.]
[It's like a very barebones spec.]

[I've been thinking about it for a while, but fuck "procedure". It sound worse and looks worse then
"function" in every way. I'm using "function" from now on.]

[What about, if the function returns [], it matches on the fields, like an object. And if it
returns something, it is multiple assignment.]

[Destructuring]
let obj [
    let field1 123
    let field1 321
]
let new-obj obj
print new-obj [outputs []]
print\n new-obj.field1 [outputs 123]
let [field1 field2] obj
print\n field1 [outputs 123]

[Multiple return]
let obj [
    let field1 123
    let field1 321
    return [field1 field2]
]
let ret obj
print ret [outputs "field1 field2"]
print\n ret.field1 [outputs 123]
let [ret] obj
print ret [outputs 123]

[Wait but that means these are still the same!]
let new-obj obj
let ret obj
[It's only destructuring that changes.]
[If this was a boring/useful language, I would probably not allow this... but whatever.]

[I guess there is no way to return a function with literals.]
[or is there?]
let obj [
    let field1 123
    let field1 321
    return [print\n field1]
]
let ret obj
print ret [outputs "print\n field1"]
let [ret] obj
print ret [outputs 123 and then [] for the second print.]

[I did it. Finally. It's done.]
[Damn.]

[And it makes sense. Right?]
[When we destructure something, we want the result to be evaluated.]
let obj [
    let field1 123
    let field1 321
    return [field1 field2]
]
let [ret] obj
print ret [outputs 123]
[This prints 123, not "field1". So it's eager.]
[And because it's eager, and the first field gets evaluated, we can just put in a function with
arguments. It will get evaluated, and so will it's arguments.]
[I'm so happy, man.]
[Finally.]

[The only caveat is returning one string. But that's manageable, of course.]
let obj [
    let field1 123
    let field1 321
    return ["Hello, World!\n"]
]
let [str] obj
print str [outputs "Hello, World!\n"]
[Actually, it's not even a real caveat!]
let obj [
    let field1 123
    let field1 321
    return "Hello, World!\n"
]
let str obj
print str [outputs "Hello, World!\n"]
[I mean, yeah. Of course it would.]

[bad]
let obj [
    let field1 123
    let field1 321
    return field1 field2
]
let ret obj [error "Not-Found" on symbol "field1" with call (field1 field2)]

let f [f] [== infinite loop]

let print-all [
    for args print\n "% " it
]
print-all [1 2 3 4 5] [outputs "1 2 3 4 5 "]

[I hope I don't find yet another headache about the language.]

[What if after destructuring the return, you can still get the fields?]
let obj [
    let field1 123
    let field1 321
    return [field1]
]
let ret obj
print ret [outputs "field1"]
let [ret field2] obj 666
print field2 [outputs 666]
[On second thought. No, it would be better to keep multiple assignment for this.]

[Then again! You should not destructure and multiple assign at the same time!]
[It's either one or the other.]
[And as usual, I prefer to remove limitation rather than adding them, so...]
let [ret field2] obj 666
print field2 [outputs 321]

[And if you want to do multiple with a function that returns a string, well you're fucked.]
[And anyway, it's impossible. Not with this model, at least.]

[I should mention, that if a function returns a single value, not quoted, it defaults to multiple
assignment.]

let [type-list] ["text" "[text]" "number"]
[That's pretty much all I need right?]
[Everything else can be built the scheme way.]
[If object layout is like C structs, then that's a lot of problems out the window, just like that.]
[And I already figured out that enums and tuples are glorified objects.]

[Oh!]
let func [
    let arg1 int args
    let arg2 float args
]
[Is this better than [#type]? Probably. But it needs working.]
[And this doesn't work.]
let func [
    let [arg1 arg2] int float args
]
[but you can do this.]
let func [
    let [arg1 arg2] int args, float args
]
[I don't see any reason not to.]

[I suppose both [] and 0 should be falsy. "" as well, of course.]

[overloading]
++ [
    if text [for 2 args] [...] [...]
] +

for 10 print\n it
for [0 10] print\n it
for [10 0] print\n it
for [10 0] as i print\n i

[infinite]
for [-5] print "% " it [outputs "-5 -4 -3 -2 -1 0 1 2 3 4 5 ..."]
[this as well. It defaults to 0.]
for [] print\n it

[I need to have implicit return.]
let add [+ args args]
add 1 2
[otherwise]
let add [return + args args]
add 1 2
[It's fine honestly. The only problem is a non-problem.]
let something ["something"]
[^ you will never do this.]
[You can implicitly return everything else.]
[If there's something you don't want returned...]
let [] func
[It gets discarded.]
[Multiple return argument that aren't destructured are also discarded.]
let mul-ret [return [1 2 3]]
let [ret1 ret2] mul-ret
[Wait, forget what I said about strings being a non-problem... Though I guess it's not that bad.
If you do multiple return, you should be explicit about it.]

[Infinite smart lists?]
for [1 10 100] print\n it

[[i/t] for rational numbers, because [rat] and [rational] are ugly...]
[... Actually, nevermind. [i/t] is perhaps even uglier.]

[This should be a feature.]
print take 10 [0 10 100] [outputs "0 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000"]

[Array programming.]
print + 5 [0 5 10] [outputs "5 10 15"]

for 0 print\n it
[is also infinite.]
[also, [] should == 0]
[there are a nice symetry if I do it (see for loop).]

[by the way.]
if true [
    print "it's true!!!\n"
] [
    print "it's false?!?\n"
]
[[] should be obligatory, otherwise...]
if true do [
    print "it's true!!!\n"
] else [
    print "it's false?!?\n"
]
[or]
if true
    print "it's true!!!\n"
    print "it's false?!?\n"
[which are harder to read.]
[while I was exploring the earlier model, it was something that annoyed me, and I put brackets
despite not needing them, just because of how unclear the language was without them.]

for 0 [print\n it]
[I guess I don't need [print\n] anymore. – Who am I kidding. It's a pain in the ass otherwise. More
characters and... and honestly, it grew on me. Yeah.]
for 0 [print it \n]
[^ this is so ugly. Ugh.]
print "Hello, World!\n"
print\n "Hello, World!"
[$$$ Beautiful $$$]

[I will eventually have to figure out how to return strings from if/ternaries...]
[Did I already mention that only the last implicit return actually returns? Well, I have now.]
[Technically, [/ arg 0] returns [] which is void or undefined. But because [] == 0, it also means
that it returns 0.]

[A way to "implicitly" return strings?]
let my-str if condition [text "1"] [text "0"]

let f [
    print next arg [outputs [1 2 3]]
    print next next arg [outputs 1]
    print next 2 arg [outputs 1]
]
f [1 2 3] [1 2 3] [1 2 3]
[... should it? This feels wrong.]

[lol]
let ever 0
for ever [print "THE END IS NEVER "]

[also, the remainder [%] should also be 0. What other value could it be? Infinity?]
[btw]
let Infinity 0
for Infinity [print "THE END IS NEVER "]
[and]
print-bool = (/ 1 0) Infinity [outputs "true"]
[or should it be...]
print bool = (/ 1 0) Infinity [outputs "true"]

[Strings are not null terminated. Nothing is.]
[Every value in the language has a [size-of].]
[The value is in bytes, and is stored in the symbol table.]
[[size-of] is low level and goes there to find the size of it. It's fast.]
[[str-len] uses [size-of] instead of the null check.]
[[length] as well. By the way, [length] checks the number of elements in an array, so...]
let [arr] [0 1 2 3 4 5]
length arr
[btw]
let arr [0 1 2 3 4 5]
print\n arr [outputs 5 because it's the last implicit return.]

[[int] casts value to int.]
[[int?] returns true if input is an int, otherwise false.]
[[int!] throws an error if the value is not an int, otherwise returns the int.]
[[float] casts value to float.]
[and all the equivalent functions for the other number types.]

[currying]
let create-add-n [return [+ arg]]
let [add2] create-add-n 2
print\n add2 4 [outputs 6]

[I may be called a heretic... But lists should be one-based.]
[Also, ranges should be inclusive.]
for [1 5] [print\n it] [outputs "1 2 3 4 5"]
let arr map [* 2] [1 2 3 4 5]
print\n get 5 arr [outputs 10]

[It's nice and all, but it will only truly be successful once I figure out how to make secretly
static.]

for [1 .5 .25] [print\n it] [outputs "1 .5 .25 .125 .0625 ..."]
for [1 1/2 1/4] [print\n it] [outputs "1 1/2 1/4 1/8 1/16 ..."]

[Huh. What if I print an infinite list?]
print range [] [outputs "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ..."]
[I guess [range] is defined as such?]
let range [
    let [val] arg
    + if and val, (<= tail val, head val) [
        head val range [+ 1 val, tail val]
    ] [
        text [0] range [+ 1 val, tail val]
    ]
]
[I guess?]

let [len arr] length . arr
[[.] duplicates an a [text].]
let array-with-length pair length . arr
print array-with-length [outputs [3 [1 2 3]]]
[or]
let array-with-length [length . arr]
[no, it only returns one value.]

let bool [
    if arg [text "true"] [text "false"]
]

[Oh shit!]
[In python,]
x[-1]
[is equivalent to]
x[len(x)-1]
[I'm totally doing that.]
[Another way to never crash.]

get -1 arr
[calls length by itself.]
[also, length should be memoized.]
[no need to pair it with a list then.]

[On a single value.]
let single 123/2
let val int single
print\n val [outputs 61]

[On multiple.]
let arr [1.34 single 3 "123" 5+3i]
let val int arr
print\n val [outputs [1.34 61 3 123 5]]

[On wrong value.]
let arr [1 2 3 "asldkjasldkj" 5]
let val int arr [error "Impossible-Casting" on value "asldkjasldkj" to type [int]]

print\n real 3+4i [outputs 3]
print\n imaginary 3+4i [outputs 4i]
print\n + real 3+4i, imaginary 3+4i [outputs 3+4i]
print\n complex 3 4 [outputs 3+4i]

[I should have negative indexes like in python.]
let [list] [1 2 3 4 5]
print\n get -1 list [outputs 5]
[but if I have negative indexes, I can't have one-based indexing... Oh well.]

[Since I am to make it almost impossible for the program to crash without an explicit panic, should
I do this?]
let [list] []
print\n tail list [outputs []]

[No even haskell can do this. This is some insane APL shit.]
let . [let n arg; return [n n]]
let square [* .]
print\n square 4 [outputs 16]

[[??] and [!?]]
let [nil] []
let not-nil 123
print\n ?? nil 321 [outputs 321]
print\n ?? not-nil 321 [outputs 123]
print\n !? nil 321 [outputs []]
print\n !? not-nil 321 [outputs 321]

let ?? [
    let [x y] args
    if x [
        return x
    ] [
        return y
    ]
]
let !? [
    let [x y] args
    if x [
        return y
    ] [
        return x
    ]
]

[By the way, this returns [].]
let val []
[It's still a function, but function without a body always return [].]

[Maybe calling [tail] on the last item goes back to the start? That would make sense if [get -1] is
the end.]
[New piece of syntax. -symbol negates a symbol and -[] negates every item in an array. -arr also
does it.]
[Wait, I can't forget that]
let [list-of-strings] ["dog" "cat" "elephant" "so on"]
for list-of-strings [print\n it]
[works for objects as well.]

[Nevermind for 1 based indexing. And I think I'm going inclusive ranges as well.]
[N has to be inclusive, otherwise [10..0] will be fucked.]

[Oh my god!]
let val [] [== 0]
[So it's zero by default. Is it even possible to have true undefined?]
[Wait no. They are equal but not equal at the same time.]
[[] is closer to the "" and can be used as an actual undefined. Who cares if a single int is 0? It
did not initialize the array it points to... But then again, how do I initialize it?]

let nil []
let zero 0
print\n bool =  nil zero [outputs "true"]
print\n bool == nil zero [outputs "false"]
[[=] is true because they are equivalent.]
[[==] is false because they are of different types.]

for [0 10] as n [print\n n]
[[as] attaches itself to the start of the code block so]
[assign [n] it; print\n n]

[These should do different things.]
let x arg
let x args

[functions are objects right?]
let.single [x] [print "hello\n"]
x [outputs "hello\n"]

[I can even do overloading like this.]
print.overload "complex" [
    let number arg
    print "%+%i" real number, imaginary number
]
let number complex 3 4
print\n number [outputs 3+4i]
[[print\n]'s definition is of course based on [print].]
let print\n [print args; print "\n"]

[I suppose I should make it so every function is overloadable. They are just overloaded by default
on basic text, [text] and number.]
[Also, I just realized that the above code is maybe broken?]
[I know what to do.]
let x args
print x [outputs [print "hello" 123 "arg3" ...]]
let [x] args
print x [outputs "hello"[]]
[... This is a bit of a long shot, but what if the arguments aren't consumed until they are used?]
[so this code would be valid.]
let print + [
    let [number] args
    if = "complex" type? number [print "%+%i" real number, imaginary number] []
] print
let number complex 3 4
print\n number [outputs 3+4i]
[Isn't it beautiful? Function overloading is just string concatenation.]

[By the way, args at the top-level takes the args from the terminal call.]

[The [print\n] is wrong. Let me think about it more.]
let print\n [print head args, tail args; print "\n"]

[Should I do this?]
let [x y z] args [tail y == z]
[No. What if [y] is a list?]

[I shouldn't about this.]
let x nth 0 args
[macros basically.]
[then again.]
let x nth.lazy 0 args
[this is probably better.]

[heh.]
let x nth.number 0 args

[wait]
let print + [
    let [number] args
    if = number.type "complex" [print "%+%i" real number, imaginary number] []
] print
let number complex 3 4
print\n number [outputs 3+4i]
[then again...]
= number.type "complex"
= type number "complex"
[I shouldn't hide fields like that.]

[[+] vs [++]]
print\n + 1 2 [outputs 3]
print\n + [1 2 3] [outputs 6]
print ++ "Hello, " "World!\n" [outputs "Hello, World!\n"]
let val 5
print\n val [outputs 6]
print\n ++ val [outputs 6]
print\n val [outputs 6]

let val 5
+= val 2 [-> 7]
+= 2 val [-> 7]
+= [1 2 3] val [-> 11]

let [val] "Hello, "
++= "World!\n" val [val = "World!\nHello, "]
++= val "World!\n"  [val = "Hello, World!\n"]
let [ue] "World!\n"
++= val ue [val = "Hello, World!\n"]
++= ue val [ue  = "World!\nHello, "]

let loop [loop args]
loop [
    print "THE END IS NEVER "
    break
]
[But no. That would be the ideal because of how simple it is... But I don't know how to make it
work. I'll have to think about it.]
[I should try to warp the logic of the language to allow for that though. It's too sexy!]

[I guess it should be this.]
let loop [loop do head args]

[A pointer to any type is [type].]
[This works too: [number].]

echo "print [Hello, World!\n]" | ./a.out

[nested destructures]
let [[field1 field2]] args

[rust]
#[function_component]
fn Component() -> Html {
    html! { 69 }
}
[vs]
let Component [
    html [69]
]

[val-of vs ptr-to vs do]
let f [print "hello"]
val-of [f] [-> [print "hello"]
ptr-to [f] [-> (random pointer)]
let [s] "print \"hello\""
ptr-to s [-> (random pointer)]
do s [outputs "hello"]

let withdraw do [
    let balance 100
    return [
        let [amount] args
        if >= balance amount [
            set balance - balance amount
            return balance
        ] [
            return "Insufficient funds"
        ]
    ]
]
[I guess you can't multiple return a function and other things...]
[But aren't variables functions?]
[Or maybe you can, but the function has to be the last one...]
[Or maybe [let] is secretly a tree argument function? And so is [if]?]

[I should probably define the standard library before I actually implement the language... Then
again? I don't know. If I do it before, I could get things that are mathematically elegant.

[Maybe I should create a borrow check of sorts, just more implicit?]
[Like instead of throwing an error because a variable no longer owns a value, it implicitly inserts
a copy?]

[My language should have the same energy as c89, at least for obfuscation.]

[I should add single quotes as well.]
let [my-str] 'Hello, World!\n'
print 'Hello, World!\n'
print "Hello, World!\n"
[Then again, maybe not. Unlike ["], it doesn't look good enough for me to make an exception.]

[I have three options right now:
    - Do it like math, where I just write the overview of the language.
    - Do it like emulated, where it's not truly compiled. I can test it though.
    - Do it like a true interpreter/compiler.]
[I don't know. I initially thought to just do the third one, because I'll just have to change it
anyway, once it's done, if I do another model. But I don't know about that anymore. I saw how
elegant some of the algorithms are and thought that I could try to first defined those elegant
functions without worrying about performance, then workout the implementation details. The goal is
something that is both elegant and performant...]

[I should consider making order of assignment irrelevant. I already planned that out for the
top-level, but I mean for inside functions as well. And it makes sense to have that, since
[#import] basically just reads an entire file and evaluates the resulting string as a
function.]
[I suppose order of assignment should only matter for redeclaration or usage?]
[There is compile-time and run-time right? So I could do it... Then again, I don't need to, since
it's literally just a bunch of strings.]

[Honestly, I'm starting to see the limits of this way of doing things. I should try to write a
second interpreter again... But honestly, I should also finish reading SICP. There's a lot of
knowledge I can steal from that.]

[There are maybe two types of [set]s? One sets variables for dynamic scoping, the other for static.
That way, there no need to create functions that create new scopes and functions that don't.]
let test [
    set.dyn var + var 123
]
[... or maybe if there isn't a global variable that matches, it simply continues searching using
dynamic scoping?]
[Or maybe I can just get away with not having it period. Yeah, I'll features as I need them.]

[Even if I do the string model, I should include [#run].]

[I guess a macro is just this.]
let test-macro [
    let val 22; do
]
let val 33
test-macro
print\n val [outputs 22]
[That and you know, the non-evaluated args.]

[I should define a map function.]
(define (map f lst)
    (if (null? lst)
        '()
        (cons (f (car lst))
              (my-map f (cdr lst)))))

let map [
    let [f lst] args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[It's nice, but I still don't know how [args] behaves.]

[I should be able to do this.]
map [+] [1 2 3] [4 5 6]
[The number of arguments is determined by the function.]
[Nevermind, should follow haskell and only partially apply the function.]
[Then I'll use [zip-with] for stuff like that.]

[Constants are uppercase, but there is nothing forcing you to not mutate.]
[You can force it by making it so that [set] can't redefine uppercase (lol).]

[[char] chars takes a [text], and converts it to list of chars:]
chars "hello" [-> ["h" "e" "l" "l" "o"]]
[Single character strings are synonymous with characters, and you can loose compare them to
numbers.]
[Maybe I should have a "text" type as well; not for any real reason, just to help with pretty
printing. Though, nevermind. That would complicate things unnecessarily.]

[There is a [type] and [true-type]. The true type is actually what's used to optimize things.]
[Every type starts as [indeterminate].]

[I shouldn't always need [#run]. If a function is pure, it should run at compile time
automatically.]

[Everything is copied by default]
let say-hello [print "Hello, World!\n"]
let ref [say-hello]
[^ to create reference.]

[Maybe [:] won't be a syntax char...]

[One of the goals was array programming but...]
[That's on hold for now, since there are no array programming languages without scheme/haskell like
syntax that I can copy. This is telling me that the syntax is probably a big aspect of it. Anyway,
array programming will be a second thought.]

[[do] and [val-of] should work on pointers.]

[If functions call themselves recursively, there no reason not to be able to do this.]
let obj [
    let name "John Smith"

    let method [
        print\n name
    ]
]
obj.method [outputs "John Smith\n"]
[or even]
let obj [
    let name "John Smith"
]
let obj.method [
    print obj.name
]
[now I now this is weird, especially considering]
let new-obj [obj]
[but you should remember that [new-obj] is still [obj]. All the earlier aliases are still valid.]
[Then again...]
let new-obj val-of [obj]
[This is broken.]

[I don't want [.] to be a special character... but it would be so good if I could do this.]
let obj []
set [obj.name] "something"
[I guess I should do this?]
set-field obj [name] "something"
[Honestly, there's no real reason not to.]
[I should and I will.]
[It's not a special character, of course.]
[The [set] function simply choose to treat it specially.]

[Passing a struct to a function should not copy the whole struct, that way I don't have to worry
about adding fields to it.]
[If the language follows a pattern, it will become something precise. otherwise, it's all just a
list of [Any].]

[What if...]
* 3 [] -> malloc * 3 sizeof [indeterminate]

[I hate it, but I really need to separate [let] destructuring and multiple assign. It's too
confusing otherwise.]
[Maybe I should consider {} again?]
[Or... I just give up on destructuring? Is it really that needed? Right, destructuring was for
multiple return.]
[The biggest problem is the function call syntax. How about I use [:] as the syntax for calling a
function?]
main() [vs] (main) [vs] main:
[The biggest gripe I had with () is that the argument count is forced.]
[I think the trick to multiple return values might be implicit return?]
[If I add [:], that means i won't need two text types anymore.]
return: [1 2 3] [vs] return text "hello" [?]

[Technically, there is still text and [text], it's just that [let] does automatic assignment for
[var:], of type text.]
==: [... [:] is a last resort.]
[also]
let: f complex [and] let: f [complex:] [are redundant]
[[return text "hello"] returns a string, [return [print "hello"]] returns multiple values or a
function, depending on the receiver.]

[I'm having another crisis.]
((func1) 1 2 3)
(display (func1))
[How do I do this is my language?]
func1:: 1 2 3
display: func1:
[Nah, this sucks.]
((func1 'field1) "hello")
(display (func1 'field1))
func1 [field1] "hello"
print [func1 [field1]]
[Or not? Maybe I can do this.]
[The only difference is that scheme returns the pointer to the function, which can be called, or
passed around, and I create lambdas.]

print "Hello, World!\n"
print: "Hello, World!\n"
let f complex 3 4
let: f complex: 3 4

[Wait a second, I can do arrays!]
let arr [
    let [index] args
    cond [
        (= index [0]) 123
        (= index [1]) 312
    ]
]
print arr[0]
[I mean right?]
[Still, assignment...]

[You know, why not?]
set arr[0] 4312
[Because you're setting [arr] to [0]. That's why.]
[I think I should focus on first doing everything scheme can do. Otherwise, I'm going to get
overwhelmed.]

[I really need to figure this out...]
let func [
    return [text "hello"]
]
print func [outputs "hello"]
let func [
    return [text "Hello, %!\n", text "World"]
]
print func [outputs "Hello, World!\n"]
let func [
    return [+]
]
print\n func 1 2 [outputs 3]
let func [
    let val 0
    return [
        ++ val
        print\n val
    ]
]
print func 1 2 [outputs 3]
[Uh...]

let f [return [1 2 3]]
let f [return "Hello, World!\n"]
let f [return [+ 1 2]]

print f [outputs "1 2 3"]
print f [outputs "Hello, World!\n"]
print f [outputs "+ 1 2"]
[equivalent to]
print [1 2 3] [outputs "1 2 3"]
print "Hello, World!\n" [outputs "Hello, World!\n"]
print [+ 1 2] [outputs "+ 1 2"]

(print (f))
print: f:
print $f
[Ahh... AHHHH. ARRRHHGGHGHAGS!!!!!!]

[Multiple return, returning functions, returning strings...]

let f [
    return { print "Hello, World!\n" }
]
let f [
    return [ 1 2 3 ]
]
let f [
    return "Hello, World!\n"
]

let val0 (+ 1 2)
let val1 {+ 1 2}
let val2 [1 2 3]
let val3 "Hello, World!\n"

print\n val1 [outputs 3]
print\n val2 [outputs [1 2 3]]
print\n val3 [outputs "Hello, World!\n"]

let f {
    return [1 2 3]
}
let [a b c] f
[equivalent to]
let [a b c] [1 2 3]

let f {
    return { + arg 0, arg 1 }
}
print f [outputs { + arg 1, arg 1 }]
[Functions that are returned are never executed.]
[As opposed to this.]
let f {
    return + arg 0, arg 1
}
print f 1 2 [outputs 3]
[I guess... You can only really really return numbers and strings?]
print f "test " "123" [outputs "test 123"]

set [arg 1] 69420
[huh]

let map [
    if (arg 1) [pair do (arg 0) (arg 1), map (arg 0) tail (arg 1)] []
]
map [* 2] [1 2 3 4 5]
let map [
    let [f lst] arg 0, arg 1
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[Things are so much simpler when I don't do destructuring.]

[Wait a second.]
let map [
    let [f lst] split args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[I mean I could, right? Did I fix it? Just like that?]
[And it just makes sense, right? Like with [as].]

[Should I use [..] instead?]
let map [
    let [f lst] .. args
    if lst [pair do f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[Yeah I should.]

[If order of assignment doesn't matter, I can do forward [goto]!]

[Technically, [..] has the same purpose as [do].]
let map [
    let [f lst] .. args
    if lst [pair .. f lst, map f tail lst] []
]
map [* 2] [1 2 3 4 5]
[It remove the [].]
[Then again, no. [do] creates a new scope.]
[But [..] doesn't? I don't know about that.]
[There's no reason for it not to create a new scope.]
[But it might be intersting for it not to.]
[Better than [do-here], that's for sure.]

[Also, this would break the [..] function.]
map [
    let [x y] 2, arg 0
    * x y
] [1 2 3 4 5]

[Still, I ended up breaking [#import]. I don't know how to fix it while keeping the behavior the
same.]
#import "System/IO"
let io #import "System/IO"
[like this?]
.. #import "System/IO"
[You know, at this point, why not? Fuck it.]
[It makes sense. It's not as nice, but it makes sense.]

.. #import "Basic"
.. #import "File"
.. #import "String"
[vs]
#import "Basic";
#import "File";
#import "String";

[Honestly, Jai's imports are nice, but they don't make that much sense. I prefer consistency.]

[Though it's weird, I should be able to do this.]
map [.. #import] [
    "Basic"
    "File"
    "String"
]
[or rather like this]
.. map [.. #import] [
    "Basic"
    "File"
    "String"
]

[By the way, [...] is still the error not implemented function.]

[[let] should return the value that's passed to it.]
let x let y 0
print\n [x y]  [outputs [0 0]]
[This is clearly wrong...]
[But something tells me this should be right.]
[The weird usage of [print\n] I mean.]
[No, there's a better way of doing this.]
print\n reduce [x y]  [outputs [0 0]]
[Having no need for new syntax is always a good thing.]

[From now on, if variable is passed to function, it should always be equivalent to passing the
literal directly. No need for surprises.]
let [val] "hello"
print val
[equivalent to]
print "hello"
[and this for every function.]
[that does mean I will have to change my for loop logic...]

[Also, I just realized an interesting mnemonic.]
[I thought of it as something ugly before, but now it's better.]
let val [print]  [type = text]
let [val] "print"  [type = [text]]
[See the resemblance?]

[How do define [arg]?]
let arg [
    let index (get 0 args)
]
[Damn, the one time I need a dynamic scope.]
[Wait.]
let arg [
    let index (get 0 args)
    return get index #args
]
[Two [args] variables. One static, the other dynamic.]

[By the way, for trailing comment, two spaces beforehand.]

atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

let fib [
    let n arg 0
    if or = n 0 = n 1
        [n] [+ fib - n 1 fib - n 2]
]

let obj [
    match word 0 [
        [field1] 123
        [field2] [print]
    ]
]
print\n obj[field1]  [outputs 123]
let set-field [
    let field arg 0
    let old arg 1
    let value arg 2
    let [new] [
        if = arg 0 field [value] [old]
    ]
    set old new
]
set-field [field1] [obj] 321
[And this would of course be optimized away.]

[It should behave more like this.]
set-field obj field1 321
[or like this?]
set [obj field1] 321
[but it also breaks the [#import]s. But it's also more elegant in a way.]

[The [obj field] also solve the chaining problem. I need to make it work.]

[Holy fuck.]
let fib [+ fib (- arg 0 1), fib (- arg 0 2)]
set [fib 0]
set [fib 1]
[^ a Haskell.]
[Also, [set] should not change the type.]

[I shouldn't abuse of parentheses. One of the purposes of this language was to be rid of the
accursed parentheses.]

[The LSP can use the indentation of the code to check if the obj field calling is erronous.]

[Initializer]
let val int []
let val int 123

let [val] [for 30 int []]
print\n get 0 val
let val (array 30 int [])
print\n val 0
[I don't know how I'll do it.]

[[#import] returns a [text] with an environment, right? Why not have a function that operates on
that? And convert the environment into an object function?]

let set-name [
    set [obj name] arg 0
]
print\n set-name "John Smith" [outputs (function body)]

[old] my-list iter filter fn [item] == item id 132 collect
print\n (my-list iter filter [= (do (arg 0) id) 132] collect)
let obj [my-list iter filter [= (do (arg 0) id) 132]]
print\n obj collect
[This works, though it's stupid.]
[Well, when you don't have overloading, you gotta do what you gotta do.]

[[iter] is only there to avoid name conflicts.]
set [my-list iter filter] [
    filter arg 0 my-list
]
[but how do I return a plain string?]

[[arg []] returns the full list?]
[but then [arg 0]...]
[...]
[one based indexing!?]

[I should try implementing infinite lists.]
for range [0 infinity] [print\n it]

[Should [let] differenciate [] and ""?]
[And no other function does it?]

let number 123
let func [print "hello"]
let str "hello"
[yeah, but...]
let array [1 2 3]
[... doing so introduces unnecessary complexity.]

[Instead, [cond] should just be like [if], always evaluating a function body.]
let condition true
if condition [
    print\n "It's true."
] [
    print\n "It's false."
]
cond [
      condition [print\n "It's true." ],
    ! condition [print\n "It's false."],
]
[Yeah, I'm doing this. Not to mention that's it's more consistent with [if] this way.]
[And you know. The body of [if] just makes sense for lazy evaluation.]

set [obj field] [text "Hello, World!\n"]
print\n obj field
[Because [set] does not change the type, any reassignment has to be the same type.]
let [my-str] "hello"
set my-str [hello]  [-> type [text]]
let my-func [print "hello"]
set my-func [print my-str]  [-> type text]
[... Or not?]
let [str] "hello"
set [str print\n] [print\n str]
print\n str
str print\n
[Every function can behave as a string, but not every string can behave as a function?]

let arr [1 2 3]
set [arr 1] [get 1 arr]
print\n arr
print\n arr 1

[I got it.]
set val [print "hello"]
set [val] "hello"
set [val say-hello] [print "hello"]
val say-hello  [outputs "hello"]
set [val [say-hello]] "hello"
print\n val say-hello  [outputs "hello"]
set [val [say-hello number]] "hello" 123
print\n val number  [outputs 123]
[Nevermind about [set] not changing the type.]

for 1 .. 10 [print\n it]
set [number ..] [range [number arg 0]]

[If you have called [let] beforehand, it's alright. [set] it for you.]
set [obj field] 123
[is equivalent to]
let obj []
set [obj field] 123

[Nevermind.]
[Fields always call functions.]
[That way, I can do this.]
set [obj "John Smith"] [
    return [
        123
        312
        [other data]
    ]
]
obj "John Smith"

let file (#import "File" open-file "./file.txt")
let file [#import "File"]
let content (file open "./file.txt")
context add (#import "File" context)
[Zig style imports... I need to figure them out.]

this context
that context

let open [#import "File" open]
let File [#import "File"]
let open [File open]
[maybe I don't need to import everything?]

[You know, if you program with discipline, you won't need to worry about name conflicts.]
[Objects shouldn't have too many nested fields.]

[The more I think about these Zig style imports, the more I like them.]
let File [#import "File"]
let file File open "file.txt"
File fscanf [file] "%d %d " val1 val2
[[val1] and [val2] should need to be explicitly declared. Though, these C-style mutations should be
avoided.]

[Ah damn.]
let [val1 val2] [] []
do [
    set [val1 val2] .. File fscanf [file] "%d %d "
]
print\n val1
print\n val2
[This is awkward.]

use [#import "File"]

let-key val1 [field1] [
    print "Hello, World!\n"
]
set-key [val1] [field2] [print "Hello, World!\n"]

val1 field1        [outputs "Hello, World!\n"]
print val1 field2  [outputs [print "Hello, World!\n"]]

[no.]
set [arr 0] 123
set [arr 1] 321
print\n arr 0
print\n arr 1
[it needs to match.]
[but then the awkward scoping assignment...]

[I guess this fixes it?]
set-key [arr 0] 123
set-key [arr 1] 321
print\n arr 0
print\n arr 1
[or just]
let arr []  [optional, but available for reset of all fields.]
key [arr 0] 123
key [arr 1] 321

[I guess [key] is also like an upsert? Or should [set] just create a new variable if not bound?]
[I guess [key] behave the same as [set] when there's only one variable?]
[Or not? Maybe [key] always takes text as functions, while [let] takes as strings?]

[No, [key] behaves the same as [let] when only one input, as [set] when more than one.]
let [str] "Hello, World!\n"
key [func] [print "Hello, World!\n"]

let [str number] "Hello, World!\n" 123
key [obj field] [print "Hello, World!\n"]

[This is nice though.]
let str "Hello, World!\n"
key func [print "Hello, World!\n"]
[or this?]
var str "Hello, World!\n"
let func [print "Hello, World!\n"]

var [str num] "Hello, World!\n" 123
let [obj field] [print "Hello, World!\n"]
let [obj field] "Hello, World!\n"
let [obj field] [text "Hello, World!\n"]
let [obj field] [1 2 3 4 5]
let [obj field] [text [1 2 3 4 5]]

[You know, if I just drop multiple assignment, like Scheme, this would be much easier.]
[If functions return multiple values, then just return a struct/array or something.]
[But no. I need multiple return for args.]
var [arg1 arg2] .. args

[Honestly, I hate it, but using different functions for multiple assign and function assignement
and object construction just makes more sense.]
[The real question is whether [let] should have both function and object assignment.]
[I'm guessing yes, otherwise there will be too many functions for every little thing.]
[String and quotes are common enough to justify seperating assignment into two functions.]

[The other question is should I make it more like scheme, and just omit objects?]
[All you really need is a list in the end.]
[And the whole obj model is kind of a pain with macros and stuff.]
print obj field
print Object.field obj
[The latter is longer, but there is no ambiguity.]
print Object.field obj
print Object/field obj

[But what about [#import]? It's broken again?]
[Does it just return a table of key/value pairs? An environment?]
[RIP, zig imports.]
[Yeah, lists and selectors just make better objects.]

[raku]
my &func = {
    my ($val1, $val2) = @_;
    print "Hello, World!, $val1, $val2\n";
}
func 1, 2;

[this]
let func [
    let [val1 val2] .. args
    print "Hello, World!, %, %\n" val1 val2
]
func 1 2

[Shockingly, as a whole, this language has fewer characters?]

let [my-vector] [1 2 3]
print "x = %, y = %, z = %\n" .. my-vector  [outputs "x = 1, y = 2, z = 3\n"]
print "x = %, y = %, z = %\n" Vector.x my-vector, Vector.y my-vector, Vector.z my-vector
let Vector.x [nth 0 arg 0]
let Vector.y [nth 1 arg 0]
let Vector.z [nth 2 arg 0]
[I should keep [arg n].]

[[#] for dynamic scope?]

[This really, really sucks, but I might have to do imports, not the Jai way, not the zig way, but
the odin way...]
#import "File"
open "my-file.txt"
#import File "File"
File.open "my-file.txt"
[Well, not exactly like odin.]

[Or different from anything else?]
let open (get "open" #import "File")
open "file.txt"

let [File] #import "File"  [File -> a table of key/value pairs.]
let open get "open" File
open "file.txt"

[[get] gets the nth element if the index is a number, or – scratch that. Tables should have numbers
as valid keys as well.]

[Should packages have [return env] at the end? Like in Lua?]

let [File] #import "File"
match [open close] File
open "file.txt"

[I guess the values should just maintain there type, which is why [match] works, but what about the
earlier combination of [let] and [get]?]

[I guess this is how a table would print.]
[
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
match [value1 value3] #import "test-module"
print\n value1
value3

[[match] actually extract a level of quotation.]
let [test-module] #import "test-module"
match [value1 value3] test-module
[is equivalent to]
let value1 get "value1" test-module
let value3 get "value3" test-module
[You can't do multiple assign, because the return is quoted.]

let func [print "Hello, World!\n"]
let [func] fn [print "Hello, World!\n"]
[But how do I implement this?]
[I guess it's similar to [..], but unlike it, does separate the return into different entries in
the stack.]

let [MyInterface] [
    name
    age
    [value1 value2]
]
make "MyInterface" MyInterface

let [value] ["hello" 123 [321 "something"]]
print\n MyInterface.name value  [outputs "hello"]
MyInterface.name! value "hello again"
print\n MyInterface.name value  [outputs "hello again"]
[I guess this is the best. It's so simple.]

[If the input of a getter/setter is a number, it treats it as a pointer to a struct, otherwise as a
value.]

make "MyInterface" [
    value1
    value2
    [value3 value4]
]
let [obj] ["hello" 123 [321 "something"]]
print\n obj
print\n MyInterface.value1 obj
MyInterface.value1! obj "bye"
print\n MyInterface.value1 obj

print\n MyInterface  [outputs [value1 value2 [value3 value4]]]

for MyInterface [
    use MyInterface
    print "% = %, " it, do it obj
]

struct "File" #import "File"
[Nevermind, "struct". I don't like duplicates.]
#import-as "File"
[But then again, there's no choice. What if you want to rename it?]

to-obj "File" #import "File"
let [file] File.open "file.txt"
use File.interface
print\n File.name file  [outputs "file.txt"]

to-obj "obj" MyInterface obj

[Okay, far simpler.]
#import "File"
File.open "file.txt"
use File
open "file.txt"
use #import "File"

[Oh.]
#import "File" as "F"
[What's going on here?]
[Well, [as] looks at the latest values added to the environment, and mutates the names.]

[Nevermind. Too complicated to implement.]
#import [File F]
[This though...]
[Hmm. It's better, because there is less noise/duplicates. There won't be fields named both
[File.something] and [F.something] at the same time.]
[Still, it would be interesting if it both has side-effects and return an environment at the same
time.]

[Maybe strings should implicitly return?]
let [val] if condition ["true"] ["false"]

# Maybe strings should implicitly return?
let [val] if condition ["true"] ["false"]

# Yeah. That might be better, because otherwise you can't do this.]
make "MyInterface" [
    value1  # Only for value4
    value2
    [value3 value4]
]

table->obj "File" import "File"

print\n MyInterface  [outputs [value1 value2 [value3 value4]]]
print\n MyInterface  # outputs [value1 value2 [value3 value4]]

# Still, if I do add [#], that means adding syntax, and abandonning [#args] or [#import].
# But frankly, I never liked how numbers and functions implicitly returned, and text did not.
# And what's up with [#import]? Why does it have a [#]?
# Also, [#!/path/to/interpreter] is now possible.

object "my-obj" [
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
my-obj.value1

# There are two ways of doing objects:
# - Tables
# - Lists with getters/setters

# I suppose this is still possible?
let func [
    object "obj" .. args
    print\n obj.value1
]
func [
    [value1 123]
    [value2 text "Hello, World!\n"]
    [value3 print\n value1]
    [value4 print value2]
]
# But I guess, you can't just use [set] on it.

# I'm really warming up to [#] for comments. It looks so nice.

# I should probably not use tables as struct, since they very much have a runtime overhead.
# Tables are more for dynamic stuff.
# Structures as lists make more sense, since they actually match the implementation.

# [rename] function
let [val] "hello"
rename "val" "value"
print\n value  # outputs "hello"
print\n val  # error: not bound

# size (in bytes)
# count (number of elements in list)
# length (length of utf-8 string)

for chars "Hello, World!\n" [print it]
# equivalent to
print "Hello, World!\n"

for chars "Hello, World!\n" [print it]
for chars "Hello, World!\n" as c [print c]

let str ["Hello, World!\n"]
let [str] "Hello, World!\n"
print str
# both are equivalent to
print do ["Hello, World!\n"]
# damn, this actually looks really nice.

let func [
    let [arg1 arg2 arg3] .. args 3
]
# ^ this is the lazy way of doing things.
# there's no way of consuming arguments otherwise.
# hmm.
let next-arg [top-args 1]

# the best.
let func [
    args [arg1 arg2 arg3]
]
# functions use arguments so often, it would be dumb not to do this.

let square [* .]
print\n square 5  # outputs 25
# [*] and [.] should not exit the scope, even if the args are outside it.
# that's why this works.
let test [
    let value 25
    do
]
test print\n value  # outputs 25
# although... it only works for once function call, which is good!
test [
    print\n value  # outputs 25
    print\n square value  # outputs 625
]

# oh!
args 3  # returns list of eager arguments
args [arg1 arg2]  # returns nothing. sets symbols to [.. args 2]

args 0   # returns all the args in a list.
args []  # same here because 0 == [].

# maybe [do] should only pop the scope when there is a quote?
let test [let value 25; do]

test [print\n value]  # outputs 25
print\n square value  # error: "value" not bound

test
print\n value         # outputs 25
print\n square value  # outputs 625

# yeah, this is the best. I still have the behavior where the scope gets poped, and can still
# include multiple function calls in it, but now I have a way to include the rest of upper scope
# without putting it in [].

# nevermind... what if a function returns a string?
# in fact, every function either return [] or something else.

let test [
    pop  # or maybe [done]? you know, to pair with [do] which creates a scope?
    let value 25
]
# yeah, but pop is called automatically at the end so...
let test [
    pop-scope
    let value 25
    push-scope
]
# ugly.
let test [
    done [let value 25]
]
# now that's better.

# for popping multiple scopes?
done 2 []
# or I guess it doesn't really pop them, otherwise this wouldn't work:
let test [
    let value 5
    done [let value 25]
    print\n value  # outputs 5
]
# All it does is set the environment.

# this only works if [let] returns nothing.
if let value ! % 2 . 5 [
    print\n value
]

let test1 [
    print\n "hello"
]
let test2 [
    print\n "hello"
    return []
]
print\n test1  # error: no argument found.
print\n test2  # outputs ""

# but what about...
let value if condition ["hello"] []
# do I need to write it like this now?
let value if condition ["hello"] [[]]
# still, the fact is that you can do this.
print\n * . 5  # outputs 25
# you can have functions that return multiple values.
# so why not functions that return nothing?
# I should figure out how to define [.]

let square [* .. .]
# if [.] returned [val val].
# but no, [..] also returns multiple values.

# this is how it should work.
let test1 [
    print\n "hello"
]
let value test1 5
print\n value  # outputs 5

let multiple [
    return .. [123 321]
]
let multiple [123 321]
let [a b] multiple
print\n "% %" a b  # outputs "123 321"

let multiple [
    123 321 return
]
# If I allow this way of doing multiple returns, then things will be more terse in some part, but
# also more verbose in others. And I'll have to use discards everywhere now...

# What's going on here?
let [a b] .. [1 2 3]
# Is 3 discarded?
# But it's a good thing no? It's more explicit. I know people like explicit.

# Should I call [] a set?

# What about a function that only runs if a function that normally never returns suddenly does, and
# therefore executes the code that's passed as a body? Like for an error?
# I don't know.

# [digits] function
print\n digits 123  # outputs [1 2 3]
# what about hex and bin?

# damn, there's actually a use for true/false constants.
let true  [u8 1]
let false [u8 0]

# it's only natural for a function that can take multiple inputs to be able to have multiple
# outputs as well.

let test [
    print\n value
    let [value]
]
test 5  # outputs 5
# nevermind. this only works for functions because they are 'strings'.
let test1 [test2]
let test2 [test1]
# this wouldn't work.
let test1 test2  # error: "test2" not bound
let test2 [test1]

let multiple [123 321]
let [a b] multiple
let [a] multiple  # discards 321
let a multiple    # discards 321 as well?
# if feel like it should.
# thing is, I really need use cases to make a decision.

if let a multiple []
# vs
if let a . 5 []
# [. 5] is a function like [multiple] that returns two things.
let a multiple  # should not discard 321 then.

# honestly, I'm not really liking this [if let] syntax.
if let a swap % 2 . 5 [] # i have to do stupid shit like this.

# maybe [let] returns the updated environment? so I don't have to do [return env]?

print\n list multiple  # outputs [123 321]
# takes any number of returns from function call and puts it in a list

let test [1 2 3]
print\n + - test  # outputs 2 -> (1 - 2) + 3
let test [1 2]
print\n + - test 3  # same as above

fold-left [+] 0 [0 1 2 3 4 5]
fold-left [+] 0 [0 1 2 3 4 5]

let [] func-call  # needs to discard.
# and I guess it's fine if it's the only thing that discards?
# also, I guess if a function explects an input but gets nothing, then there will be hell to pay.
let test []
print\n test  # error: passed void as argument

let multiple [1 2]
let test [
    args [a b c]
]
test multiple 3  # this should work.

let multiple [1 2 3]
let [] print\n - multiple  # outputs -1
# or
clean let [value] - multiple
print\n value  # outputs -1
# should I just not have the ability to discard?
let [a b _] multiple
print\n _  # outputs 3
# it's just a convention. it could be any name.
# [_] just keeps getting reassigned to 'discarded' values.
# this is probably the best. [let] now behave like all the other functions.

# but then what does this do?
let [] multiple
# it could throw, but I thinks it's better for it to just not do anything.
# it's equivalent to
multiple

let [byte-arr] map [u8] [1 2 3 4 5 6]
# then again...
let [byte-arr] u8 [1 2 3 4 5 6]
# all you need is an overload.

# actually, nevermind for [list].
let multiple [1 2 3]
print\n [multiple]  # outputs [multiple]
print\n reduce [multiple]  # outputs [1 2 3]

# [<>] instead of [swap]?
let multiple [1 2]
let [a b] swap multiple
let [a b] <> multiple
# or even
let [a b] >< multiple
# nah. [swap] is better.

let [quoted] [print "Hello, World!\n"]
print\n quoted  # outputs [print "Hello, World!\n"]
to-fn quoted
quoted  # outputs "Hello, World!\n"

let [arr] [1 2 3 4 5 6]

print\n first 3 arr  # outputs [1 2 3]
print\n first   arr  # outputs 1

print\n last  5 arr  # outputs [2 3 4 5 6]
print\n last -1 arr  # outputs [2 3 4 5 6]
print\n last  0 arr  # outputs [1 2 3 4 5 6]

print\n half   arr  # outputs [[1 2 3] [4 5 6]]
print\n half 0 arr  # outputs [1 2 3]
print\n half 1 arr  # outputs [4 5 6]
# [first] and [last] work. I still need to think about [half].

# constant just capitalized for the same reason that [_] is used as a discard variable.
# it's all convention. no need to actually change the language to add these "features".
# though again, you can add them; just not through the default channels.

# I still can't get over this. so simple, yet so smart.
let multiple [1 2 3]
let [a b _] multiple
let [a _ _] multiple
let _ test
let [val err] test
let [val _] test
let err drop test  # [drop] takes one argument, and returns nothing.
let drop [args [_]]
# nah, this is better.
let [_ err] test
# or this.
let err let [_] test
let drop [let [_]]

# Go
import (
	"fmt"
	"os"
)

func main() {
	// Try to open a file
	file, err := os.Open("example.txt")
	if err != nil {
		// Handle the error
		fmt.Println("Error opening file:", err)
		return
	}
	// Don't forget to close the file
	defer file.Close()

	fmt.Println("File opened successfully")
}

# this
import "File"

let main [
    # Try to open a file
    let [file err] File.open "example.txt"
    if err [
        # Handle the error
        print\n "Error opening file: %" err
        return
    ]
    # Don't forget to close the file
    defer [File.close file]
 
    print\n "File opened successfully"
]

# maybe I should seperate imports and uses?
import "File"
use [File]
# but again, I don't like repetition for such common operations, so no.
# the problem is what [import] returns.
# if it returns something, thing will become pretty dirty, pretty quick.
let [_] import "File"
drop import "File"

use [File System Graphics Core]
# i think this is the best. it also encourages the use of [use].

let [file err] File.open "example.txt"
defer File.close file
# vs
let [file err] File/open "example.txt"
defer File/close file

# [.] looks kind of better with ["].

# oh shit.
let import [
    args [file]

    if ! between count file, 1, 2 [
        error [usage = [import "module-name optional-rename"]]
    ]

    let [content] read-file get 0 file
    module get 1 file
    done [add env, get 0 file, content]
    done content
    module ""
]
# damn, this is actually so simple.
# I think you can omit the ending [module] call.
# unless it is in a [done] call. then you have to include it, unless you want the effect to be
# included in the outer scope.

let use [
    for args 1 [
        done 2 [do it]
    ]
]
# [for] should automatically call reduce on the array that's passed.
# you can still iterate of symbols, but you have to quote them first.
for quote args 1 [...]

print\n quote [1 2 3]  # outputs ["1" "2" "3"]
let arr [1 2 3]
print\n quote arr  # outputs ["1" "2" "3"]
print\n quote [print "hello"]  # outputs ["print" ["hello"]]
print\n quote 123  # outputs "123"?
# or should I do this?
print\n quote 2 [1 2 3]  # outputs ["1" "2" 3]
# I don't know. I don't see much use from this.

let test [args 3]
test 1 2 EOF  # error: invalid argument count. expected 3, got 2

# I like the idea that because the functions are so general, you can get some "happy accidents"
# from it. functionality you didn't expect, I mean.

# does this throw?
get 1 [1]
# it should. so...
get-or 1 [1] []
get-or-nil 1 [1]

# I guess [] and 0 should be equal to each other. otherwise...
+ [] 2
+  0 2
# what should I do?

let [arr] []  # null pointer?
set 0 arr 5  # [5]
set "val1" arr 6  # [5 [val1 6]]
# cannot have numbers as keys then.

print\n get "val1" arr  # outputs [val1 6]
print\n key get "val1" arr  # outputs "val1 6"
print\n value get "val1" arr  # outputs 6
print\n get-key "val1" arr  # outputs "val1"
print\n get-val "val1" arr  # outputs 6
# [get-val] runs the function if it is one.

set "val1" arr [print\n "hello"]  # to set functions
set "val1" arr ["hello"]  # to set strings
# or
set "val1" arr fn ["hello"]
set "val1" arr "hello"

even? [1 2 3]  # false, because list count is not even

add arr [val1 hello]  # though it doesn't check for duplicates...

let [str] "hello"
set 2 char str "x"
print\n str  # outputs "hexlo"
# but [char] should probably copy it.

let [str] char "hello"
set 2 str "x"
print\n str  # outputs ["h" "e" "x" "l" "o"]
print\n to-str str  # outputs "hexlo"

# I just realized. I don't need [get-key] – because it's stupid – but also [get-val] because that
# should just be [get].
let arr []
set "value" arr 123
print\n get "value" arr  # outputs 123
# fuck. I just realized. I can't use [set].

let arr []
set [arr] at 0 arr 123
set [arr] at "test" arr 321
print\n arr  # outputs [123 [test 321]]
# or
let-at 0 arr 123
set-at "test" arr 321
print\n arr  # outputs [[0 123] [test 321]]

# I know.
let arr [[] [] []]
set 0 arr 123
set 2 arr 321
print\n arr  # outputs [123 [] 321]
set [0 2] arr 4
print\n arr  # outputs [4 4 4]
# nevermind. I don't know.

key 0 arr 123
key "test" arr 321
print\n arr  # outputs [[0 123] ["test" 321]]
print\n get "test" arr  # outputs 321
# the key cannot be a symbol
let n 0
print\n get n arr  # outputs 123

set 2 123  # error: not bound [2]
let 2 123
print\n 2  # outputs 123
# lol.

let [arr] reduce [* 3 []]
set-at 2 arr 123
print\n arr  # outputs [[] [] 2]
# if the array was empty, it would not check if the index was out of bounds, like C.
print\n at 2 arr 123  # outputs [[] [] 2]
# [at] return, doesn't mutate.

set-at [1 0 2] arr 123 321 333
print\n arr  # outputs [321 123 333]
set-at [1 0 2] [arr1 arr2] 123 321 333
set-at range [0 2], arr, .. range [10 12]
# now I need to figure out arr vs [arr].

let val 123
let [val] 123

let func [print "hello"]
let [func] fn [print "hello"]

let [str] "hello"
let str "other hello"
print\n hello  # outputs "other hello"
# alright, from now I'm quoting the symbol passed to [let] as well.
# I can always go back if I don't like it. still, I should try this consistency thing.

let [import] fn [
    args [file]

    if ! between count file, 1, 2 [
        error [usage = [import "module-name optional-rename"]]
    ]

    let [content] read-file get 0 file
    module get 1 file
    done [add env, get 0 file, content]
    done content
    module ""
]
# doesn't change that much, honestly.

import "File"

let [main] fn [
    # Try to open a file
    let [file err] File.open "example.txt"
    if err [
        # Handle the error
        print\n "Error opening file: %" err
        return
    ]
    # Don't forget to close the file
    defer [File.close file]
 
    print\n "File opened successfully"
]
# not much at all.

let [arr] reduce [* 3 []]
set-at 0 [arr] 123
print\n arr  # outputs [123 [] []]
let [index] 2
set-at [0 index] [arr] 123 321
print\n arr  # outputs [123 [] 321]

let [arr] []
set-key "hello" [arr] 123
set-key "bye" [arr] 321
print\n arr  # outputs [["hello" 123] ["bye" 321]]
print\n get "bye" arr  # outputs 321
print\n get 0 arr  # outputs ["hello" 123]
set-key 0 [arr] 666
print\n arr  # outputs [["hello" 123] ["bye" 321] [0 666]]
print\n get 0 arr  # outputs ["hello" 123]

# hmm.
let [arr] []
set-at "hello" [arr] 123
set-at "bye" [arr] 321
print\n arr  # outputs [["hello" 123] ["bye" 321]]
set-at 0 [arr] 123
print\n arr  # outputs [123 ["bye" 321]]
# good. this fixes the [set-key 0] problem.

# I shouldn't allow number assignment. if it's more code to add such a stupid feature, I'm not
# doing it.

let [test] fn [
    print\n args 0
]
test 1 2 3 4  # a random comment.
print\n "Hello, World!\n"  # another random comment.

# this should print something like [1 2 3 4 print\n "Hello, World!\n"].
# the comments are of course ignored. I guess that's how you do metaprogramming?
let [meta] fn [
    print\n first args []
]
meta hello world  # outputs "hello", then error because "world" not bound
# or rather...
let [meta] fn [
    print\n first quote args 0
]

let [test] fn [
    for args 0 [
        if = "end" it [
            break
        ] [
            print "%, " it
        ]
    ]
    print \n
]
let [\n] "\n"
test 1 2 3 4 5 6 [end]  # outputs 1 2 3 4 5 6

let [break-list] ["for" "while" "loop"]
let [break] fn [
    pop-until [contains this break-list]
]

let [for] fn [
    args [list body]
    let [it] first list
    do body
    for last -1 list, body
]

let [it] 6
for [1 2 3] [print\n it]  # I guess [it] shouldn't be 6?
# does the static scope only work when [fn] is called then?

let [func] fn [for [1 2 3] [it]]
# equivalent to
let [func] fn [1 2 3]
let [func] fn [1 2 3]

let [test] fn [
    print\n this
]
test  # outputs "test"

do [
    print\n this
]  # outputs ""

let [test] fn [
    let [here] this
    if true [
        goto here
    ] []
]

# maybe [do] only takes strings as functions, numbers as the level.
do [
    let [x] 5
]
print\n x  # [error] not bound: x
do [
    do 1 [let [x] 5]
]
print\n x  # outputs 5

do fn []  # [error] scope level too high
# or not. [fn] should return a string. so...
do fn []  # [error] argument not quoted
# or something.

# everything is a string.
let [val] 123
char *val = "123";
let [val] [123]
char *val = "[123]";
let [val] [print "Hello, World!\n"]
char *val = "[print \"Hello, World!\n\"]";
let [val] fn [print "Hello, World!\n"]
char *val = "print \"Hello, World!\n\"";

do val  # will equally run a string as if it were a function

let [_] [this is a comment, lol.]
drop [this is a comment, lol.]

# string manipulation needs to be hella good, because it's also code manipulation.

do 0 [
    let [x] 5
]
print\n x  # outputs 5
# this is equivalent to the old [do-here].

# [head]/[tail] vs [first]/[last]?
# and [tail] defaults to -1 for the input.
# I'm still torn on what to do for an input of 0.

let [set-at] fn [
    args [key var value]
    do 1 [
        set var, at key (do var) value
    ]
]
set-at "hello" [arr] 123
# so easy!

let [at] fn [
    args [key var value]
    reduce [
        for var [
            if = head it, key [
                [head it, value]
            ] [it]
        ]
    ]
]
# wait, but how do I do [at (number)]?

# comparing an array or a list is just a [strcmp], lol.

print\n bool = 0 []   # outputs "false"
print\n bool = 0 [0]  # outputs "false"

print\n bool == 0 []   # outputs "true"
print\n bool == 0 [0]  # outputs "false"

let [null] u64 0
let [value] []

print\n bool == null value

# actually...
print\n bool == 0 []   # outputs "false"
print\n bool == 0 [0]  # outputs "false"
# because "0" and "[]" are seperately allocated strings.
# I guess [==] is check for reference and reference only. so...
print\n bool =  0, ptr []  # outputs "true"
print\n bool == 0, ptr []  # outputs "false"
# [=] is just strcmp. I can make better in the future, but not now.

let [hello] fn [print\n "hello"]
print\n reduce 1 [hello]  # outputs [print args 1; print \n]
print\n reduce [hello]  # outputs [exec 1010101010101101]... something like that.
# or not? because...
let [vars] [a b c]
let vars 1 2 3
print\n vars  # outputs "a b c"
print\n reduce vars  # outputs "a b c"
print\n reduce vars  # outputs [1 2 3]
# right, I see the problem. [reduce] actually execute the code! it just doesn't return.

# honestly, a function passed arg that returns nothing should just take another argument.
# then again... I just don't see a use case. most cases are bugs!

# maybe I should write a [strcmp] that ignores syntax chars?

# I don't know if I can do [goto] in this language. at least not the high level unoptimized version
# of the interpreter. if I do implement it, it need to be as powerful as C's goto: can go up a
# scope, backwards, forwards, down a scope – all the directions. if it can't do that, it's not
# worth having in the language. and honestly, since everything is recursion now, I guess I don't
# even need it? I don't know, I don't know.

[-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-]
[ ASSIGNMENT                                                                                      ]
[-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-]

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-#
# ASSIGNMENT                                                                                      #
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-#

# honestly, this time, the [] win. they somehow look nicer.

let [table] [
    "my-str" 123
    "another value" "Hello, World!\n"
    "do-something" fn [print\n "hello"]
]
print\n get "another value" table  # outputs "Hello, World!\n
get "do-something" table  # ... how do I run this?
do get "do-something" table  # not this, [do] only accepts strings.
let [table] [
    "my-str" 123
    "another value" "Hello, World!\n"
    "do-something" [print\n "hello"]
]
do get "do-something" table  # I guess?
let [do-something] fn get "do-something" table
# yeah, this is the best solution.

let [File] import "File"
let [open] get "open" File
# oh! another reason why numbers can't be keys: variables can't either.
let [my-file] open "example.txt"
write my-file "Hello, World!\n"
print\n get "filename" my-file  # outputs "example.txt"
print\n my-file  # outputs [(insert file struct/table here)]

let [open close] get [open close] File
let-get [open close] File
let-get [open close] import "File"

use import "File"
object "File" import "File"
# I don't know how make these last two though...
# How do you represent a function as a string?

let [table] [
    ["my-num" 123]
    ["another value" "Hello, World!\n"]
    ["do-something" print\n "hello"]
    ["do-again", fn [print\n "hello"]]
]
# this is probably ideal.
print\n get "my-num" table  # outputs 123

let [get] fn [
    # searching logic...
    print\n found  # e.g. [123]
    do tail found
]
let [do-again] get "do-again" table
do-again  # outputs "hello"

make "File" table
print\n File.my-num  # outputs 123
# or it throws if the key is spaced.
make "File" import "File"
make-import "File"

let [make-import] fn [
    do 1 [make import .]
]

let [let-get] fn [
    args [name]
    do 1 [let name get name]
]

let square [* .]
let [square] fn [* .]

let ^ [* .]
let [^] fn [* .]

# honestly, a function that executes the moment you [get] it, doesn't make sense.
let [table] [
    "my-num" 123
    "another value" "Hello, World!\n"
    "do-something" [print\n "hello"]
]
print\n get "do-something" table  # outputs [print\n "hello"]
do get "do-something" table  # outputs "hello"
# ah, I remember now, why this was a problem.
# how do we know if [do-something] is a function?
let [do-something] get "do-something" table  # string
let [do-something] fn get "do-something" table  # string
let-get [do-something] table  # string

# this instead.
let [get] fn [
    # searching logic...
    print\n found  # e.g. [123]
    fn tail found
]

let [table] [
    ["my-num" 123]
    ["another value" "Hello, World!\n"]
    ["do-something" print\n "hello"]
]
let [do-something] get "do-something" table  # function
do-something  # outputs "hello"

let-get [do-something] table

let [test] fn [
    let 1 [x] "hello"
]
print\n x  # outputs "hello"

let [make-import] fn [
    make 1 import .
]

let [let-get] fn [
    args [name]
    let 1 name get name
]

print\n map    [+ 5] [1 2 3 4 5]  # outputs [6 7 8 9 10]
# vs
print\n map fn [+ 5] [1 2 3 4 5]  # outputs [6 7 8 9 10]
# it's still just [[]] instead of [fn []] because it's basically typed.
# it only expects a function. nothing else.

# I need to figure out what this does.
do fn []
# before, it errored, but I don't know anymore.
let [do-something] get "do-something" table  # function
do-something  # outputs "hello"
do get "do-something" table  # ???
# logically, it should just run the function... but, that creates inconsistencies.
# a function is a string without quotation characters at the start and end.
# [do] needs to remove those characters, before running the code...
# I know.
call fn []
call get "do-something" table  # ???
# I guess I could call (lol) it something else, but it's clear that this only accepts functions.

# it should be [get-at] to make it clear that it pairs with [set-at] and [let-at].
# or not? since [at] is a standalone function, and [get] has nothing to do with it?
# [set-at] is called so because it is a mix of the two functions.

# I'll be using [let] a lot, and so if I made a mistake with the argument count a function, the
# program will pick up on that by telling me that the argument returned nothing (it's an error).
# The function will have take the [let] call as an argument and gotten a invalid input from that.

call fn [print\n "hello"]
# vs
call [print\n "hello"]
# what happens?
# I guess it returns a string?
# it's equivalent to
let [test] fn [[print\n "hello"]]
print\n test                    # outputs [print\n "hello"]
print\n call [print\n "hello"]  # outputs [print\n "hello"]
# because functions called with variables and literals should behave the same.
let [test] fn [print\n "hello"]
call fn [print\n "hello"]
call test  # ...
# maybe not.
let [test] [print\n "hello"]
call test
call [print\n "hello"]
# what now?
# no, with the variable it still returns the string of code.
# but doing the same for the literal is weird... but no matter.
# even for the variable, you usually only return one string or number.

let [value] 123
assert [= value 123]
# it's funny how easy [assert] is to implement.

# intrinsics.c vs functions.c

+ fn [123 321]  # what happens here?
# I can't proceed until I figure this out.

# let's think about it. the only function that really needs [fn] is [let].
let [test] fn [123 321]
+ test
let test [123 321]
+ test
# or not?
set-at "test" [table] fn [123 321]
# or yea?
set-at "test" table [123 321]    # function
set-at "test" [table] [123 321]  # string
# should 0 == [0]?
# because I mean...
print\n 0    # outputs 0
print\n [0]  # outputs 0
# okay, my intuition says that
+ fn [123 321]
# should be treated like
+ [123 321]
# so there should be a bool [is_executable].
# the function and string representation are the same.
+ [123] [321]
+ 123 321
+ [123 321]
+ fn [123 321]
# all equivalent?

# necessary
+ 123 321

# I should get rid of [fn] because of how much trouble it causes.
# [do] vs [..] are the same.
# the language is less consistent but cleaner without [fn].
# the only reason I added [fn] was [set-at].
# I should have [unquote] instead of [fn].
# but [unquote] can break things, so it should be used conservatively.
# the only time [fn] is used is during assignment.
let [a b c] get-token, args 2

import File, import "File", import [File FileImport]
# I guess this makes more sense with [load]?
load ./lib.txt, load "./lib.txt", load [./lib.txt lib]
# though I need this...
load ./my\ file.txt, load "./my\ file.txt", load [./my\ file.txt MyFile]
# but what about
print\n "hello"
# ?
# wait.
import "File", import File "File", import FileImport [File]
# maybe? but I really don't like repetition! I want to avoid it!!
# this model is the best one. it's the cleanest, and shortest one.
import File, import "File", import [File FileImport]
load ./lib.txt, load "./lib.txt", load [./lib.txt lib]
# I can't import only a specific few things, but who cares!
# in other languages I always did things like this.
from numpy import *
# Jai also doesn't have the ability to extract specific functions.

# it doesn't look like stack-oriented programming language, but it is.
# or stack-based?

use import-as "File"

# I will probably have to do malloc to 'capture' variables.

let str ["Hello, World!\n"]
let [str] "Hello, World!\n"
print str  # outputs "Hello, World!\n" for both.

print do ["%\n" 123]  # outputs "123\n" ?

let my\ function [print\n "hello"]
my\ function  # outputs "hello\n"
# I can't have call or assign without '\'.
my\        function  # maybe the amount of whitespace doesn't matter?

let test [
    let [var] new [hello]
    ptr-to var
]
print\n test  # outputs "hello\n"

load ./src/
# honestly, I didn't expect this.
# that was something I liked about the nix programming language. who would have thunk?

# though I should this consider this.
./src/print\n "hello"  # outputs "hello\n"
# like a shell script.
File  # is already in the PATH
# so we just need to do
use File
# or
File/open "file.txt"
# but what is [/]? is [File] a directory? a file?
let open [File/open]
let close [File/close]
# need to know how Jai does it.
# what does this do?
print\n File
# I guess there is a file called "File.txt" and a directory called "File"
# [File.txt] contains all the loads for the folder [File], though there's no real need for a
# folder. it could all be contained within the file.

# preload module?

# I'm not doing the shell imports...
# If I do, then [.] and [/] have to special characters.
# I don't know if I want that.

# then again... it would look nice.
File/open "file.txt"
let open [File/open]
use File
# where [File] is a directory.
# but what is [open]? a single file? a function within a file?
# or I guess more like zig?
File/file.txt/open
# both directories and file count in the path.

append PATH "path/to/modules"
include "path/to/modules"

# hmm, I'm not liking how .txt is removed from the thing, but I'm not liking keeping it either.
# honestly, the shell model only works if you have single file binaries.
# don't now how I would actually do that though.

# if I did make it, [/] would be like the interpolation character.
File/open
# instead of [$].
$File/open

File/my-file.open "file.txt"
# so [/] for directories, [.] for files?
# I know none of this is getting in, but whatever. still interesting.
# yeah, giving up on it. too hard to implement.
# guess this language can't really be used as shell then?

# maybe?
import "File [open close]"
# well, if I really need this feature.

# eh.
import "File" as "FileImport"
import "File" as ""
import "File" as "File"
# I will take the shortest.

for 0 []  # should probably not execute.

# I guess if a function returns a non quoted string, it should just run it? but all number are non
# quoted strings... or i guess [do] just work for everything.

object [Vector3] [x y z]
print\n Vector3.x [1 2 3]

# function for strings passed by copy, strings for pass by reference?
# but strings are just functions that return strings.

let [value] if condition [function1] [function2] input
# pass [input] to [function1] or [function2]?
# I can and I will. I just need to evaluate the [then]/[else] bodies of the if statement.
# not [do] them!, just put the string in the stack.

let [value] if condition [
    function1
] [
    function2
] input

let func1 [print "printing func1!"]
do format [func%] 1  # outputs "printing func1!"
# [format] may be more useful than I thought. especially for macros.

# a static scope might be easier than expected?
# same process as the old language implementation, but the recursive lookup will search another
# linked list?

do format [let 1 % 123] "value"

let let-get [
    args [symbols table]
    do format [let 2 [%] get symbols table] symbols
]
let-get [open close] import "File"
# I guess this is the best way of doing this?
# but anyway, while we can, I should avoid doing this.
# it's ugly, and impossible if you consider recursive function calls (i.e. for/while loops)

# [Volatile] If you change these, the bytecode has to change!
enum [
    SOMETHING
    SOMETHING-ELSE
]

# I really need to make it so [get_type] properly identifies quotes, like with the scan and layers.
# just to make sure that the first and last brackets are actually pairs.

object [Node] [
    value
    next
]
let [node] [123 [321 []]]
print\n Node.value node  # outputs 123
print\n Node.next  node  # outputs [321 []]
print\n Node.value Node.next node  # outputs 321
print\n Node.next  Node.next node  # outputs []

Node.value! node 124
print\n node  # outputs [124 [321 []]]
Node.value! Node.next node 322
print\n node  # outputs [124 [322 []]]
# I guess?

do [
    use Node
    print\n value node  # outputs 124
    # it's not that different from something like a typed function.
    print\n Node  # outputs [value next]
]

# maybe I should always [debug-stack]? just as a implicit way of telling you not to fuck up.
# it prints to stdout, all the values of the stack at the end, always.

let get-obj [
    let inner 123
    let [obj] [print\n inner]
    obj
]
let obj get-obj
obj  # Variable not bound: 'inner'
# this is probably fine for now right?

let get-obj [
    let [obj] [print\n inner]
    obj
]
let inner 123
let obj get-obj
obj  # outputs 123

# do I really need to capture variables?
# the best use for it is encapsulation.
# ... wait, but can I do encapsulation without captures?

let empty []
let args [1 2]
print\n - empty args
# I'm going to allow this, I think.
# it require more code to prevent it.

# I think pointers will really be key to pass by pointer.

let ptr to [1 2 3]
set-at 0 ptr 5
print\n ptr  # outputs (random pointer)
print\n of ptr  # outputs [5 2 3]
print\n get 1 ptr  # outputs 2

let ptr new [1 2 3]
free ptr
let test [
    let ptr new [1 2 3]
    ptr
]
# I guess it makes sense? in scheme, references are also just lists.

# oh! okay, so the pointer is stored in the stack, or environment, and the actually value is
# somewhere in memory.

# hmm.
let ptr new 123
set-at 0 ptr 321
print\n get 0 ptr  # outputs 321 ?
# I don't know. it feels awkward.

# I feel like I need a mixture of a stack and a queue.
# a global stack for everything, then a queue individual scopes.
# what is left in a queue after a function returns, is pushed to the stack.
# ... no, the simpler solution is to just reverse n amount of arguments in the stack.

# maybe the special thing about [for] and [while], is that [->next] for [Program] pointers skip a
# scope? and you know, giving the illusion that the scope is special, while still retaining the
# variable are are popped after the stack gets deleted.

let func [
    let [_ _ _]
]
func 1 2 3

let func [
    let [a b c] args 3
    print\n reduce [a b c]
]
func 1 2 3

let func [
    args 3
]
func 1 2 3

# don't forget: free all variables at the end of the scope.

# wait, shit.
# how do I define [print\n] using the language?
let print\n [
    print args 1
    print \n
]
# ...

# oh!
let print\n [
    defer [print \n]
    print
]

# or simpler...
let print\n [
    print "%\n" format
]

# still, I'm curious. is there a way I could make this work with just [args]?
let test ["% %\n" 1 2 3]
print test
# what happens here?
# honestly, I think this should just work.
print test  # outputs "1 2 3\n"
# and also
let test ["% %\n" 1 2 3]
print test
# should... maybe...... (not) return 3?
print\n print test # outputs "1 2\n", then 3
# because
let test [
    print\n args 0
]
# ...
# this would be much easier if this language was lazy.
let print [
    let [buf nbytes] format args 0, size buf
    write stdout buf nbytes
]
# or
let print [
    defer [write stdout, buf, size buf]
    let [buf] format args 0, size buf
]
# or
let print [
    write stdout swap size . format
]

# the fuck?
print\n + .1 .2  # outputs 0.3??
# how does %g figure that out?

# maybe I should [reduce] the first argument of [for]?
for [1 2 3] [print\n it]
for 3 [print\n it]

# maybe [new] is nothing special? it's just a bool field called [should_free] or something.
# when calling [free_scope] automatically, at the end of [interpret], ...
# no, [free_scope] is only called if...
# wait. ok. [free_scope] frees all the variables that should be freed with [should_free].
# but the scope itself does not get freed unless all variables are freed.
# so, using the variable will still be like anything else in the language.
# or not, because when you return from a function, it copies...
# wait!
new [print\n "hello"]
# vs
let [var] new [print\n "hello"]
var
# ??

# wait a second! that's good!
let [macro] [set [x] - x 1]
let test [
    let [x] 6
    do macro
    print\n x
]
test  # outputs 5
# then again... is there that much use for it?
# honestly, [do] running statically vs ...
# oh.
let test [
    let [x] 6
    do [set [x] - x 1]
    print\n x
]
# it needs to be dynamic, otherwise the above code is impossible.
# ... then again.
let function [set [x] - x 1]
let test [
    let [x] 6
    function
    print\n x
]
# is equivalent to
let test [
    let [x] 6
    set [x] - x 1
    print\n x
]
# right?
# or should [set] always work one scope lower?
# it kind of works the same as [let] when inside the same scope.

# nah
let func [1 2 3]
func
# is equivalent to
do [1 2 3]
# so [do] should be statically scoped.
let [func] [1 2 3]
do func
do [1 2 3]

let [number] 123
map [+ number] [1 2 3 4 5]
# how do I do this?
map reduce [+ number] [1 2 3 4 5]
# this is an option...

map [print\n] my-list
# this works regardless.
# whatever. I'll only add features as I need them.

# ... I just realized, but my reduce is kinda scuffed.
# when I first had the idea for reduce, it was for reducing everything that did not have
# side-effects, or something like that.

# in scheme:
(define x 123)
(define func '(begin (set! x (+ x 5)) (display x)))
(define other-func (lambda () (let ((x 5)) (eval func) (display x))))
(other-func)  ; outputs 1285
# or
(define x 123)
(define func (lambda () (set! x (+ x 5)) (display x)))
(define other-func (lambda () (let ((x 5)) (func) (display x))))
(other-func)  ; outputs 1285

# hmm
mkdir 'test
'
# is equivalent to
mkdir test\n
# and [ls] prints
test\n
# regardless.
# also,
mkdir 'test  test'
# and
mkdir test\ \ test
# are equivalent
# (you need the double blackslashes for consecutive spaces in tokens).

let bool [
    if args 1 ["true"] ["false"]
]
print\n bool false

# for [for], first a reduce, then while not end of scope, [args 1], [args 1] and [args 1].

rename x y
# vs
rename "x" "y"
# I think the former is better, since I need to write a [is_valid_symbol] function otherwise.
# and it doesn't really make sense to have "" or [], if I don't do multiple renames.

let ptr to "hello\n"
print\n ptr  # outputs (random pointer)
let val "hello\n"
let ptr to val
print\n ptr  # outputs (random pointer)
# the difference between the two, is that the former is on the heap, the latter on the stack,
# essentially because it will be freed afterwards.
print\n of ptr  # outputs (random pointer)
# huh, just realized I can't use [to] indefinitely.

let [my-list] ["1" "2" "3" "4" "5"]
map [to] my-list
print\n my-list  # outputs [(list of pointers)]

# oh! I just realized! I do have a stack!

# OH. MY. FUCKING. GOD!!!!!!
# I just found out that I can have both writable AND executable memory on macos!
# I just need MAP_JIT as a flag!! That's all!

# ... or not? I played around with, but while it tells me it's readable, executable, I get a SIGBUS.

# you know. I guess I should only really compile when creating a file.
# the performance gain is shadowed by the JIT compilation.
# the interpreter should be slow, the compiled code should be fast.
# ... but then, some things become impossible.
# how do I define assembly instructions as function calls using [exec]?

# damn, another problem: I'm using the stack to return things, but I can't do that when compiled.
# variables will also be on the stack.
# so I would need to pop all the variables, then push all the returns.
# it's easier when everything except the args are on the heap...

# how do I both use the stack to store the values of variables and function returns?
# then again, it's impossible to return a string as a value...
# so I can reserve space for pointer returns. the question is about returns of variable length.

# while I create this stuff, I should try to make it as faithful to the future implementation as
# possible.
# it would be so much simpler if I didn't have to worry about compiling...

# let's think about the final implementation:
# honestly, I should be able to return from function, arrays as copies. I think.
# man, I really wish I could see how Jai does, if it does it.

let [str]        "Hello, World!\n"  # in the stack
let [str] static "Hello, World!\n"  # in readonly memory
let [str] new    "Hello, World!\n"  # in the heap
# maybe?
# but this sort of thing should be determined by the compiler.

# I could also have two stacks?

# for now, I should continue with the current model. try some advent of code problems and stuff.
# I'm getting ahead of myself.

# still, it might be easier to do the C low level implementation first.
# but then again, if the assembly implementation is done first, it will be easier with strings.
# I should still try to make the "looks and behaves high-level, but has a lot of shenanigans
# underneath" thing work.

let fib [
    let [n] args 1
    if < n 2 [n] [+ fib - n 1 fib - n 2]
]
print\n fib 10  # outputs 55

let ptr to    "Hello, World!\n"          # in readonly memory
let [str ptr] "Hello, World!\n", to str  # in the stack?

let recursive [
    let [n] args 1
    print\n n
    recursive + 1 n
]
recursive 0

# actually, [debug] should be smarter.

# the following rust code outputs something much nicer.
fn main() {
    let str = "Hello, World!\n";
    dbg!(str);
}

[src/main.rs:3:5] str = "Hello, World!\n"

# hell!
fn main() {
    dbg!(1 + 1);
}

[src/main.rs:2:5] 1 + 1 = 2
# now this is nice!

debug [+ 1 2]  # outputs [test.txt:1:1] + 1 2 = 3
# the position in the file is actually the start of the debug call.

# [set-ref] sets the values of a pointer
# equivalent to C's
*ptr = (something);
# wait.
# I thought of adding a [set-char]... but I don't need it right?
let ptr to "hello"
print\n ptr     # outputs (random pointer)
print\n of ptr  # outputs "hello\n"
set-ref ptr "hello\n"
print   of ptr  # outputs "hello\n"
mut + 2 ptr "x"
print   of ptr  # outputs "hexlo\n"

# shit, I can't short-circuit the [and] function.
and cond, func-call
# the arguments are both eager.

# bitwise operators don't accept decimals. that's fine.
# but instead of throwing an error, it should just truncate the thing.

let test [
    let [str] "hello\n"
    to str
]
print\n of test
# interesting. because everything is copied when passed to something else, there is no way to
# reference something on the stack if it wasn't already a pointer.
# that is unless [to] does not evaluate its argument?

# maybe go back to the original model?
let [str] "Hello, World!\n"
let ptr ptr-to [str]          # [ptr-to] takes a quoted symbol.
let [another-str] val-of ptr  # [val-of] takes a number/pointer.
print another-str

let test [
    let [str] "hello\n"
    ptr-to [str]
]
print\n val-of test

let [str ptr] "hello\n", ptr-to [str]  # [str] and [ptr] are static.
set-ptr ptr "hello"  # still static, but now points to another readonly string.
print\n val-of ptr  # outputs "hello"
set-char ptr "x"  # now in the stack.
print\n val-of ptr  # outputs "xello"
add-char ptr "lsjn"  # now in the heap. dynamic arrays automatically go in the heap.
print\n val-of ptr  # outputs "xellolsjn"

# btw, [mut-char] has an overload over numbers and strings?
mut-char ptr "ljlf"  # unsafe like C, can override other parts of the memory.
mut-char str "ljlf"  # returns a mutated copy of the string.
# ... I guess [mut-char] is like [strcpy]?

# in C.
int x = &0;
# this is not valid, so this should not be valid either.
let [x] ptr-to 0

let [macro] [let [x] 5]
inline macro

let test [
    if ! = [end] args 1 [
        + 1 test
    ] [print\n "end"; 0]
]
test 1 2 3 4 5 [end]

let [a d] 50 10
let [q r] / a d, % a d
print "a = %\n" + r * q d
# this works, but when you switch 50 and 10, there's a bug, because [/] returns a decimal.
# btw, can't forget that it's supposed to return a fraction... yeah, I'll have to do it.

# [+>] should be something. it looks cool. so should [>>=].
[1,2,3,4] >>= \ x -> [x - 1, x + 1]
[0,2,1,3,2,4,3,5]
# ^ in haskell

# the repl is line disciplined. you need to use [do] for multiline in...puts.
# no, [inline].

# I think you should have only the need for one [import] call in an entire project.

# I am increasingly more tempted to use a reference counter.
# that's the only way for me to make [load] work.

do [
    let [scope-offset] 1
    let [x] 123
]
print\n x

let macro [
    let [scope-offset] 0
    let [x y z] 1 2 3
]
macro
print "% % %\n" x y z

let [vec] [1 2 3]
print\n Vector3.x vec
# or
use Vector3 vec
print\n vec.x
set vec.x 4
# but [set] breaks it.
# ... what if [vec.x] is a pointer?
set-ptr vec.x
get-ptr vec.x
# or
use Vector3 vec
print\n vec.x
vec.x! 4
# this is the shorted one.
# or not?
use Vector3
print\n x vec
x! vec 4
# nevermind. the model I had already planned is the shortest, and cleanest.
x! vec 4
x: vec 4

table vec [x y z] [1 2 3]
print\n get "x" vec
table [vec] [
    x 1
    y 2
    z 3
]
# but what is
print\n vec
# pointer to the list? the list?

# ...
let [vec] [
    x 1
    y 2
    z 3
]
# same thing right?
# so table just convert a list into a table.

# I should consider the scheme style loop. the other loop are not impossible, but [continue] or
# [break] make things ugly. especially with loops implemented as recursion.

loop [
    print "THE END IS NEVER "
]  # should loop forever.

loop [
    args [x]
    print\n x
    if < x 10 [it - x 1] []
] 10  # or more like this.

let i 0
loop [
    print\n x
    set i + i 1
    if < 10 i [it] []
]  # for loop basically.

let i 0
loop as continue [
    if < 10 i [
        print\n x
        set i + i 1
        continue
    ] []
]  # for loop basically.

# you know, the more I use it, the more I like it.
# it's really just recursion, but you don't have to define the function, then called it.

let i 0
let it [
    if < 10 i [
        print\n x
        set i + i 1
        continue
    ] []
] it

loop [
    print "THE END IS NEVER "; it
]  # should loop forever.

# wait, if a loop calls itself automatically, then what happens when you return?
let i 0
loop [
    if < 10 i [
        print\n x
        set i + i 1
    ] [return]
]
# the loop needs to reach the end to call itself again, but it didn't.
# and since the outer scopes are already at the end, they will simply return.

loop [
    print "THE END IS NEVER "
]  # should loop forever.

loop [
    args [x]
    print\n x
    if < x 10 [it - x 1] []
] 10  # no longer possible

# or is it?

loop [
    args [x]
    print\n x
    if < x 10 [it - x 1] []
    return
] 10  # because what is actually being called here?

# but at this point, it might be better to just do recursive functions.

let it [
    args [x]
    print\n x
    if < x 10 [it - x 1] []
] it 10

# they where a little redundant with the earlier model, so I guess this is better?

for list [
    print\n it
]

let it [
    args [x]
    print\n car x
    if cdr x [it cdr x] []
] it list  # yeah... I'll just call them [car], [cdr].

let [x] list
loop [
    print\n car x
    set [x] cdr x
    if x [] [return]
]

# ah, I just remembered why I didn't do [return].
if x [] [return]
# this returns from the [if] function.
# right.
let [x] list
loop [
    print\n car x
    set [x] cdr x
    if x [it] []
]
# so this is it. [it] remains the same, so it doesn't matter what scope you're in.
loop [
    args [x]
    print\n car x
    if cdr x [it cdr x] []
] list
# and it matches with [for] and [while], what with the [as].
# you know, I think it will be good, because unlike the mundane recursion, it doesn't dirty the
# environment with define and use once functions.

while true [
    print "THE END IS NEVER "
]

# I'm thinking that I maybe don't need the no repetition thingy?
import [File File]
File.open "file.txt"
import "File"
open "file.txt"

File.open "file.txt"
File/open "file.txt"

Vector.x vec
Vector/x vec

# hmm... anyway, it is useful to have, but becomes weird with [load].
load "lib.txt"
lib.txt.open
lib.txt/open
# or should it automatically remove the file extension?
load "lib.txt"
lib.open
lib/open
# it is a little, just a little scuffed. still, if I ever find a better way of doing it, I will.
# and you can do this.
load "file1.txt"
load "file2.txt"
load "file3.txt"
load "file4.txt"
# which just looks cleaner.

# I should still try to memoize these things eventually.
# also, in general, the shorter solution is often the better one.

# should [args] return the actual arguments passed by the command line?
# probably not, since it will break something, but also because the command line passes arguments
# more like lisp. it's a list. demanding a specific number of args from the cli is weird. forcing
# the language and the cli to use the same interface is also just weird.

# maybe I should have a global defer? it would make implementing a reference counter easier.
# anyway, defer. I will probably use an extra field in [Program].

# a good thing about the red programming language is how you could just pass a url or filename to a
# function and it would figure out what it is just like that.
read https://example.com
# thought I imagine you had to pass it the full path or whatever.
# and underneath, it calls the appropriate function accordingly.

# seems like red has some "refinements".
request-file
request-file/file %test.red
request-file/file/save %test.red
# right, if I want it to be high level, I should have to open or close files.
write %r.html read/binary http://redprogramming.com/Home.html

# I guess [delete] will only delete things in the scope it is called in?

# this is one fucked up way of writing factorial...
fac: func [
    "Factorize number"
    n "Number to factorize"
][
    if n = 0 [return 1]
    n * fac n - 1
]
# and it fucking works!
let fac [
    args [n]
    if = n 0 [1] [
        * n fac - n 1
    ]
]
print\n fac 3  # outputs 6
print\n fac 3  # outputs 24

# oh. no wonder it was a fucked up factorial. in my mind, I thought of it as fib...
# I'm dumb. oops.

let test [
    - args 2
]
test 1 2  # yes! YES! YES!! I thought this would break things, but it didn't!

let ++ [+ 1]
++ 10

reduce [1, next 1] -> reduce [1, 2, next 3]
# so like a list that grows everytime you call reduce on it.
# though 'consuming' the first value may be a better idea.
# can forget just having numbers with internal states.
let next [
    args [n]
    unquote format [% next %] n, + n 1
]
reduce reduce reduce [next 1]
# just tried it. lol, it actually works.

# this somehow breaks if the [free] call in [eval] is placed higher??
let [list] [next 1]
for 10 [
    set [list] reduce list
    debug list
]

let inline [
    append [let [scope-offset] 1]
]

let test inline [
    let [x] 123
]
print\n x
# but what about
inline test-func
# it needs to be like jai, where every function has it's opposite.
do inline reduce [test-func]
# is ugly.

# oh! so like a macro?
# [inline] gets token, then if it's a quote, appends, if it's a symbol, gets the values, appends,
# then runs? but I think I should avoid this sort of thing...

do here [test-func]  # probably the best.

a: 1 b: 2 c: 3
str: "hello"

inline: [
    append [let [scope-offset] 1]
]
# I looks nice, but I'm not feeling it.

let macro [
    let [token1 token2] tokens 2
    print\n "token1 = '%', token2 = '%'\n" token1, token2
]
macro something something-else

macro: fn [
    token1: token2: tokens 2
    print\n "token1 = '%', token2 = '%'\n" token1, token2
]
macro something something-else

a: b: c: 1 2 3
let [a b c] 1 2 3
# it's interesting, but you can reassign [:] right?
# and how do you [set] something!? damn, it's the python problem.

object Vector3 [x y z]
use Vector3
let [vec] [1 2 3]
print\n get x vec  # outputs 1
set-at x vec 123
print\n vec        # outputs [123 2 3]
# vs
object Vector3 [x y z]
use Vector3
let [vec] [1 2 3]
print\n x vec  # outputs 1
x: vec 123
print\n vec    # outputs [123 2 3]
# considering just how often I'll be using this, model 2 is better.
# I keep swinging with this shit. when will I decide? when!?

if condition []
if-else condition [] []
if condition [] []

view [
    title "Tip Calculator"
    below
    let [f] field "9"
    let [t] field ".2"
    button "Calculate" []
    let [x] field "tip"
]
# basically, [view] first calls [reduce] on the string, then iterates over the list to determine
# how to display stuff.

cond: true
value: if cond ["true"] ["false"]
print\n value

a: b: c: 1 2 3
print\n a  # outputs 3
# because that's how the precedence works.
a: 1 b: 2 c: 3
# hmm.
three: fn [1 2 3]
a: b: c: three
# oh?
three: fn [[print] [loop] [error "Not found"]]
a: fn b: fn c: fn three

let square [* .]
square: fn [* .]
# shocking!

object Vector2 [x y]
object Vector3 format [% z] Vector2
debug Vector2  # outputs [x y]
debug Vector3  # outputs [x y z]

table vec [x y z] [1 2 3]
print\n get "x" vec
table [vec] [
    x 1
    y 2
    z 3
]
# but what is
print\n vec
# pointer to the list? the list?

# ...
let [vec] [
    x 1
    y 2
    z 3
]
# same thing right?
# so table just convert a list into a table.

# I should consider the scheme style loop. the other loop are not impossible, but [continue] or
# [break] make things ugly. especially with loops implemented as recursion.

let [vec] [1 2 3]
object Vector3 [x y z]
print\n Vector3.x vec  # outputs 1
print\n Vector3        # outputs [1 2 3]

object [vec] [x 1; y 2; z 3]
print\n get x vec  # outputs 1
print\n get/symbol "z" vec  # outputs 1
let [i] 2
print\n get/index i vec  # outputs 2

let [vec] [1 2 3]
object Vector3 [x y z]
let [vec] to-obj Vector3 [1 2 3]
# or
object [vec] [x y z] 1 2 3
# so
object [vec] [x y z] do vec
# that way, [to-obj] doesn't need to be.
print\n get/fields vec  # outputs [x y z]
print\n get/values vec  # outputs [1 2 3]
print\n vec             # outputs [x 1 y 2 z 3]
set/at vec x 4          # outputs [x 4 y 2 z 3]
# I kind of like this refinements model.
# it allows this representation, which is so clean! [x 4 y 2 z 3]
# but with less weirdness? no, there's still some. I need to "refine" it.

object [vec] [x y z] [1 2 3]
# perhaps this is better? since
object [vec] [x y z] vec
# is shorter?
# ...
object [vec] [x y z] [1] [2] [3]
# vs
object [vec] [x y z] ["1" "2" "3"]
# then again.

# anyway, I'm keeping [get/fields] and [get/values].
# also, I think I have a solution for the symbol/string dilemma.
let [v] reduce/symbols [x 1; y 2; z 3]
print\n v  # outputs [x 1 y 2 z 3]
# or just don't use [;].
set/at "x" vec 123
print\n v  # outputs [x 123 y 2 z 3]
set/at "x something" vec 123
print\n v  # outputs [x 123 y 2 z 3 "x something" 123]
# I think this is the best.
# also,
let [x y z] 1 2 3
let [v] reduce/values [x x y y z z]
print\n v  # outputs [x 1 y 2 z 3]
let [v] reduce/pairs [x y z]
print\n v  # outputs [x 1 y 2 z 3]
# or [reduce/match]?

# wait, [set/at] vs [set/field]...
# [set/at] for indices.
# [set/field] for... um, what was it again?.

# omg.
# [.] is like [[]], but for valid symbols.
print\n .my-symbol   # outputs [my-symbol]
print\n [my-symbol]  # outputs [my-symbol]
obj [field1]
obj .field1
# but also
obj[field1]
obj.field1

# like ['] in scheme, I guess.
obj .field1/set 123
obj .field1/get

set/field .x v 123

Vector3.x
Vector3/x
# I can't have [Vector3.x] with [Vector3[x]]
# well, whatever. [set/field] is better than [set.field].

# I need to be clear though.
print\n get/type .something  # outputs .String

let [v] [x 1 y 2 z 3]
object Vector3 get/fields v
let [v] get/values v

# but what if it was just an enum?
let [v] [1 2 3]
object Vector3 [x y z]
print\n Vector3          # outputs [x y z]
print\n Vector3/x        # outputs 0
print\n get Vector3/x v  # outputs 1

use Vector3
print\n get x v  # outputs 1
print\n get 0 v  # outputs 1
set/at x v 123
let [v] map [.] v
print\n v        # outputs [123 123 2 2 3 3]

print\n x v  # outputs 123
x: v 321
print\n v    # outputs [321 123 2 2 3 3]
# ^ still the best model.

let .v [1 2 3]

let func1 []
let func2 .func1

get/ptr
get/val

# ?
set/ptr
set/val

# no.
let [str] "hello\n"
let ptr to [str]
print\n ptr      # outputs (random pointer)
print\n get/ptr  # outputs "hello\n"
set/ptr ptr "Hello, World!\n"
print\n ptr      # outputs (random pointer)
print\n get/ptr  # outputs "Hello, World!\n"

let [pointer-list] reduce [for 100 [u64 0]]
# vs
let [pointer-list] list for 100 [u64 0]

let [v] f64 [1 2 3]
use Vector3
x: v     69  # 69 will not be another type than f64.
x: v f64 69  # you don't have to do this.

let [str] "Hello, World!\n"
set [str] 123  # throws an error?
# it really shouldn't.
# I guess it's just for numbers?

let func1 []
let func2 .func1
let func2 'func1
let func2 [func1]

get .x v
get 'x v

let func [
    .done
]
let func [
    'done
]

set/field "a string" obj 123
print\n obj  # outputs ["a string" 123]
set/field .a\ string obj 321
print\n obj  # outputs ["a string" 321]

let [value] 123
print\n get [value]  # outputs 123
# [get] is like [get/field], but with the environment, which is also a hashmap!

let get [
    get/field args 1, env
]
# or
let get [
    args [field]
    if env [
        get/field field, car env
    ] [get/field field, cdr env]
]
# I don't know how to do it.
# no, I know, but it's ugly.
let get [
    let inner [
        args [field env]
        if env [
            let [value] get/field field, car env
            if value [value] [inner field, cdr env]
        ] [inner field, cdr env]
    ]
    inner
]
# or
let get [
    let inner [
        args [field env]
        if && env, exists/field field, car env [
            get/field field, car env
        ] [inner field, cdr env]
    ]
    inner
]
# or~
let get [
    loop [
        args [field env]
        if && env, exists/field field, car env [
            get/field field, car env
        ] [loop field, cdr env]
    ]
]
# wait.
let get [
    loop [
        args [field env]
        if env [
            if exists/field field, car env [
                get/field field, car env
            ] [
                loop field, cdr env
            ]
        ] [error "Symbol not bound: '%'" field]
    ] args 1, env
]
# this is probably the best implementation.
let get [
    args [field]

    loop [
        args [env]

        if env [
            if exists/field field, car env [
                get/field field, car env
            ] [
                loop field, cdr env
            ]
        ] [error "Symbol not bound: '%'" field]
    ] env
]

let [v] [.x 1 .y 2 .z 3]
# vs
let [v] [ x 1  y 2  z 3]

car/2
cdr/2

set/ptr
set/char

let [x y z] 1 2 3
let [my-list] [x y z]
print\n my-list  # outputs [x y z]
reduce/set .my-list
print\n my-list  # outputs [1 2 3]

let get-thing [
    let add1 [+ 1]
    [add1]
]
print\n do get-thing 5  # outputs 6

let [x y z] 1 2 3
let [my-list] [x y z]
print\n my-list           # outputs [x y z]
print\n get/at 0 my-list  # outputs 1
print\n my-list           # outputs [x y z]
# and [my-list] should continue returning 3 when using [get/at 0], no matter the environment.
# and so, strings should have static scopes attached to them, or something.

get/x
set/x

while < 1 0 []
while [< 1 0] []
# the second one makes more sense... and can easily be implemented.

let loop [
    let it args 1
    it
]

loop [
    print "THE END IS NEVER " it
]
# this works, but it breaks [rename]...
let while [
    args [cond body]
    if do cond [
        do body
    ] []
]
# another reason of strings have a scope attached to them.
# it can't be done otherwise.
# still, I just realized the problem. If the scope is static, [loop] won't know what [it] is.
# or I guess the scope is static when using [do], but becomes static when assigning as a function?

map [my-function] [1 2 3]
# ^ here, [my-function], the string is dynamic, the function inside the string is static?
# this feels somewhat natural? maybe? but also a little arbitrary...

let "print\n" fn [print "%\n" format]
let .print\n fn [print "%\n" format]
let print\n [print "%\n" format]

let "value" 123
let .value 123
let value 123

let "square" fn [* .]
let 'square fn [* .]
let .square fn [* .]
let square [* .]

let "str" "Hello, World!\n"
let "str" fn ["Hello, World!\n"]

# Like seriously, there's not reason not to have macros in the language.
# except consistency. whatever. it's shorter, it's better.
let print\n [print "%\n" format]
let value 123
let square [* .]

# I think I should use ['] instead of [.]. otherwise, [..] and [...] are not possible.
# and they're too nice not to have.
load '.my-file
# is better than
load ..my-file
# which is confusing.
# and ['] matches with ["], and is nice for characters.
let 'my-char 'x
print\n my-char

let new-print 'print
# like
int (*new_print)(const char *fmt, ...) = printf;
# in C.
let new-print [print]

let [table] ['x 1 'y 2 'z 3]
set/at 'x table 321
print\n table  # outputs ['x 321 'y 2 'z 3]
# or
let [table] [.x 1 .y 2 .z 3]
set/at .x table 321
print\n table  # outputs [.x 321 .y 2 .z 3]

# ... but it's ugly.
let [table] ["x" 1 "y" 2 "z" 3]
set/at "x" table 321
print\n table  # outputs ["x" 321 "y" 2 "z" 3]

let [obj] [
    name "John Smith"
    age  23
]
let [obj] [
    .name "John Smith"
    .age  23
]
let [obj] [
    'name "John Smith"
    'age  23
]
let [obj] [
    "name" "John Smith"
    "age"  23
]

# okay, usual logic: take the shortest one.
let [table] [x 1 y 2 z 3]  # shortest initializer.
get/at .x table            # shortest getter
set/at .x table 321        # shortest setter
print\n table              # shortest output: [x 1 y 2 z 3]
# I didn't think of that! no need to keep the actual fields in the map quoted, just while getting
# and setting!

# [type] could return different things depending on whether it is comptime or runtime.

object Vector2 [.x .y]
object Vector3 [do Vector2, .z]
print\n Vector3  # outputs [.x .y .z]

object [vec] [.x .y] 1 2
# or
object Vector2 [.x .y]
zip-with Vector2 [1 2]
# or whatever the function is called that matches two values.
(define (interleave lst1 lst2)
    (apply append (map list lst1 lst2)))
(interleave '(1 2 3) '(4 5 6))  ; => '(1 4 2 5 3 6)

atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
let fib [
    args [n]
    cond [
        = n 0 0
        = n 1 1
        true + fib - n 1 fib - n 2
    ]
]
let fib [
    match args 1 [
        0 0
        1 1
        _ + fib - n 1 fib - n 2
    ]
]

# it should really be like this.
object Vector2 [x y]

get/at [0 0] # -> [caar]

get/at [0 0] list
# is equivalent to
caar list

# I should do [get/index] first (was it called that?).

let File [import "File"]
let [file] File open "file.txt"
print\n file id
# I already decided not to do this. the current object model is simpler.
# still, zig style imports are just nice.
object File [
    id
    ...
]
import "File"
let [file] File.open "file.txt"
print\n File.id file
# but zig style is shorter?
# then again, how do you initialize a struct?
let [vec] [1 2 3]
print\n vec  # outputs [1 2 3]
# zig style could not do this. it's so insanely simple.
for vec [print\n it]  # outputs "1\n2\n3\n"

# what does this do?
let [file] import "File" open "file.txt"
print\n file  # outputs... [id 1 ... ...]
# no, I just can't make it work.

let obj [
    field [field1] "Hello, World!\n"
    field [field2] 123
    field field3 [print\n get [obj]]
]
print   obj field1  # outputs "Hello, World!\n"
print\n obj field2  # outputs 123
obj field3  # outputs (the content of [obj])
# anyway, [field] is a function that basically works like [tokens], but only consuming a token if
# there is a match.
# maybe I should call it [part]?

let/field obj [x y z] 1 2 3
print\n obj x  # outputs 1
let/field obj func [print\n "hello"]
obj func  # outputs "hello\n"

let [vec] [1 2 3]

object Vector3 [x y z]
print\n Vector3/x vec  # outputs 1
print\n           vec  # outputs [1 2 3]

use Vector3
print\n x vec  # outputs 1
print\n   vec  # outputs [1 2 3]

let [vec] [y vec, x vec, z vec]
print\n x vec  # outputs 2
print\n   vec  # outputs [2 1 3]
# mutation like this? it's very functional right?
# but how do I implement this?

let/quote
let/unquote
# or
let/var
let/fn

let [vec] [1 2 3]
set [vec] [3 2 1 0]  # error: cannot reallocate stack space
let [vec] [3 2 1 0]  # valid
# so
use Vector3
set [vec] [z vec, y vec, x vec]
print\n vec  # outputs [1 2 3 0]
# [set] only mutates. this actually makes it so much more useful!

set [vec] [z vec, y vec, x vec]
# is equivalent to
set/at 0, vec, z vec
set/at 1, vec, x vec
set/at 2, vec, z vec

use/all [Vector3 Matrix]
# or
use/for [Vector3 Matrix]

# passing vec to function is awkward if vec is used as [vec x], because you need to use [do].
let my-func [
    args [vec]
    do vec x
]
print\n my-func [vec]  # outputs 1, or whatever x is

# [let] and [set] don't allocate? only [get/at] or [get/char]?
# [set] should be safe. no reason for it no to be so.

let ptr ptr-to "Hello, World\n"
print get ptr  # outputs "Hello, World!\n"

# [set] throws if not typed?
let [str] "hello"
set [str] "bye"  # error: unknown type for [str]
# or not?
let [str] [1 2 3]
set [str] [1 2 3 4]  # error: reallocation too large.
# whether it's a string or a list, it still makes sense!

set/char str "hey\0"

# hehe, just thought of something stupid.
let [arr] [1 2 3]
set [arr] [1 20 3]  # error: reallocation is too large.
let [arr] [1 02 3]
set [arr] [1 20 3]  # valid.
# I mean... right?
let [arr] u64 [1 2 3]  # [00..001 00..002 00..003]
set [arr] [1 20 3]  # valid.
# ... but like, binding the alocation to the string size? am I sure of this?
# this may come to bite me in the ass, but it's so interesting! doubt anyone has done this!
# still, it does make some sense, I guess?

let number 123
set number 1234  # error: reallocation is too large
let number u64 123
let number 1234  # valid
# should I? the whole point of this is that it's located on the stack.
# you're mutating a stack location, so it's impossible to increase the size without using [let].
set number 12345  # error: mutation is too large
# ^ better?

# still, that mean that...
let [arr] "hello"
set [arr] "hey"  # puts the null terminator automatically.
print\n arr  # outputs "hey\n"
# that said, I really need to move away from null terminators.
# and so, I need a allocated size, and a used size.
# or real size and used size.

# wait, I need to move away from null terminators...
let [str] "hello"
set/char str "hey\0"
print\n str  # ?
# I suppose there is no wait to do this then. "\0" is there for compatibility.

# maybe individual functions should allocate their own stack?
# then again, nah. simpler to have one stack pointer for everything. just change it after a while.
# need to add a field for the old stack pointer in each program...

let test [
    print\n this/name
]
test  # outputs [test]

# I'm giving up on [.] for quoting, that said, I might consider [']. I will see.

# I should probably giving this sort of thing.
let [arr] [1 2 3]
set/at 1 arr 4
print\n arr  # outputs [1 4 3]
# for
let [arr] [1 2 3]
set [arr] set/at 1 arr 4
print\n arr  # outputs [1 4 3]
# otherwise, every function need to essentially double.
# but... the shortest way to write it is usually better?
let [arr] [1 2 3]
print\n set/at 1 arr 4  # outputs [1 4 3]
# this is sorter? it is, so I can consider it. it won't be good to have too many functions.

let number stack/push 64 1
print\n number  # outputs 1
set number 1000
print\n number  # outputs 1000
let number 1
print\n number  # outputs 1
set number 1000
print\n number  # error: mutation is too large.

# honestly, it's probably better to just not have unsigned numbers.
# how is [+] or [-] supposed to tell if they are signed or unsigned?
# if you want it to wrap around, or error, do it yourself.

to/object [x 1 y 2 z 3]  # nevermind, no useful way of doing this.
object Vector3 [x y z]
to/table Vector3 [1 2 3]
# or just
object [Vector3] [x y z] [1 2 3]
# ^ passing the values as an array instead of
object [Vector3] [x y z] 1 2 3
# is better for errors because it's possible that the value count and name count are not the same.
# anyway, hashmaps should really not be used so casually... or rather, it's not really a hashmap,
# is it? this is a hashmap:
let [hashmap] reduce [for 99 [alloc 64]]
# a preallocated array of nodes.

# if I know what a function returns, I can put the returns in the stack as well...
# but the language is not typed... if I can figure it out, it would be good.
# I suppose I should make it so a function has to return the same size values, no matter the
# control flow? ... but then, a function like [new] that returns arbitrary memory... it could
# return a pointer, that's easy, but I don't know if I want that. I should create a seperate stack
# for returns. then see how it goes, then maybe consider having only one stack. the end product
# should be like that anyway. I really need a comptime and a runtime...

# I should have a function that takes a heap value, copies it to the stack, returns it, then frees
# the original. that's something I've been doing a lot in C. or is [defer] enough for this?

# but I guess I do need a seperate stack anyway? how do I [pop] and [push] otherwise?
# like, I also need a seperate place to put the for symbol/value pairs.

# I guess [Token] has a size (used), and [Variable] too (real)?

# aaargh! [get/token] should push a value in the stack, then [let] should bind the pointer to that
# value to a symbol... but then, adding a stack for returns requires extra steps...

# okay, since this will require making massive changes, I will have to save c-interp in archive
# again.
# well, admittedly, the behavior of the language won't change that much.
# it's important though, to be able to return both a string and a pointer, because that's how pass
# by value and pass by reference is done.

let test [
    let [value] "Hello, World!\n"
    value
]
test  # the stack space should ideally only be allocated once for performance.
# this needs to be determined when calling [test], not when defining, because after defining, the
# function can still be mutated.

let [value] "hello"
let test [
    args [value]
    set [value] "hey"
    print\n value
]
test value  # what happens?
# it should be copied. but then, that changes things.
let test [
    let [value] "Hello, World!\n"
    value
]
test  # this is copied, in a different stack?

# no matter how i think about it, it's just impossible! you need to run a function to determine how
# large its return is.
# wait a second, what about returning to registers?

# [set/char] should be [mut/char].
# recursion can also return an arbitrary precision value... numbers in general.

get/chars str  # returns ["h" "e" "l" "l" "o"]
get/chars str  # returns ['h 'e 'l 'l 'o]
get/chars str  # returns ['h' 'e' 'l' 'l' 'o']
# honestly, [' '] looks better then [' ]... also, just realized: ['\ ] for space (ugly).
# or [to/chars]?

let [Vector3] [x y z]
let [vec] [1 2 3]
use Vector3
x vec  # returns 1
# no need for [Vector3/x]?
# but then import is weird.

# or when I define a package, should I just use prefixes for everything?
let File/open [...]
let open [File/open]
open "file.txt"  # returns (file object)

import "File"
File/open "file.txt"  # returns (file object)
let open [File/open]
open "file.txt"  # returns (file object)
let/fn [open close] [File/open] [File/close]

# the reason a hashmap is important is because that's what the environment is.

let memcpy [...] @unsafe
# [memcpy] should show itself in red when called.

let [File] import "File"
let/get [open close] File

let File [import "File"]
let open  [File open]
let close [File close]
# this is the only way to return a struct, basically.

# well... you can still do this?
let [File] import "File"
use File
# nah, I still can't do it. the implementation is such a pain in the ass.

# You know? I don't need anything complicated.
import "File"
open "file.txt"  # that's all I need. that's all.
# that's how scheme does it, that's how C does it.
# if worst comes to worst
do [
    import "File"
    open "file.txt"  # that's all I need. that's all.
]
# I guess it would be nice if [import] did not polute any subsequent imports.

# oh!
let [table] [
    function [...]
    [str] "hello"
]
let/get [function str] table
function  # error: not implemented yet.
print\n str  # outputs "hello\n"
# um... I think I figured out hashmaps?

# though, it's better to use [this]... or not, just call the functions from the import environment.

do/tokens [x y z]  # returns "x", "y", and "z"

# hmm, [let] and [object are both valid?
let    [Vector3] [x y z]
use Vector3
x vec
# or
object [Vector3] [x y z]
Vector3/x vec
use Vector3
x vec
# you know... I'll keep having headaches on how to implement this for the rest of my life, won't I?

# *sigh*

# Maybe I should still have options for this object type?
let vec [field [x y z] 1 2 3]
print\n vec x  # outputs 1
let vec [field [x y z] vec z, vec y, vec z]
print\n vec x  # outputs 3

# three models for objects:

    # from least to most verbose initialization.
    let [vec] [1 2 3]              # array type
    let [vec] [x 1 y 2 z 3]        # table type
    let vec [field [x y z] 1 2 3]  # function type

    # from least to most verbose getter.
    print\n vec x          # function type
    print\n get 'x' vec    # table type
    print\n Vector3/x vec  # array type

    # from least to most verbose setter.
    set/key 'x' vec 4                        # table type
    use Vector3 set [vec] [4, y vec, z vec]  # array type
    set vec [field [x y z] 4, vec y, vec z]  # function type

# it seems there is no way to tell that something is a function in an array. you have to use [do].
set/key 'x'  vec  4  # as function
set/key 'x' [vec] 4  # as variable

# the thing is, the reason I'm so reticent about the table type, is because I don't like
# [Vector3/x]. not the naming scheme or whatever, but the idea that a function does a bunch of
# side-effects, and names a bunch of things this and that, polluting the environment...

# AAAAAAAAAAAAAAAAAAAAAAAAAARRRRGHH!!!!!11!1!1!!!

# I guess if there's a way to switch between the three types, that would help?
# If I use [load] as a script, it returning a environment would complicate things?

get/meta [value]  # returns (metadata object)
# but what type is the object!?!

let map [
    args [func list], set/unquote [func]
    func 5  # returns 7
    ...
]
map [+ 2] [1 2 3]

let Module [
    field [var1 var2 var3] 1 2 3

    field func1 [...]
    field func2 [...]
    field func3 [...]
    field func4 [...]
]

# (another file)
import "Module"
Module func3
let func3 [Module func3]
delete [Module]  # and it's gone!
func3  # but this should still work?

# one thing is certain, I should make the three object systems work before anything.
# well, also change the way the stack works as well.

# how the fuck do I make it so a variable is still available after it was deleted??
# to make it so, it needs to be pointerified (?) and stuff... though, I guess it's fine if that is
# done explicitly by the programmer?
let func3 append/for ["call ", ptr-to Module, " func3"]
delete [Module]  # and it's gone!
func3  # but this still works
# NOT! because when deleting something, that thing is also deallocated.

# the whole memory managing thingimagig is so annoying!
# I'm going crazy! I fucking am!!

struct Module [
    [var1 var2 var3] 1 2 3

    func1 [...]
    func2 [...]
    func3 [...]
    func4 [...]
]
Module func2
# basically taking a hashmap as input.
# but then how is it implemented? it needs to be a function, so we're back to square one?

# object: function object
# struct: array object
# table : hashmap

# object allows for cleaner nesting?

enum [x y z]
get/at x [1 2 3]  # returns 1

let [Vector3] [x y z]
enum Vector3
get/at x [1 2 3]  # returns 1
use Vector3
x [1 2 3]  # returns 1

struct Vector3 [x y z]
Vector3/x [1 2 3]  # returns 1

# oh. my. god! the more I think about it, the more frustrated I become! I cannot fucking decide!
# I need to do something else... get my mind off of this.

let test [
    let [x y z] 1 2 3
    [x y z]
]
let [vec] test
x vec  # should return 1? or error?

let test [
    let [x y z] 1 2 3
    reduce [x y z]
]
let [vec] test
x vec  # better?
# well, I suppose the implementation is certainly easier.

# but that also means that...
let test [
    let [x y z] 1 2 3
    reduce [field [x y z] x y z]
]
let vec test
vec x  # is impossible
# I should probably give up on the function object, it's not very practical.
# the internal are ugly too. it's lacking in performance.

# then again...
let test [
    let [x y z] 1 2 3
    reduce ['x' x 'y' y 'z' z]
    # or
    reduce/table [x x y y z z]
]
struct vec test
vec x  # is possible

# is anyone reading this? this is the notebook of someone going insane.

# anyway, do I even want the function object? unlike the hashmap, which is useful for environments,
# it has no real purpose.
# if anything it's a little dangerous.
let obj [
    field [x y z] 1 2 3
]
obj w  # error?
let test [
    args [obj]
    do obj x
]
test [field [x y z] 1 2 3]  # return 1
# I guess the advantage over structs, is that it can actually store functions as well?

# I really need a reference counter, or compile time memory management, that checks whether
# something should be freed from usage.
# [new] and [static] are ugly. I don't want them.

# wait a second? then things shouldn't be added to the stack... an environment should be open until
# all references to it are removed... if I put things in the stack, it becomes impossible to do.

let Object [
    args [value]
    [
        field [
            func1 [print\n value]
            func2 [set value]
        ]
    ]
]
let obj Object 123
obj func1  # outputs 123
obj func2 321
obj func1  # outputs 321
# this should work, it other words. the memory manager should be able to tell that [obj] is a
# string returned from [Object], and that having been returned from there, the environment from
# [Object] should persist. this is impossible with the current model, but even less with the stack
# model I was about to implement.

let Object [
    args [value]
    [value] [set value]
]
let [getter setter] Object 123
do getter  # outputs 123
do setter 321
do getter  # outputs 321
# but you know, doing this... means putting everything in the heap, like it python and stuff.
# that's not very good for performance.

let test [
    [] "error message"
]
let [value] unwrap test

let unwrap [
    args [result error]
    if error [throw error] [result]
]

let make/obj [
    let [a b c] 1 2 3
    env
]
let [obj] make/obj
get 'a' obj  # returns 1

do/env value  # returns (environment)

let Module [
    let [var1 var2 var3] 1 2 3

    let func1 [...]
    let func2 [...]
    let func3 [...]
    let func4 [...]

    call get tokens 1 env
    # or
    get/call tokens 1 env
    # nvm, same length
]
Module func1
# [call] does not unquote if the input is a quote.

let Module [
    let [var1 var2 var3] 1 2 3

    let func1 [...]
    let func2 [...]
    let func3 [...]
    let func4 [...]

    match/field env
]
Module func1

let Module [
    field [
        [var1 var2 var3] 1 2 3

        func1 [...]
        func2 [...]
        func3 [...]
        func4 [...]
    ]
]
# ^ the best one.

# oh!
field [
    [var1 var2 var3] 1 2 3

    func1 [...]
    func2 [...]
    func3 [...]
    func4 [...]
]
let file [import "File"]

# setting public/private things in the module is just dumb.
# the user of the module should have control of what they import.
let/get [open close] import "File"
# this is probably the ideal. it isn't short, but it is clean.
# having all the global the import is not something I care to have.

# btw, importing "File" again, would instead increment the reference count instead of running the
# thing again. it will still return the environment, of course.

# I should probably use gmp for arbitrary precision arithmetic.

+ [1 2] [3 4]  # returns [4 6]
# so like vector addition?

# okay, doing reference counter like swift, with maybe weak references and manual breaking of
# cycles, and whatever else. I'll change it back when the language is more advanced.
# well actually, the implicit borrow-checker is probably the best option.

# this should be a linked list, as in they are references to references...
let [list] [1 [2 [3]]]
# ... or should I really just use pointers?
# it has to be a pointer, otherwise we can do recursive linked lists.
# unless...
let [list] [1 [2 [3 [list]]]]
# and be it's quoted, it's fine to reduce for every [get/at] call?

# Numbers have a "maximum" field which is by degault 0.
# or is it char size? since that would work with strings too.

format/code [
    print "hello\n"
    print "bye\n"
]  # return [print "hello\n" print "bye\n"]
# nevermind, if there's nesting, it become pretty weird.
let [fib] [
    args [n]
    if <= n 1 [n] [
        + fib - n 1 fib - n 2
    ]
]
debug fib  # outputs [args [n] if <= n 1 [n] [
        + fib - n 1 fib - n 2
]]
# instead of just
debug fib
# outputting
[
    args [n]
    if <= n 1 [n] [
        + fib - n 1 fib - n 2
    ]
]

# kind of clever? reason you can't assign numbers as keys is because [get/at] and [set/at]?

# I should make it so the prefix [-] or [:] can but should never be used for symbol names.
# or maybe, make it so [args] looks out for it?
let cc [
    args [filename]
    let [output-file] "a.out"
    opts [
        -o [set [output-file] args 1]
        --output [set [output-file] args 1]
    ]
    compile filename output-file
]
cc "main.txt" -o "main"
# the only thing is, the options cannot be placed randomly...
# wait a motherfucking second... these are named parameters, basically!
cc "main.txt" :o "main"
cc "main.txt" --output "main"
cc "main.txt" -output "main"
cc "main.txt" .output "main"
# I just realized... but isn't this just [field] all over again?
# ok, I looked it up: python make named arguments go last when there are positionnal arguments as well.

# maybe [..] should be the spread operator? like with do?
let [a b c] .. [1 2 3]
let [a b c] do [1 2 3]
let [list] [1 2 3]
let [a b c] .. list
let [a b c] do list

# I think I just found a bug? [format] unquotes its input... that's great and all for [print], but
# what if you want to reassign the formatted text?

# this is the reason why it should be placed at the end.
cc "main.txt" -o "main" -o "app-name"

let test-func [
    static [value] 123
    print "% " value
    set [value] + 1 value
]
for 10 [test-func]  # outputs [123 124 125 126 127 128 129 130 131 132]
# I guess [static] is a useful way to do objects?

# convert this code in this language.
    (define (make-bank-account balance)
        (lambda (message . amount)
            (cond ((eq? message 'deposit)
                      (set! balance (+ balance (car amount)))
                      balance)
                  ((eq? message 'withdraw)
                      (if (>= balance (car amount))
                          (begin (set! balance (- balance (car amount)))
                                 balance)
                          "Insufficient funds"))
                  ((eq? message 'balance) balance)
                  (else "Unknown message"))))

    ;; Create an account with an initial balance of 100
    (define my-account (make-bank-account 100))

    ;; Example usage
    (display (my-account 'deposit  50))  (newline)  ; => 150
    (display (my-account 'withdraw 30))  (newline)  ; => 120
    (display (my-account 'withdraw 200)) (newline)  ; => "Insufficient funds"
    (display (my-account 'balance))      (newline)  ; => 120

# converted:
    let make-bank-account [
        args [balance]
        [
            args [message]
            cond [
                = message "deposit" [
                      set balance + balance args 1
                      balance
                ]
                = message "withdraw" [
                    if >= balance args 1 [
                        set balance - balance args 1
                        balance
                    ][
                        "Insufficient funds"
                    ]
                ]
                = message "balance" [balance]
                _ ["Unknown message"]
            ]
        ]
    ]

    # Create an account with an initial balance of 100
    let my-account make-bank-account 100

    # Example usage
    print\n my-account "deposit"  50  # => 150
    print\n my-account "withdraw" 30  # => 120
    print\n my-account "withdraw" 200 # => "Insufficient funds"
    print\n my-account "balance"      # => 120

# or...
    let [make-bank-account] [
        static [balance] 0
        match args 1 [
            "deposit" [
                set balance + balance args 1
                balance
            ]
            "withdraw" [
                if >= balance args 1 [
                    set balance - balance args 1
                    balance
                ] ["Insufficient funds"]
            ]
            "balance" [balance]
            _ ["Unknown message"]
        ]
    ]

    # Create an account with an initial balance of 0
    let my-account make-bank-account

    # Example usage
    print\n my-account "deposit"  50  # => 50
    print\n my-account "withdraw" 30  # => 20
    print\n my-account "withdraw" 200 # => "Insufficient funds"
    print\n my-account "balance"      # => 20

# damn, this is actually so terse!
# though, I suppose it's no longer terse if you want to specify the initial amount...

for [let i 0][< i 10][set i + 1 i] [
    print\n i
]
let i 0
while [< i 10] [
    print\n i
    set i + 1 i
]
# I mean, it's not like I can't do it?
# in fact, I will probably do [while], but [for], or at least this one, is too ugly.

# I guess I could also do this?
for [let i 0; < i 10; set i + 1 i] [
    print "%\n" i
]
# you run the first 2 items of the list, then the body, then the last item...
# since you run the first too items once, you can determine the size of the function call.
# and once you determine that, you can very simply seperate them.
# it's impossible without calling though.
for (int i = 0; i < 10; i = 1 + i) {
    printf("%i\n", i);
}
# huh, somehow it's the exact same length... well, no. I could do [+=] or [++].
for [let i 0; < i 10; ++ i] [
    print "%\n" i
]
for (int i = 0; i < 10; ++i) {
    printf("%i\n", i);
}
# damn! suprising even!

# when I'll do the reference counter, and maybe eventually a automatic borrow-checker, I'll need to
# make a way to check if the things do actually get freed.

# in python, range can take a step, but it's better to do it this way.
range 1 10        # [1 2 3 4 ...]
range [1 10 100]  # ... I guess this would be [1 10 100 1000]
# wait no, that's a lazy list...
# but I guess I could do it, if I figure out how.
let [list] [next [* 10] 0]
for take 10 list [print "% "]  # outputs [0 10 20 30 ...]

# anyway.
let [list] take 10 range [1 2 3]
for list [print "% "]  # outputs [1 2 3 4 5 6 7 8 9 10 ]
# so [range] can return a normal list, or a lazy list...

use Vector3
use [Vector3]
use [Vector3 Error]
# I think passing in a list by default is just better.
# I condidered making [use] a macro, but you can't do this otherwise.
let [Vector3 vec] [x y z] [1 2 3]
let test [
    args [Obj list]
    use Obj
    # or equivalent
    use [Obj]
    for quote Obj [print "% " .. it list]  # outputs [1 2 3 ]
]
test Vector3 vec
# actually... I can use it as a macro?

use Error, use Vector3
use [Code Message], use [x y z]

use [Error Vector3]
use [[Code Message] [x y z]]

# I feel like [use] will be... used often enough for it to deserve a default list input.

let [Vector3 vec] [x y z] [1 2 3]
use [Vector3]
print\n x vec  # outputs 1
x! vec 4
debug vec      # outputs [4 2 3]
# I honestly don't want the [!] postfix, but it's too long otherwise.
let [vec] [x vec, 5, z vec]
# vs
y! vec 5
let x  [get/at 0]
let x: [set/at 0]

# hmm, I know what happens when you do this.
let [vec] [x 1, y 2, z 3]
set/at "x"  vec  4
debug vec  # outputs [x 4, y 2, z 3]
set/at "x" [vec] 4
debug vec  # outputs ["x" 4, y 2, z 3]
# but what happens when you do this?
let [vec] [1 2 3]
set/at 0  vec  4
debug vec  # outputs [1 2 3] ?
set/at 0 [vec] 4
debug vec  # outputs [1 2 3] ?
# heck!
set/at "0"  vec  4
set/at "0" [vec] 4
# so like, my earlier conclusion that numbers cannot be bound to as symbols because of [set/at] is
# wrong... or not?
let ["a" b c] 1 2 3  # this is not valid, and will throw and error.
# the symbol that is passed to the assignment has to be a symbol or a number, but the number will
# also be rejected be it will basically destroy the list.
# then again, I will probably use a hashmap... but maybe I can still interface with it using
# something like [get/at] and [set/at]?
# or not? I mean, [debug env] will probably show something a little fucked up, like a list of pointers or something.

# [!] postfix should be used for "can error" like [u64!].

debug stack  # outputs (stack list)
# [stack] is a variable.

let x 123
let func [print\n x]
let x 321
func  # outputs 321
# I don't see a use case where this doesn't output 321.
let func1 [func2]
let func2 [print\n 123]
func1  # outputs 321
# it makes sense. and it's less complicated to implement.

# okay, let's consider [.] as a special syntax character.
let [File] import "File"
File.open "file.txt"
# ARGH!! but how does it consider it a special char? how do you initialize it...
# fuck it, never mind.
# it's simply amazing how much I struggle at this.

# this model is better than [.] syntax, since I don't have to change the interpreter at all.
let File [import "File"]
File open "file.txt"
# it also just looks better.
# that said...
let [File] import "File"
.. get/at [open] File "file.txt"
# is longer, but...
let/get [open] import "File"
open "file.txt"
# is the exact same length as the [File open] model. huh.
let/get [open close] import "File"
let [file] open "file.txt"
close file
# vs
let File [import "File"]
let [file] File open "file.txt"
File close file
# the former is in fact shorter.
# that said...
let/get [open close] [import "File"]
let [file] open "file.txt"
close file
# where [let/get] expands to
let/unquoted [open close] [import "File" open] [import "File" close]
# but never mind. it's really ugly.

let load [
    let [env] get-env read-file/memo args 1
    do/get args 1, env
]
let App [load "app.txt"]
# this is actually... so elegant!
# though I might need to change all the [/] for [-]...
# vs
let load [
    get-env read-file/memo args 1
]
let [App] load "app.txt"

let App [load "app.txt"]
# vs
let [App] load "app.txt"

let run [App run]
# vs
let/get [run] App

let run [App run]
let shut-down [App shut-down]
# or
let/get [run shut-down] [App]
# vs
let/get [run shut-down] App

let run [load "app.txt" run]
# vs
let/get [run] load "app.txt"

let read-file/memo [
    static [files] []
    args [filename]
    if contains filename files
        [get/at filename files]
        [set/at filename, [files], . read-file filename]
]
# and then maybe a function that automatically memoizes this?
memoizes [read-file filename]  # is all you need to do!

# I think [read-file/memo] is a good example of how to use [-] and [/] when naming things.
# [/] is for refinements that use the original, or composition?

private [
    let func1 [...]
    let func2 [...]
    let func3 [...]
    let func4 [...]
]
# ^ I might want to do this just to shut up the OOP people.
# ... but how is it implemented? do I create a new hashmap?
# maybe the implementation is related to how [static] is implemented?

# scheme but with currying?
(let (func-call arg1 curried-arg2)
    (print\n arg1)
    (print\n curried-arg2))
((func-call arg1) curried-arg2)
# ...
(let func-call
    (args [arg1 curried-arg2])
    (print\n arg1)
    (print\n curried-arg2))
# nah, parentheses are not where it's at. it's intersting to think about scheme with more
# functional properties, but my language just works without really needing to think about these
# things.

# I just realized, but this is extremely unsafe!
let test [
    + args 2
]
test [1 2 3] 4
# if [+] takes variable arguments depending on type, it can break things.

let/typed [a int, b int, c int] 1 2 3
args/typed [x int, y int, z int]

let/type [x number] 123
let/type [x string] 123
let/type [x symbol] 123

# maybe type checking is just some functions run before [compile]?
# I mean, as opposed to the earlier model when every function is 'compiled' per se.
# though I suppose it should still be compiled... and honestly, it's better if every function is
# forced to handle all the type cases. that will help keep the list of names shorter and stuff.

# maybe standard recursive functions add a new stack frame by default, but [loop] is always in the
# same stack frame?

# load and image.
let [img] read-bytes "img.png"
debug img  # outputs [0x43 0x55 0xAB ...]
# an array of bytes.

# basically typing.
let variable value    # function type
let [variable] value  # variable type
# of course, "variable" is just a function that returns a string.

# I'm probably repeating myself because of how long it took for me to get back here...

typst watch "file.typ"
# where [typst] is an object?

let func [
    args [a b c]
    print "% % %" a b c
]
func 1 2 3 4
# ^ the linter should throw a warning here, to tell you the argument count is invalid.
# and the linter should be a file, used to enumerate the rules for linting.
# maybe the linter can also tell invalid type changes? basically adding type checking without
# changing the language itself?
let [num] 123
set [num] "hello"
# first off, invalid size error. but if it wasn't there, invalid type conversion.

# lol: format is typing

print quote Hello,\ World!\n  # outputs "Hello, World!\n"

auto value 123  # i32
int  value 123  # i32

# maybe I should really do this? I mean, I've been struggling so much because of how there's no
# function overloading... and I can't copy Jai here.

auto square [* .]
func square [* .]

# but there should still be a value like dynamic. not to be confused with auto.
# [dyn] accepts all values, but not all values accept [dyn].

# and of course it can be used to optimize the compiler.

# now, for objects. the thing that brought this up. the pain in the ass.
# nevermind, not in the mood to think. I'll have to reread everything too.

# or not! paused for a few hours...
Car car [something something...]
# ^ no need for this.
Person person1 ["John Smith" 23]
print name person1
print age  person1
# no... this doesn't fix the problem of mutable values.
# and the earlier model was better.
let [vec] [1 2 3]
use Vector3
print x vec

# in other words...
set person1.name "Jane Doe"
# I need a function like this.
# wait a second... it's typed, and therefore overloaded, and THEREFORE!
set person1 name "Jane Doe"
# and for multiple...
set person1 [
    name "Jane Doe"
    age 24
]
# wait, no.
person1 name
name person1
# which is it?

# you know? it's been a real pain in the ass with [name person1].
# either I don't do it, and we have classic imperative mutation; or we have Haskell objects, with
# basic variable mutation.

# this language is about elegance and minimalism. if I didn't want that, I'd use Jai or something.
# my goal is to create the LISP that never was, so I will.
# there are only functions and literals. variable are functions. there can be reassigned.
# that is the restriction I will work with. and of course, no types; so no overloading.

let [vec] [1 2 3]
let func [
    use Vector
    set [vec] [x vec, * . y vec, z vec]
]
# ... that's just such a pain in the ass.
let [vec] [1 2 3]
let func [
    use Vector
    set [vec] [x vec, * . y vec, z vec]  # THIS is the problem! too long!!
]

# I need a coding project that I can convert into this language.

# haskell records:
data Vector3 = Vector3 { x :: Double, y :: Double, z :: Double }

vec :: Vector3
vec = Vector3 { x = 1.0, y = 2.0, z = 3.0 }

x vec   -- 1.0
y vec   -- 2.0
z vec   -- 3.0

x :: Vector3 -> Double

vec2 = vec { y = 10 }  -- new vector: Vector3 { x = 1.0, y = 10.0, z = 3.0 }

# I think this might be something...
let [Vector3] [x y z]

let [vec] [x 1.0, y 2.0, z 3.0]

use Vector3
x vec   # 1.0
y vec   # 2.0
z vec   # 3.0

let vec2 mut y 10 vec  # [x 1.0, y 10.0, z 3.0]
# yeah, this looks like "something", but it's not polished.

# the lesson that can be learned: maybe objects shouldn't be arrays. or rather, it is trivially
# easy to convert from array to object and vice-versa; so no need for an object that looks like an
# array.

# three types of "objects": arrays, interfaces and hashmaps.
let [array]     [1 2 3]
let [interface] [x y z]
let [hashmap]   [x 1, y 2, z 3]
# now I just need way to convert between those three.

vec2 = vec { y = 10 }  -- new vector: Vector3 { x = 1.0, y = 10.0, z = 3.0 }
let vec2 mut vec [y 10]  # [x 1.0, y 10.0, z 3.0]
# so like
let vec2 mut vec [y 10, z 100]  # [x 1.0, y 10.0, z 100.0]

# or maybe...
let vec [Object x 1, y 2, z 3]
vec x  # 1
mut [vec] [y 10, z 100]
# though, honestly, function objects are just not it. they're such a pain to pass through a
# function parameters. objects should be lists, end of story.
# that or...
let func [
    args [val [obj]]
    print\n val
    print\n obj x
]
func 123 [vec]

# maybe it's just a better model?
let func [
    args [val obj]
    print\n val
    use Vector3
    print\n x obj
]
func 123 [x 1, y 2, z 3]
func 123 [y 2, z 3]  # error: field x not found
# right? the problem with the language is that there are too many ways for an error to go unnoticed
# and now that I think about it, this is closer to how javascript do annonymous objects.
let obj = {
    name: "John Smith"
    age: 23
}
let [obj] [
    [name] "John Smith"
    age 23
]
let func-with-optional-args [
    args [input opt]
    match opt [
        trim 
    ]
]
func-with-optional-args "John Smith" [trim 5]
# ... well, something like that.

# wait a second.
let [vec] [x 1, y 2, z 3]
use vec
x vec
# the object is its own template?
# maybe I should just get rid of templates?
# at most, templates should be there to convert lists into tables, nothing more.
let [vec] [x 1, y 2, z 3]
get "x y" vec
use vec x vec y vec
# hmm...
take 2 to/list vec  # 1 2
# I really don't know anymore...
let/get [x y] vec
debug [% %] x y  # outputs [1 2]

# btw, I very much realize this is old news. shut up.

export [func1 func2]  # at the end of library files?
# returns table?
# nah, I prefer being able to import everything... then again, it's clever encapsulation.

use import "File"
# so...
use [x 1, y 2, z 3]
print\n reduce [x y z]  # outputs [1 2 3]
# wait, that's actually kinda good!
let [vec] [x 1, y 2, z 3]
+ get [x y] vec  # 3
use vec
+ x y  # 3
# WAIT! Isn't that Jai's [using]? literally?!

# you know what would be nice?
let [vec] [x 1, y 2, z 3]
use vec
print\n x
set x 10
debug vec  # [x 10, y 2, z 3]
# right? but how though...
debug get/val x  # [get "x" vec]

esu vec  # the opposite of [use]?

# nevermind. I'll just use
set [vec] mut vec [x x]
# ... which is very long. ugh.
set/mut vec [x x]

# Jai example
#import "Basic";

Point3D :: struct {
  x, y, z: float;
}

main :: () {
    pnt := Point3D.{1,2,3};
    using pnt;
    print("The coordinates of pnt are % % %\n", x, y, z);
}

# in my language
let/get [print] import "Basic"

let main [
    let [pnt] [x 1, y 2, z 3]
    use pnt
    print "The coordinates of pnt are % % %\n" x y z
]

# of course, this is easier.
print "The coordinates of pnt are % % %\n" .. pnt

# nested structs are a bit of a pain in the ass.
let [obj] [x [y 2, z 3]]
get "x" obj  # returns [y 2, z 3]
get "y" get "x" obj  # returns 2
# if I do this...
get "x y" obj  # returns 2
# then I can't do this:
get [read write] env

# oh, man! I. Just. Keep. On. Finding. NEW! PROBLEMS!!

# hmm, maybe...
let [obj] [x [y 2, z 3]]
obj.x.y
# a special operator?
set obj.x.y 123
set obj.x [y 3]  # doesn't delete z?
let obj.x [y 3]  # this does?
# also, it's not an operator. eval just looks out for it like with [].
# and maybe I'll have to change the internal representations.
# if it's pointer? [.] should also deref?

# huh.
let [File] import "File"
File.open "file.txt"  # I can do this?
# honestly, I decided this on a whim, but damn, it's nice.

# well, the reason I didn't come up with this idea earlier, is because I insisted on objects with
# no metadata, and templates. it became simpler when I limited complex types to two.
# we'll see if this holds up.

import "File"
File.open "file.txt"
let open [File.open]
open "file.txt"
# or
let/get [open close] File
# "the limit is your imagination."

# anyway, this should be avoided.
use import "File"
# 1. it's ugly (never liked it), 2. it's bad practice.
import "Math m"
m.sin 1

unquote [x 1, y 2, z 3]
# what if... that's equivalent to [use]? (although only at the top level)
# so like
import "File"             # env gets used
let [File] import "File"  # env bound to File
# I mean... I can do it the Jai way, but should I?
# then again, he probably did it for a reason.

let/get [open close print] import [File Basic]

let [arr] [1 2 3]
arr.1  # returns 2
# wait, that's a little confusing!

let [person] [
    [name] "John Smith"
    greet [print "Hello, %\n" this.name]
]
print\n name  # outputs "John Smith\n"
person.greet  # outputs "Hello, John Smith\n"

set person.bid-farewell [
    print "Goodbye, %\n" this.name
]
person.bid-farewell  # outputs "Goodbye, John Smith\n"

# the equivalent in javascript.
let person = {
    name: "John Smith",
    greet() {
        console.log(`Hello, ${this.name}!`)
    }
}

console.log(person)
person.greet()

person.bid_farewell = function() {
    console.log(`Goodbye, ${this.name}!`)
}
person.bid_farewell()

# of course, you can't do rust style function chaining.
let nums = vec![1, 2, 3, 4, 5];
let result: Vec<_> = nums.iter()
    .map(|x| x * 2)
    .filter(|x| x % 3 == 0)
    .collect();
# but that's fine. we're doing it haskell style (or scheme)
nums :: [Int]
nums = [1, 2, 3, 4, 5]

result :: [Int]
result = filter (\x -> x `mod` 3 == 0) (map (*2) nums)
# so...
let [nums] [1 2 3 4 5]
let [result] filter [= 0 % args 1 3] map [* 2] nums
# my language can get unreadable, but whatever.
# that's why I added optional parentheses.

# anyway, I think I figured out objects, for the most part.
# unlike the earlier models, this one is far cleaner, although I have to change the evaluator...
# best of all, it works like javascript prototypes!
# I know it's a controversial opinion, but I love them!

# I'm starting to think the Jai way is better.
import "Basic"
print "Hello, World!\n"
# vs
import "Basic"
Basic.print "Hello, World!\n"
# vs
let/get [print] import "Basic"
print "Hello, World!\n"
# vs
use import "Basic"
print "Hello, World!\n"

# the problem is this
.. [
    import "Basic"
    print "Hello, World!\n"
]

# you know what? for now, the Jai way. I'll try to implement it, and see what happens.
# maybe I should rename [unquote] to [use]? no need to have 2 functions that do the same thing.

print\n name   # outputs "John Smith\n"
person .greet  # still outputs "Hello, John Smith\n" ?

person person person person
.greet .greet .greet .greet
# outputs "Hello, John Smith\n" x 4?

# but how does
set person .bid-farewell [print "Goodbye, %\n" this.name]
# work?
# maybe [set] parses all the arguments first?

# I mean, you can do this.
import "std" .print "Hello, World!\n"
# and this
let std [import "std"]
std.print "Hello, World!\n"
# and even this!
import "std"
print "Hello, World!\n"
# because it's not a goddamn function!!
# hell, even this!
let [std] import "std"
# or this
let print [import "std" print]
# or this
let/get [print] import "std"
# well, ^ is shorter, so I guess I should keep it?
# anyway, you get my drift.

# I should make it so
person.greet
# and
person .greet
# are equivalent. things become too interesting no to.
# like, the insane flexibility of this language, bro.

# there should be a way to enable multiline comments.
# of course, if it's a library, it only affect the library. not the program that imports it.

set Config.multiline-comments true
#[
    Hello, World!
]#

# ... the implementation will be such a pain in the ass.

# ah shit, I forgot.
internal value .type
# does [internal] get called first, or [.type]?

internal value .type
# is not the same as
internal value.type
# ?

internal .. [value .type]

let [value] .. [
    let [func] use [print "Hello, World!\n"]
    func
    123
]
print\n value  # outputs 123 ?
let [value] .. [
    import "File"
    123
]
# maybe [import can detect if it's been used?

[ func [print "hello\n"] ]
func  # outputs "hello\n"

# I guess it makes sense?
let [Module] [ func [print "hello\n"] ]
Module.func  # binds to "Module"

[ func [print "hello\n"] ]
func  # binds to the top level

# hoh.
[ func [print "hello\n"] ] .func  # outputs "hello\n"

# maybe I should make it so () is not whitespace?
# it's only equivalent to .. []

internal .. [value .type]
internal(value .type)
internal value.type

let [arr] [1 2 3 4 5]
value.2        # returns 3
value.(+ 1 1)  # returns 3

let [Module] [ func [print "hello\n"] ]
func    # error: symbol [func] not found
Module  # returns [ func [print "hello\n"] ]
func    # outputs "hello\n"
func    # outputs "hello\n"
func    # outputs "hello\n"

# I guess this only gets added to the environment if a normal function is called afterwards?
[ func [print "hello\n"] ] .func  # one use, can't call [func] again. any other function deleted.
[ func [print "hello\n"] ]  func  # [func] and other function added to environment.
# this works, but again, inside a function it doesn't.

let func [
    let [vec] [x 1, y 2, z 3]
    use vec
    print "% % %\n" x y z
]
let func [
    use import "File"
    open "file.txt"
]

use import "File"
use import "Math"
use import "Http"
use import "OS"

import "File"
import "Math"
import "Http"
import "OS"

use import [File Math HTTP OS]
# I really think consistency and shortness is a good thing.
# I already have everything else. No need to be greedy.

let/get
extract
# yeah. it's fate.

extract [open close] import "File"

# () usually behave as whitespace. but sometimes it doesn't.

_ _ _ [1 2 3]  # discard?
# no
let [_ y _] [1 2 3]

# ah... remember when I thought the language shouldn't have objects? lol.

let [value] if false [123] []
print\n value  # outputs [] ?
# maybe?

# or...
321
let [value] if false [123] []
print\n value  # outputs 321 ?
# but I don't know. feels very erroneous (whatever that means).
# *error prone was the term I wanted to use.

print .. []  # should probably crash.

let [value] "vec"
let (value) [x 1, y 2, z 3]
print\n vec  # outputs [x 1, y 2, z 3]
# so like [#run] in Jai? no, I don't think so. I'll think about it later.

let run [App run]
extract [run] App

let arg [args 1]

let [nums] [1 2 3 4 5]
let [result] filter [= 0 % arg 3] map [* 2] nums

123 .x
ptr .x
# ?

# nah, I don't need () being actual syntax. just use .. [] if you really need to.
# or better: bind to a variable.


let greet [
    print "hello\n"
]
let bid-farewell [print "bye\n"]
use [
    greet [
        print "hello\n"
    ]
    bid-farewell [print "bye\n"]
]
greet
bid-farewell

# I just realized.
let ModuleName [
    greet [print "hello\n"]
    bid-farewell [print "bye\n"]
]

use import "ModuleName"
ModuleName.greet
ModuleName.bid-farewell
# of course, I prefer to be able to bind my own name, but it's an option.
# I'm just showing we have C++ namespaces.

let PI 3.14
set Settings.constant-modification ALLOW  # default
set Settings.constant-modification WARN
set Settings.constant-modification ERROR
set PI 4.13  # error: tried to modify constant symbol "PI"

# maybe [Settings] is by default empty?
let [Settings] []
set Settings.constant-modification ERROR

# honestly, I think it might be better to just have a constant type.
let value 123
set value 312  # error: tried to modify immutable symbol "value"

var value 123
set value 312
# so I guess constant objects should be declared fully ahead of time? maybe.
let obj [
    [name] "John Smith"
    age 23
]
set obj.age 24  # error: tried to modify immutable symbol "obj.age"

# I need to look at Jai, so I don't add features for the sake of adding them.
# btw, I guess I'm doing duck typing now...
let func [
    args [obj]
    obj.greet
]
func [ greet [print "hello\n"] ]  # outputs "hello\n"
func [ bid-farewell [print "bye\n"] ]  # error: object field ".greet" not found.
# ^ caught at compile time.
# although it should also allow runtime. no reason not to. do everything, is what I say.

# I guess objects should be stored compact, but printed pretty?
# () should be considered for #run, because I don't know how to [use] inside object.
# [Context] should be empty because there's a new one for every env.

let [private] [
    greet [print "hello\n"
]
let func [
    use private
    greet  # outputs "hello\n"
]

use Math.PI
print\n PI  # [use] on single values?

# also, what happens here? (if [let] is constant)
let greet [print "hi\n"]
use [
    greet [print "hello\n"]
]
# error? I guess not? I mean, use is equivalent to [let], so we shadow it?

let x "John Smith"
call/set upper x
set x upper x
print\n x  # outputs "JOHN SMITH\n" for both
# though I probably won't do that. I'm not liking [call/set], [let/get] anymore.

# ++ vs use
let obj ++ obj1 ++ obj2 []
let obj [
    use obj1  # ignore that [use] doesn't work here.
    use obj2
]
# you know, this is basically Jai's using, but it take advantage of the fact that everything is a
# string. yeah, I think I'm team [++].

# there should be a function that finds [let] calls and modifies them.
let func [
    let [str] "hello\n"
    print str
    Metaprogram.replace-let [func] [str] "bye\n"  # [str] being or not being quoted is significant
]
func  # outputs "hello\n"
func  # outputs "bye\n"
func  # outputs "bye\n"
func  # outputs "bye\n"
# equivalent to C's static.

# in C
#include <stdio.h>

void counter() {
    static int count = 0;  // initialized only once.
    count++;
    printf("count = %d\n", count);
}

int main() {
    counter(); // prints: count = 1
    counter(); // prints: count = 2
    counter(); // prints: count = 3
    return 0;
}

# in my language
let counter [
    let count 0;  # initialized everytime, but the literal changes.
    Metaprogram.replace-let [counter] [count] + 1 count  # [str] being or not being quoted is significant
    print "count = %\n" count
]

let main [
    counter  # outputs "count = 1\n"
    counter  # outputs "count = 2\n"
    counter  # outputs "count = 3\n"
]

# it's only after every thing is defined that the program runs.
let main [fun2]
let fun2 [fun3]
let fun3 [fun4]
let fun4 [print "hello\n"]
compile [
    main  # after everything is defined.
]

let [value] mut []
mut [value] []

# maybe everything is dynamic by default, but you can add types afterwards?
# also, maybe constant by default.
# I've probably said this before, but variables should be colored according to internal type.
# the problem is numbers, right? like, i32, u64, BigInt, etc. how do you decide what is what from
# usage.
# I should look into "tainted analysis".
# even with dynamic to added types, functions should remain typeless, a new instance of the
# function should be created from usage. static dispatch?

# maybe I should follow python and do "convention over restriction".

# type system - model 1 (ideal)

    let value 123  # no types.
    let value 123u32  # or maybe just this?
    let func [
        + . arg  # because [+] is called on [value], it's now a [Number] type.
    ]
    func value  # returns whatever type was passed in...

    [for 10 [u32 0]]  # array of 32 bits, unsigned integers?

    set value 321  # automatically makes [value] mutable, and removes it from readonly memory.

# type system - model 2

    let value     123  # type dynamic, basically the current implementation, everything is a string
    let value i32 123  # type i32, better optimized. actual numbers, not text of numbers

    let func [
        + . arg
    ]
    func value  # returns 246, functions still don't have types, but they have static dispatch.
    # works for both dynamic values, and static values. still has duck typing.

# honestly, model 2 is just really easy to understand, and probably easier to understand.
# if I can't make heads or tails of the concept, the implementation will even more impossible.
# but what if it's just numbers? there is no way to infer them, so what if I added them for now?
# let's try model 1 with number types for starters.

let [arr] [for 10 u32 0]  # this thing is just so nice!
let [arr] u32 [for 10 0]  # valid as well?
# I should try making them equivalent.

let [arr] u32 []
set [arr] add 5 arr
set [arr] add arr 10
debug arr  # outputs [5 10]

# again, if you don't specify [u32] or whatever, the type is dynamic (string).
# wait, no. that's model 2. for model 1, the type is Number, or BigDecimal in other languages.

# à la scheme.
number
 └─ complex
     └─ real
         └─ rational
             └─ integer

let [arr] [1 2 3 4 5]
set arr.0 10
set arr:0 10
print arr  # outputs [10 2 3 4 5]
set arr:+ 2 2 50
print arr  # outputs [10 2 3 4 50]
let i 2
set arr:i 30
print arr  # outputs [10 2 30 4 50]

# I mean, if I did it for objects, I should do it for arrays too.

# should [print] look at the true types so it prints properly?
# I think so. no need for [debug] in it's current form, too.

# it goes without saying, but if [.greet] is called, the type it's called on is automatically a
# struct. although...
let func [print]
let [obj] [
    func [print "hello\n"]
]
obj.greet  # outputs "hello\n"
.. obj  # outputs [print "hello\n"]
# so what's the type of object?

# I guess every object has a source? but that source can have children depending on usage?

let [arr] [0 1 2 3 4 5]
let func [
    args [arr]
    set arr:5 50
]
func arr
print arr  # outputs [0 1 2 3 4 5]
func ptr-to arr
print arr  # outputs [0 1 2 3 4 50]
func [arr]
print arr  # error: array out of bounds [arr].
func [0 1 2 3 4 5]
print arr  # outputs [0 1 2 3 4 50]

# so like, [arr] is equivalent to [[0 1 2 3 4 5]]? it is redondant, and still cloned.
# plus, it can't be overloaded. when [:] is used on a pointer, it's pass-by-reference.

let [arr] [1 2 3 4 5]
set arr:0 arr
print arr  # outputs [1 2 3 4 5 2 3 4 5]
let [arr] [1 2 3 4 5]
set [arr:0] arr
print arr  # outputs [[1 2 3 4 5] 2 3 4 5]

let [arr] [1 2 3 4 5]
let ptr to arr
let val of ptr
# or
let ptr >> arr
let val << ptr
# but that's bitshift...

# is this overloaded?
let [arr] u64 [1 2 3 4 5]
<< + 1 ptr  # returns 2?
# probably. I guess [+] looks at the true type.

# GOD! SO MANY DECISIONS!!

# it would be nice if functions had options.
+ .wrap 1 u32 .max  # returns 0

set [obj .field1 .field2] [1 2]
# hmm, no. [.field2] should be a subfield.
set [obj .field1.subfield1 .field2.subfield2] [1 2]
print obj  # outputs [[field1] [subfield1 1], [field2] [subfield2 2]]
# I think that's good. very powerful and terse.

# I think this should be a macro.
set [obj.field] 0
# becomes
set [obj] mut obj [field 0]

let Vector3 [
    [x arg, y arg, z arg]
]
# wait, does that even work?
let [vec] Vector3 1 2 3
print vec    # outputs [x arg, y arg, z arg]
print vec.x  # ... wtf happens here?!
# maybe [.x] returns the function body for [arg]? so [args 1]?

let Vector3 [
    new [x y z]
]
let [vec] Vector3 [1 2 3]
let [vec] Vector3 1 2 3

let [Vector3] [x y z]
let [vec] new Vector3 [1 2 3]  # oddly enough, this feels like the best one.
let [vec] new Vector3 1 2 3
print vec

let Person [
    new [
        id
        [name]
        age
    ]
]
let [person1] Person random, "John Smith", 23
let [person1] Person [random, "John Smith", 23]

let [Person] [
    id
    [name]
    age
]
let [person1] new Person [random, "John Smith", 23]  # it's just so much better with brackets.

# I think the second model is better since you can do this:
for quote Vector3 [
    print\n get it vec
]

# trying out different syntax: what if {}, [] and "" where different?
let arr [1 2 3 4 5 6]
arr.1  # objects are still arrays.
arr:1  # two ways to access them.

let func {
    print "Hello, World!\n"
}
func  # outputs "Hello, World!\n"
let [value func] 1 {print\n}
func value  # outputs "1\n"

let obj [
    value 1
    func {print}
]
let {value func} obj

let [open close] import "File"
extract [open close] import "File"
# yeah... honestly, I don't really feel it.

# making these the same doesn't feel right.
let  something  [print]
let [something] [print]

let "something" [print]
let ["something" "otherthing"] [print] [debug]

obj :: {
    value 1
    func {print}
};
obj.func obj.value

# if I allow [obj .field], I should be able to add infix operators?
# I think I'm going to stop this line of thought. it's becoming too complicated.
# the only reason I added field syntax and primitive number types, is because of how much of a pain
# it was. and they're really just macros, or necessities.

# although, I could remove the Scheme-style numbers and only have C-style, with i32 as default, idk
# all numbers should be wrapping by default. with maybe [+!] for short error checking.
# although... is this language, you can mix multiple type in an array. that's not very static of it
let [arr] [1 "hello" "A" [print "hello\n"] 321.55]
# it should be opt-in to system programming. so things should be easy to beginners.

let value 50
print *- value  # outputs -50

Pointer.+
Pointer.-

let [vec] [x 1, y 2, z 3]  # still a string.
print vec  # outputs with no formatting.

let [vec] [x 1, y 2, z 3]  # the linter show [vec] is a object because of later usage.
print vec  # outputs with struct formatting.
set vec.x *- vec.x

# and function really need to detect argument count. it will cause problems.
+ 1 2
+ [1 2 3 4]

- [1]  # returns -1?

# since I'm already overloading on true types, I don't need [Pointer.+] and [Pointer.-].

let [arr] [for 100 u64 0]  # array of null pointers.

# wait a second.
let ptr ^$ [1 2 3]
print $^ ptr  # output [1 2 3]
# full list right? but I can't do this!
set *ptr 10
# only
set ptr:0 10
print $^ ptr  # output [10 2 3]

# mnemonic?? [$] the value, [^] the pointer.

# also, because of this,
let ptr ^$ [1 2 3]
# you can't do this.
let [arr] [1 2 3]
let ptr ^$ [arr]
# it has to be
let ptr ^$ arr

# scheme to this, equivalents
    # pointers
    arr
    ^$ arr

    # function calls
    (my-func 1 2 3)
    my-func [1 2 3]

    # symbols
    'symbol
    [symbol]

# I don't know...
let 'arr [1 2 3]
let ptr ^arr
print ptr^  # output [1 2 3]
# nah, I'm keeping [$^] and [^$]. too much syntax, too quickly.
# I should also note, I can always remove it.

let arr [1 2 3 4 5]
arr:1  # returns 2
let func [print "hello\n"]
func  # outputs "hello\n"
# yeah, I can't do this.

let [arr] [1 2 3 4 5]
# vs
let 'arr [1 2 3 4 5]

# maybe I should actually edit the copy of the program as I run it?
# no, the error messages will get very confusing.

let [obj] [field 123]
set field: obj 321
print field: obj  # outputs 321

let [str] "Hello, World!\n"
set chars str :5 "hhh"
# I don't know about that. it's read as [set chars str] only.

let [vec] [x 1, y 2, z 3]
x.vec

set 5:chars str "hhh"
set + 1 2:chars str "hhh"
# no. just no.

let [arr] [1 2 3 4 5]
set-at 1 arr 20
set arr:1 20

set-at 2 arr "hello"
print arr  # outputs [1 20 hello 4 5]
# I mean, you need it for objects!
set-at 2 [arr] "hello"
print arr  # outputs [1 20 "hello" 4 5]
set [arr:2] "hello"
print arr:2  # outputs "hello"
print get-at 2 arr  # outputs "hello"
# it's not even funny how bad it is without [:].

# the problem is [set-char]. I can't use [:].
let [str] "Hello, World!\n"
set-char str 3 "hello"
print str  # outputs "Helhelloorld!\n"

let [c] to-char "Hello, World!\n"
set c:3 to-char "hello"
print to-str c  # outputs "Helhelloorld!\n"
# honestly, I don't like the need for conversion.

let [str] "Hello, World!\n"
set str.chars:3 "hello"
set-char str:3 "hello"
print str  # outputs "Helhelloorld!\n"

# there's no [let-char], so... do I need the [set-] part?
char str:3 "hello"

let [File] import "File"
open.File "file.txt"
# so ugly. but I don't know.
open.import "File" "file.txt"
# it does fix my earlier problem

let [File] import "File"
File.open "file.txt"
get "open" File "file.txt"
get open File "file.txt"
open: File "file.txt"

import "File" .open "file.txt"
# I'll just go with the most aesthetically pleasing one.

let [arr] [1 2 3 4 5]

arr[1]  # returns 2
arr: 1  # returns 2

set arr[1] 20
set arr: 1 20

set arr[1 2 3] 20 30 40
set arr :1 :2 :3 20 30 40

set arr[.. range 1 4] 20 30 40
set arr: range 1 4 [20 30 40]
# oh!
set arr[1 2 3] 20 30 40
set arr:[1 2 3] [20 30 40]

# how about [:] is for internal objects?
let [str] "Hello, World!\n"
print str  # outputs "Hello, World!\n"
print str:type  # outputs "String"
print str:char  # outputs ["H" "e" "l" "l" "o" "," " " "W" "o" "r" "l" "d" "!" "\n"]
# basically, this is what [+] accesses to overload on type.
# or [print] to determine how to format the thing. etc.

# I can also use this.
print str::char  # outputs "String"
#

let [vec] [x 1, y 2, z 3]
let [field-name] "x"
print vec.x  # outputs 1
print vec.[field-name]  # outputs 1
# clever right?

add Syntax.rules []
add [1 2] [3 4]  # returns [1 2 3 4]
# or
+ [1 2] [3 4]  # returns [1 2 3 4]
+ 12 [3 4]  # returns [12 3 4]

# I like the relation between [.], [:] and [::].

let obj3 + obj1 + obj2 []
let str3 + "Hello,"::chars + " "::chars "World!"::chars
let str3 ++ "Hello," ++ " " "World!"

# maybe I don't need [::].

let [str] "Hello, World!\n"
print str  # outputs "Hello, World!\n"
print internal str .type  # outputs "String"
print chars str  # outputs ["H" "e" "l" "l" "o" "," " " "W" "o" "r" "l" "d" "!" "\n"]
chars str :[1 2 3]  # outputs ["E" "L" "L"]

let [arr] [1 2 3 4 5]
set arr:1 20
print arr  # outputs [1 20 3 4 5]
set [arr:1] "XX"
print arr  # outputs [1XX0 3 4 5]

let [vec] [.x 1, .y 2, .z 3]
for vec [print "%, " it]  # outputs "x, 1, y, 2, z, 3, "
# okay. but the reason it didn't work before was...
print\n .x  # outputs "x"
print\n [.x 1, .y 2, .z 3] .x  # outputs 1
# how will I make this work?

# nevermind. I don't need it.
for quote vec [print "%, " it]  # outputs "x, 1, y, 2, z, 3, "

# shit! [let] and [import] are both functions! how does [.open] know when to call?!
let [file] import "File" .open "file.txt"

let [file] :open import "File" "file.txt"

let [File] import "File"
File.open "file.txt"
.open File "file.txt"

let [arr] [1 2 3 4 5]
:+ 1 2 arr
arr:+ 1 2 

let [file] (import "File" .open "file.txt")  # ugly...
# man, I really thought I had it too.

let [file] import "File".open "file.txt"  # not good, because it's on it's on the string.
let [file] import "File" .open "file.txt"  # better because [import] get's called.
let [file] identity import "File" .open "file.txt"  # still gets called after [import]...
let [file] identity import "File" ..open "file.txt"  # gets called after [identity]...
# or
let [file] identity .open import "File" "file.txt"  # gets called after [identity]...
# nah. [.open] should before it's arguments.

# I guess I fixed the problem quickly?

# btw, the reason why this work is really clever.
obj .field .sub-field
# [.field] returns a object! so [.sub-field] is really just a seperate function!!

# I guess I should be careful about this...
print-and-return obj.field .sub-field  # gets [.field], prints it, then gets [.sub-field].
# if you think about it, in any other language you have to use parentheses to determine this.
# this is actually a shorter way of doing things. far more homoiconic too.

# or maybe I do?
let [vec] [x "1", y "2", z "3"]
for quote vec [print "%, " it]  # outputs [x, "1", y, "2", z, "3", ]

# maybe I should do this instead.
let [obj] [field1 123]
let obj.field2 456
print obj  # outputs [field1 123, field2 456]
set obj.field3 789  # error: could not assign 789 to field [.field3], it does not exist.
# I think this makes more sense.

let [list] [1 [2 [3]]]
list:1:1  # returns [3]
list:1:1:0  # returns 3

let value u64 123
set value 321  # still a u64. you shouldn't have to say u64 everytime.
# but what are the implications of that? does it throw if you change the type?

# a comment [

] still a comment?

print loop as next [
    static [value] 123
    print "% " value
    set [value] + 1 value

    if < value 100 [next] [value]
]
# outputs [123 124 125 126 127 128 129 130 131 132]

# I forgot how clever this renaming was. I feel like I've been using 'clever' a lot... I should
# stop. sounds pretentious.

# btw, I can totally do [return].

print loop [
    static [value] 123
    print "% " value
    set [value] + 1 value

    if < value 100 [] [value  return it]
]

# maybe instead of [;], I should use [  ] for multiline statements on a single line?
# [;] has always felt weird.

print "Hello, "; print "World!\n"
print "Hello, "  print "World!\n"

+ 1 2; + 4 5; + 6 7
+ 1 2  + 4 5  + 6 7

# well, I'll keep [;] around. I just won't use it. I think it's a matter of preference.
# in the first place, avoid unreadable code.

# also, I'll say it before I forget, but I've looked at my old code, and the [/] seperator for word
# names is no longer aesthetically pleasing to me. I don't know what happened, but whatever.
vec/x
vec.x
# ^ obvious which one is better.
set/at
set-at
# same.

# a convention of the language should be that a function should always take the same number of
# arguments. I just see this become a horrible pain in the rear if not. the language is already too
# lax with duck typing and such, no need to cause more chaos.

# then again, that's why I added this
print let x 1  # error: [print] did not receive any value.
# no... it should be added in spite of that. you can do stupid shit, but you shouldn't.
# big codebases should be easy to debug. python is dynamic, but it doesn't have javascript's
# nonsense, right?

# "This language is not for the faint of heart."

compile [
    entry-point [main]
    output-file "app"
]
# nevermind. [main]'s body should be inside [compile].
# I can change the settings for the compilation elsewhere.
set Settings.output-file "app"
set Settings .output-file "app" .compile-target Platforms.x86_64
# damn! it's better than
set Settings.[
    output-file "app"
    compile-target Platforms.x86_64
]

set Settings
    .output-file "app"
    .compile-target Platforms.x86_64
# okay... I know I said that, but I'm starting to like .[]
# the problem is that it's already set for evaluating things...
# and it just makes sense that you can chain assignments like that...

# then again, no.
print reduce [Settings .output-file .compile-target]  # error: field [.compile-target] not found in [Settings].
print reduce [ Settings.[output-file compile-target] ]  # outputs ["App" 4]

# wait a second.
set Settings.[
    [output-file] "app"
    compile-target Platforms.x86_64
]
set [Settings
    .output-file "app"
    .compile-target Platforms.x86_64
]  # yeah, I'm definitely NOT doing this.

set [Settings.output-file] "app"
set [Settings.compile-target] Platforms.x86_64

set [Settings.output-file Settings.compile-target] "app" Platforms.x86_64
set [Settings .output-file .compile-target] "app" Platforms.x86_64  # essential should "app" be data.appname

set [Settings .output-file "app" .compile-target Platforms.x86_64]  # wait, that doesn't fucking work!
# then again, I guess it could work. like you can't combine different models?
# or you can, but [.compile-target] has to get it's input first.
# I guess you can't combine different models for each object?
set [Settings .output-file "app" .compile-target] Platforms.x86_64 # then again...
# whatever. I guess you can, it will just be weird, and you'll have to figure things out.
# just don't do weird shit. seriously.
set [Settings .output-file "app" .compile-target Platforms.x86_64 MyObject.x] 5  # valid.
set [Settings .output-file .compile-target Platforms.x86_64 MyObject.x] "app" 5  # bugged, waiting 4 values.

set Settings.[[output-file] "app" compile-target Platforms.x86_64]  # can be shorter, can be longer
set Settings .[output-file] "app" .compile-target Platforms.x86_64
set Settings .[[output-file] "app"] .compile-target Platforms.x86_64
# wait, but it is 'quoted' already, if you think about it!
set Settings .[output-file "app"] .compile-target Platforms.x86_64
set Settings.[
    output-file "app"
    compile-target Platforms.x86_64
]  # this is valid!

# I don't see why I can't make them all valid.
# I thinks it's nicer if .[] just doesn't accept functions. but maybe it should. like some lambdas.
# and it's good to keep object definitions the same. no need to cause confusion.

print reduce [ Settings.output-file Settings.compile-target] ]  # outputs ["App" 4]
print reduce [ Settings.[output-file compile-target] ]  # outputs ["App" 4]
print reduce [ . Settings .output-file .compile-target] ]  # outputs ["App" 4]
# I really think there are only 3 ways to access multiple fields...

# maybe...
let [arr compile-target] [1 2 3 4 5] 2
arr:"compile-target"  # returns 3
# non numbers and decimals don't make sense.
# but what if...
set [field] "compile-target"
Settings:field  # returns 4
# so I don't need [Settings.[field]]!
# but I guess I really can't have numbers as keys. at least, they have to be quoted.

# wait.
let [obj] [1 2 3 4 5 6]
obj.3  # so, what happens?

# oh. my. god. I just realized. it gets even more fucked when I combine [.] and [:]... God save me.

# alright. I'll just do this.
let [[func] value] [print] 123
func value  # outputs 123
# or not?
let [symbol] "hello"
let [[symbol] value] unquote [print] 123
hello value
.. symbol value
# but honestly, there's not much point to it.
# better to do
let [symbol value] "hello" 123
set env:symbol 123
print\n hello  # outputs 123

env.NEXT-LAYER.NEXT-LAYER.NEXT-LAYER.NEXT-LAYER  # linked list?
# btw, [env] is totally a pointer. isn't [.] just so convenient.
# no need for dumb [->]. heh, stupid tool for cavemen!

# [->] :(

for 100 [
    print\n arr:[quote it]
]
# I guess I can have numbers. Just have to be careful about switching them around.

# you know? why not make many of them valid? like with [import].
# just add many options and call it a day.

set set []
delete set
set  # returns []

let x 1
.. [
    rename x y
    set y 2
]
print\n x  # outputs 2 ?

# I feel like this language is becoming rakuish, in that it's closer to a maximilist language,
# while still being constrained by a very few basic rules.

set 5 str "---"  # it something, but nothing.
# should be like this.
set 5 []
set env.5 []
# ^ equivalent. and useless, although possible.

let [str] chars "Hello, World!\n"
set str:3 chars "---"
print string str  # outputs "Hel---lo, World!\n"
# I think that's the key. I literally have [set-char] as two different functions!
# and it makes sense, like in rust, it's utf-8! so internally, you convert from [u8] to [u64].

let [arr] [1 2 3 4 5]
set arr:0 10                    # [10 2 3 4 5]
set arr:0 [100]                 # [100 2 3 4 5]
set arr:0 [10 20]               # [10 20 2 3 4 5]
set arr:-1 [-10 0]              # [-10 0 10 20 2 3 4 5]
set arr:-0 [-30 -20 -10]        # [-30 -20 -10 0 10 20 2 3 4 5]
set [arr:0] -3                  # [-3 -20 -10 0 10 20 2 3 4 5]
set [arr:0] [-3]                # [[-3] -20 -10 0 10 20 2 3 4 5]
set arr:[1] [-2]                # [[-3] [-2] -10 0 10 20 2 3 4 5]
set arr:[1 2 3] 111 222 333     # [[-3] 111 222 333 10 20 2 3 4 5]
set arr: offset 3 ['x' 'y' 'z']  # [[-3] 111 222 'x' 'y' 'z' 2 3 4 5]
set arr: range 1 4 111 222 333 # [[-3] 111 222 333 10 20 2 3 4 5]

offset 3 ['x' 'y' 'z']  # returns [3 4 5] .. ['x' 'y' 'z']
offset   ['x' 'y' 'z']  # returns [0 1 2] .. ['x' 'y' 'z']
# I know what I said. but damn, this should be.

set str:3 chars "---"
set arr: offset 3 chars "xyz"

for range 0 100 [print\n it]
for offset 0 range 0 100 [print\n it]

regex [insert regex here]  # returns C-style compiled regex function?
regex [insert regex here]  # returns C-style compiled regex function?

(define (interleave lst1 lst2)
    (apply append (map list lst1 lst2)))
(interleave '(1 2 3) '(4 5 6))  ; => '(1 4 2 5 3 6)

let interleave [
    args [lst1 lst2]
    let [lst3] []
    for enumerate lst1 [set lst3:(quote it.value) lst2:it.index
    lst3
]
# I thought it would be simpler, but maybe not.
# also... how do I do this?
arr[indexes[i]] = ...;
set arr:indexes:i ...
# I guess you can index with a list, right?
# except you can, because of multiple assignment. that you still accept strings...

# these two are different? that's the only thing I can think right now.
set arr:indexes:i ...
set arr: indexes:i ...

let interleave [
    args [lst1 lst2]
    let lst3: quote lst1 lst2
    lst3
]
# this works??
let interleave [
    let lst3: quote args 2
    lst3
]
# but is there no way to one-line it?
let [ls] interleave [1 2 3] [4 5 6]
let ls: quote [1 2 3] [4 5 6]

let ls: [1 2 3]
# vs
let [ls: 1 2 3]
# should they be different?

# swap
let [ls] [1 2]
set [ls] [ls:[1 0]]

# css, basically.
[h1] [
    color BLUE
    background-color BLACK
]
let [main] [
    [h1] "Hello, World!\n"
    [div] []
]

print view [
    h1 style [color BLACK] "Hello, World!\n"
]
# outputs [
    [element] [h1]
    [style] [color BLACK]
    [content] "Hello, World!\n"
]
# I have to say: the whole [h1 style [] class [] []] type of chain is just so nice.
# one of the best parts of the language.
# like with [for list as value []].

let thing view [
    div [
        h1 style [color BLACK] "Hello, World!\n"
        h2 style [color BLACK] "Goodbye, World!\n"
    ]
]
print thing
# outputs [
    [element] [div]
    [style] []
    [content] [
        [element] [h1]
        [style] [color BLACK]
        [content] "Hello, World!\n"
    ] [
        [element] [h2]
        [style] [color BLACK]
        [content] "Goodbye, World!\n"
    ]
]
# something like this?

print thing.div.h1.style
# that's how it should work, but that doesn't follow the current model.

# outputs [
    [div] [
        [h1] [
            [style] [color BLACK]
            [content] "Hello, World!\n"
        ]
        [h2] [
            [style] [color BLACK]
            [content] "Goodbye, World!\n"
        ]
    ]
]
# then again, no. there are multiple divs, so there will be confusion.

make-step v [dt .5]
make-step v -dt .5

make-step v []
make-step v
# ^ is better.

# also, like python, required comes first (by convention).
let make-step [
    args [v]
    opts [dt 1]  # [-] is added by the function.
    print\n dt
]
# it's best this way because [print\n] may also have optional arguments.
# then again... if you put [-dt] in a required spot, there's no ambiguity, right?

make-step v dt .5
make-step v
dt other-thing
# yeah, not good. [-] should be a convention. only used when expected as symbol.
# no need for redundancy. the earlier [make-step] definition is correct.

let make-step [
    args [v]  opts [dt 1]
    print\n dt
]

# by the way, when passing a number when expecting a string, should it be treated as a reference?
# no overload, basically. – well, there is, but it's on references/values acting the same.
# like with [ptr .field].

let cc [
    args [filename]
    opts [o "a.out"]
    compile filename o
]
cc "main.txt" -o "main"

let cc [
    args [filename]
    opts [o "a.out" -output "a.out"]
    compile filename -output
]
cc "main.txt" --output "main"
# now, though...

# should I add this?
opts [o -output "a.out"]
# I mean, I guess I could, but I also think it's rare enough that I don't need it.
# it also doesn't fix this problem:
compile filename o  compile filename -output
# I don't think python does this, so I don't see why I should.

# destructuring with defaults
function createUser({ name, age = 18 } = {}) {
    console.log(name, age);
}

createUser({ name: "Alice" });  // "Alice 18"
createUser();                   // undefined 18

# in my language
let create-user [
    extract [name [age 18]] arg
    print "% %\n" name age
]

create-user [[name] "Alice"]  # "Alice 18"
create-user []                # error

args [value1 value2 [func1 func2 func3]]
# ^ [func1-3] are unquoted.

# anyway, I don't know about treating any number as functions when expecting a string.
for [0 1 2] [print\n it]  # good.
for 3       [print\n it]  # also good.
# and anyway, what benefit do you get by passing it by reference? for loops work by value.
let [list] [0 1 2]
for index list [print\n list:it]

fn main() {
    let fruits = vec!["apple", "banana", "cherry"];

    for (i, fruit) in fruits.iter().enumerate() {
        println!("{}: {}", i, fruit);
    }
}

let main [
    let [fruits] ["apple" "banana" "cherry"]

    for enumerate fruits [
        extract [index value] it
        print\n "%: %" index value
    ]
]

let main [
    let [fruits] ["apple" "banana" "cherry"]

    for enumerate fruits [
        print\n "%: %" it.index it.value
    ]
]

fn main() {
    let fruits = vec!["apple", "banana", "cherry"];

    for it in fruits.iter().enumerate() {
        println!("{}: {}", it.0, it.1);
    }
}
# well... being shorter than rust isn't much of an accomplishment.

# I think it's maybe not idiomatic, but in keeping with the spirit of the language, you should be
# able to explicitly type everything if you really want to.

let [list] [1 2 3 4]
[0]list
0:list
:+ 1 1 list

x.vec
.vec x

obj.func "hello"
.func obj "hello"
func.obj "hello"
func:obj "hello"
func: obj "hello"

let [list2] [5 6 7 8]
:list :list2 0
list: 5
list: list2:0
# what a pain in the ass.

let ptr to [true]
print\n ptr:0  # outputs true
let func [
    args [ptr]
    set ptr:0 false
]
print\n ptr:0   # outputs false
print\n ptr     # outputs 0xFFFFF...
print\n of ptr  # outputs [false]

print\n $^ ptr  # outputs [false]
print\n ptr^  # outputs [false]

let ptr ^[true]

let ptr to [true]
let val of ptr

let ptr &[true]
let val *ptr

# this should probably be syntax, because of how often it's done.
# then again, it's impossible. not with the way function calls work (no parentheses).

print\n ptr-list:0^   # now that's fucked.
print\n *ptr-list:0   # maybe?
print\n *ptr-list :0  # different?

# maybe [debug] works like rust? it prints, then returns? also, maybe it just takes all multiple
# return values, but also does multiple return after printing? that sounds useful.

# I think [$^] and [^$] might just be the way to go.

let ptr to [true]
let val ot ptr
# no...

print\n $^ ptr
print\n *ptr
print\n ptr

list:1
list.[1]

obj.i
obj:i
# it's more powerful if we do both [.] and [:].

map [pair] quote import "File"  # returns [["open" []] ["close" []] ...]
for map [pair] quote import "File" [
    print "%: %\n" it:0 it:1
]
# outputs open: []\nclose: []\n...

map [+] [1 2 3 4 5 6]  # returns [3 7 11]
map [+] [1 2 3 4 5  ]  # error: insufficient arguments for [+].
# that's interesting.

map [group 3] [1 2 3 4 5 6]  # returns [[1 2 3] [4 5 6]]
let pair  [group 2]
let quote [group 1]  # maybe? but maybe not. we need it not to evaluate things.

let then [
    let cond pop
    if cond [arg] [cond]
]
let else [
    if pop [arg] []
]
# nevermind. faster to just do this.
let then [
    if args 2 []
]
then cond [print\n "yes"]

# oh my god!
if cond [print "yes"] []
if cond then [print "yes"]
if cond else [print "no"]

let then [ arg [] ]
let else [ [] arg ]

# well, it's intersting. but interesting is not shorter.
if cond [print "yes"] []
then cond [print "yes"]
guard cond [print "yes"]
# I could maybe do [guard], but for once, I think it's better to just use [if], always.

# right, I can't forget about this:
let else [arg]
if cond [] else []
if cond [] []
# really optional, but may help readability.

if true [
    print "the value is 'truthy'."
    halt
] else [
    print "the value is 'falsey'."
    continue
]

# I guess there's no way to do [else if]? unless...
if true [
    print "the value is 'truthy'."
    halt
] else-if false [
    print "the value is 'falsey'."
    continue
] else [
    print "that's not possible... how?"
]
# yeah... but the input is not lazy.
# I guess if you avoid giving the condition side-effects, it's good?

cond [
    true [
        print "the value is 'truthy'."
        halt
    ]
    false [
        print "the value is 'falsey'."
        continue
    ]
    _ [
        print "that's not possible... how?"
    ]
]
# this makes more sense, since the list is evaluated from the top, it can stop evaluating anytime.
# also, I suppose [_] is just assigned to [true] at the start.
# I guess it breaks if it finds a match?
# though, I suppose it's not hard to create a fallthrough function? it's basically identity, but it
# overflows from the function block and execute the next condition. nice and elegant.

.. [
    print "Hello, World!\n"
]

print match value [
    0 "the value is 0\n"
    1 "the value is 1\n"
    _ format "the value is %\n" _
]

print match value [
    for 2 [ it, format "the value is %\n" it ]
    _ format "the value is %\n" _
]
# god... this is nice.

import "Debug" .step-into [print "Hello, World!\n"]
import "Debug" .step-into 2 [print "Hello, World!\n"]

let T 1
let F 0

if T [
    print "it's true."
] else-if F [
    print "it's false."
] else [
    print "stop."
]

let is-open true
let is-open T

print bool true  # outputs "true"
print bool T     # outputs "T"

# I think there is merit to [T] and [F], but I don't know.
# the values being capitalized makes sense, since they are constants, though. like python.

# oh. my. god.
for ! T [ print "is true." ]
if ! T [ print "is true." ] []
guard ! T [ print "is true." ]
# okay, that's how I'll do single if statements. it's too clever not to.

while true [ print "is true." ]
while T [ print "is true." ]
while 1 [ print "is true." ]
loop [ print "is true." it ]

# wait, no.
for 0 [print "forever "]
# there's probably a benefit to having [it] increment infinitely...
# and the fact that [it] is assigned, it'll cause problems if the "[if]" statement is inside
# another [for] loop.
# let's just use [if]. it's the best for short code, and for refactoring.

[field1 123] get "field1" pop

# maybe I don't need a string append?
let [IObject] + IOther + IThing [
    field1
    field2
]
let [obj] new IObject [...]
# I mean, there's a \n right there ^

# (old thing from there)
.. map [.. #import] [
    "Basic"
    "File"
    "String"
]
# hmm...
use map [use import] [
    "Basic"
    "File"
    "String"
]
# of course, this is redundant now.
use import [Basic File String]

let obj [
    let [name] "John Smith"

    let method [
        print\n name
    ]
]
obj.method  # outputs "John Smith\n"
# or even
let obj [
    let [name] "John Smith"
]
let obj.method [
    print obj.name
]

# [let obj.method] feels so wrong, but it makes so much sense for initializing a field...
# anyway, I think I should have this. function objects sound really nice.
u32 123
u32.max
# also, they make sense for this:
import "File" .open "file.txt"
# okay, nvm. I thought I was unto something with [import], but no.
# still think [u32.max] is good though. and I want a way to change [let] statements inside
# functions. like optional arguments, but more definite. I mean, might as well overload on whether
# or not it's function or a string. it's right there.

# also, [static] becomes easy.
let func [
    let i 0

    if < i 10 [
        set func.i + 1 i
    ] [
        print "the value has reached it's maximum.\n"
    ]
]
func func func func func func func func func func
func  # outputs "the value has reached it's maximum.\n"
func  # outputs "the value has reached it's maximum.\n" again
print\n func.i  # outputs 10

# right, this is what I want to do with [import] and function objects.
python -m http.server 8000
# but it's better to do it like this
import "HTTP" .serve 8000

let Server [
    format [
        [server-address RequestHandlerClass] % %
        serve-forever [
            let [host port] .. server-address
            ...
        ]
    ]
]
let [server] Server ["localhost" 8000] SimpleHTTPRequestHandler
server.serve-forever
# not very ideal, is it? I can't do this for example.
let [server] new Server [["localhost" 8000], SimpleHTTPRequestHandler]
# maybe...
let [Server] [
    new [
        args [this.[server-address RequestHandlerClass]]
        this
    ]

    serve-forever [
        let [host port] .. this.server-address
        ...
    ]
]
let [server] Server.new ["localhost" 8000], SimpleHTTPRequestHandler
server.serve-forever
# then again, this is more scuffed.
let [Server] [
    [server-address RequestHandlerClass] % %
    serve-forever [
        let [host port] .. server-address
        ...
    ]
]
let [server] format Server ["localhost" 8000], SimpleHTTPRequestHandler
# why is this the most elegant...
# a little dangerous, though.
let [Server] [
    [server-address RequestHandlerClass] % %
    serve-forever [
        let [host port] .. server-address
        ...
        print "% % %"
    ]
]

let [Server] [
    [constructor] [server-address RequestHandlerClass]
    [fields] [
        [field1] 123
        [field2] 123

        serve-forever [
            let [host port] .. server-address
            ...
        ]
    ]
]
# or maybe [new] assigns depending on the type?
let [Server] [
    [server-address RequestHandlerClass]  # initialized by constructor

    serve-forever [  # during definition.
        let [host port] .. server-address
        ...
    ]
]
let [server] new Server [["localhost" 8000], SimpleHTTPRequestHandler]
server.serve-forever

let [Server] struct [
    [server-address]
    [RequestHandlerClass]
] [
    serve-forever [
        let [host port] .. server-address
        ...
    ]
]
# interesting, but I don't feel it.

let [Server] [
    new init [server-address RequestHandlerClass] []

    serve-forever [
        let [host port] .. this.server-address
        ...
    ]
]
let [server] Server.new [["localhost" 8000], SimpleHTTPRequestHandler]
# now that I think about it, if I have [Server.new] I also have [server.new], which is useless...

let [Vector3] [x y z]
let [vec] new Vector3 [1 2 3]
# ^ I should go with the assuption that this works, and work around that.

# huh.
let [Object] [
    field1 field2 field3      # to be bound
    method [print "hello\n"]  # already bound
]
let [obj] new Object [1 2 3]  # only binds to [field1 field2 field3]
# but
let [obj] new Object [1 2 3 4]  # causes problems, because [method] is bound to 4
# this is extremely unsafe, but also very short... and it works with the old model!
# I think I'm unto something. [new] is even handling all the shit!

# I think the best solution is the easiest one.
let [obj] new Object [1 2 3 4]  # error: [print "hello\n"] is not a field.
# or more simply, the fields have to be unquoted. it's prevention incorrect argument count.
# also
let [obj] new Object [1 2]  # this is valid.
print obj  # outputs [field1 1, field2 2, method [print "hello\n"]]
# it can even be useful!

# hmm, I think I'm unto something, but I really need to flesh it out.

let [Object] [
    field1 field2 field3
    method [print "hello\n"]

    random-value random 0 100  # function call...
]
# that's tough. fields should be assignable to eagerly computed values.
let [obj] new Object [1 2]  # in other words, I can't do this.

# in that case, I can also do this, since the argument count is fixed.
let [Object] [
    [field1 field2 field3]
    random-value random 0 100
    method [print "hello\n"]
]

# huh.
new [1 2 3] [4 5 6]  # returns [1 4 2 5 3 6]
# I guess it's not exactly interleave, since the left most value is quoted, but it's close.
# should interleave behave the same then? (minus the quoting part, of course.)
interleave [1 2 3] [4 5 6 7 8 9]  # returns [1 4 2 5 3 6 7 8 9]
# maybe.

# honestly, so much brainstorming... and I finally found a very simply yet dangerous solution.
# I think I'm going to stick with it, for now.

# what does this do?
new 3 Vector3 [1 2 3]

new [x] [1]  # returns [x 1]
new [1] [1]  # returns [1 1]
new  1  [1]  # returns ?

# huh.
let Vector3 [2 [x y z 3]]
new Vector3 [1 2]    # returns [x 1 y 2 z 3] ?
new Vector3 [1 2 3]  # error: Vector3 expected 3 arguments.
# no, I don't think so. new throws an error anyway, and [Vector3]'s definition is ugly. but I may
# be unto something.

let [Vector3] [x y z]
new T Vector3 [1 2 3]
new F Vector3 [1 2 3]

maybe it's simpler to just take a pointer.
new Vector3 list-ptr  # this makes sense, so [Vector3] should also accept pointers for symmetry.

# I just realized: the [] in [new Vector3 [1 2 3]] is now mandatory, since [new] itself doesn't
# know how many argument to have.

# I think no two functions should do the exact same thing.

map [print\n] [1 2 3]  # returns [print\n 1 print\n 2 print\n 3]
.. map [print\n] [1 2 3]  # outputs 1\n2\n3\n

map [+] [1 2 3 4]  # returns [+ 1 2 + 3 4]
print map [+] [1 2 3 4] :0  # returns 3
print map [+] [1 2 3 4] :1  # returns 7
# no, it can't return like that. we don't know how many arguments [+] or whatever takes, so it
# needs to be evaluated before returning. 'tis a shame.

# [args] and [opts] at top level.
args [text]
print text

    $  0 main.txt "Hello, World!\n"  # outputs "Hello, World!\n"

opts [twice 0]
if twice [print text] []

    $  0 main.txt "Hello, World!\n" -twice 1  # outputs "Hello, World!\n" x2

togl [twice]

    $  0 main.txt "Hello, World!\n" -twice  # outputs "Hello, World!\n" x2

# if there's not top-level arguments/etc., but you still pass some.

    $  0 main.txt "Hello, World!\n"  # outputs "Hello, World!\n" anyway.
    $  0 main.txt "Hello, World!\n" > file.txt

# heh, needs refinement.

compile [
    print "Hello, World!\n"
] -- [
    target x86_64 platform linux
]
let compile [
    args [main]  opts [-]
    ...
]

compile [] [
    print "Hello, World!\n"
]
# ^ this is maybe better.
# I don't like miking optional arguments and options tables. do one or the other.

compile [] [
    print "Hello, World!\n"
] -target x86_64 -platform linux

let value auto 123
let value u32  123
# I guess unless you unfer it back to [auto], the type of value will remain [u32]?
set value "hello"  # error: [value] cannot be implicitly reassigned.
let value "hello"  # fine.

# nah, I don't need this.
# [u32] is only there because you can't infer it. [auto] and [string] and whatever don't exist.

let [obj] [
    field1.[
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    field2.[
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
]
print\n obj.field1.sub-field2  # outputs 2
# I guess?
# alternatively:
let [obj] [
    [field1] [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    [field2] [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
]
# or going further with the earlier example?
let obj.[
    field1.[
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    field2.[
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
]
# huh.
let vec.[x 1, y 2, z 3]
let vec.[x y z] [1 2 3]
let [Vector] [x y z]
let vec.Vector [1 2 3]
# maybe it's different than this?
set vec.Vector [1 2 3]
# no. [let] works essentially the same, except for this one thing. I don't like that.
set vec:quote Vector [1 2 3]

let obj [
    field1 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    field2 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]

    method1 {...}
    method2 {...}
]

let square {* .}
let square [* .]

let vec {x 1, y 2, z 3}
# maybe it's represented without [brackets] or {braces}?
# ah, but again, it's {} and [] are different, so should "". and now, a lot of problems.
# maybe it's only for literals, though?
let temp {* .}
let square temp
# yeah, even if passed by symbol, the literal is processed then.
map {+ 1} [1 2 3 4 5]
map [+ 1] {1 2 3 4 5}
# I guess there should be a difference?
# no, the problem has only ever been for the assigment part of things. everything else is fine.
# then again, I guess I could make this work?
let map [
    args {fn ls}
    ...
]
# you know what? nevermind. the biggest problem is that it's ugly, and I can't have that.

let square fn [* .]

let obj [
    field1 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    field2 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]

    method1 fn [...]
    method2 fn [...]
]

# if you do this, [map] will just convert it. that's one way to prevent crashes.
map [+ 1], fn [1 2 3 4 5]  # or maybe it should throw?
# yeah, that was the reason I didn't want [fn].

let func  [...]
var value [...]
# this might be best... except it doesn't solve the objects problem! fuck!!
# if I do decide to add another way to do functions, [fn] seems to be the cleanest way.

# like, [square] is nice and all~
let square [* .]
# but you're forgetting that everything else pays the price.
let [arr] [1 2 3 4 5]

let func fn[...]
let func ()[...]
let func .[...]
let func :[...]

let func : [...]  # is nice.

let obj [
    field1 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]
    field2 [
        sub-field1 1
        sub-field2 2
        sub-field3 3
    ]

    method1: [...]
    method2: [...]
    # but it does break array indicing.

    method3 .[...]
    method4 .[...]
    # this is the nicest looking one.

    method5 fn[...]
    method6 fn[...]
    # [fn] feels different when you stick it together like that.

    method7 $[...]
    method8 $[...]
]

let square fn[* .]  # I might actually use this. it tickles me. and it's obvious, more importantly.

let Vector3 quote [x y z]  # ["x" "y" "z"]
let vec: Vector3 [1 2 3]
# it... kind of makes sense? almost feels like rust...
# anyway, I don't think object assignments have changed much at all~

for 10 [set vec:it list:it]  # uh...

let [obj field] [field "hi"], ["field"]
set vec:field "hello"
# maybe it makes sense? quoted things should be reprensented diffenrently?
# but I don't want people to do this.
let Vector3 [[x y z]]
# still I really think I'm unto something with
let vec: Vector3 [1 2 3]
let [vec] new Vector3 [1 2 3]  # is no longer valid.
let vec new Vector3 [1 2 3]  # not as nice.
# maybe arrays are really just tables?
let arr [1 2 3]
for arr [print\n it]
let 1 "something else"  # would maybe just index something in the hashmap?
# we established that value and [value] have no difference,
let obj [
    value 123
    [value] 321
]
# so 1 and [1] should be the same.
let obj [
    1 123
    [1] 321
]
let arr list[1 2 3]  # [0 1 1 2 2 3]
for arr [
    print "%: %\n" id it
]
# this is very similar to lua...
# but I don't like it.

map [+ 1] list[1 2 3 4 5]
# I guess you can still [car] and [cdr], which makes sense, since you have to traverse the list to
# find what you want. but how do I low-level this?
get 1 arr  # still works?
let arr:-1 "test"  # [-1 "test"]
set arr:.5 "test again"  # [-1 "test", .5 "test again"]
arr..5  # error?
arr:5 arr:"5"  # any difference?
arr.5 arr.[5]  # now, there SHOULD be a difference!
# I guess there is: [eval] is called or not on it...
# I suppose it's consistent, if anything. everything is a prototype.

let Vector3 [x y z]
let vec: Vector3 [1 2 3]  # [x 1, y 2, z 3]
let arr [1 2 3]
let vec: range 0 3 arr  # [1 2 3]

let [[obj]] "hello"  # redundant, maybe?

# by the way, I kind of glossed of that, but damn, tuples are nice.
let tuple fn[123 "hello"]
let [number string] .. tuple
let [number string] tuple:0, tuple:1

x = 1, y = 2
[x y z] = 1 2 3
func = fn[
    print "Hello, World!\n"
]
# nah...

let main $[
    print "Hello, World!\n"
]
# [$] is a good contender.

let File import File  # I mean, I could. no reason not to.
import File .open "file.txt"
# hell, I could just have all the modules already in here.
# they are just ignored because they aren't used.
use File

# it depends on directories?
.../File/functions.txt  # [File.open] & [File.close] & ...
.../File/More/functions.txt  # [File.More.misc] & ...
# makes sense.
# though to avoid conflicts:
let func [...]  # ./functions.txt (were main is)
this.func

use [
    open  [...]
    close [...]
]
open  # returns [...]
# ^ I like this... but I can't do this.
use [File OS HTTP String]
# honestly, [use] for assignment is redundant with [let]... though it's a good alternative if you
# need [:] style assignment?
use File
use OS
use HTTP
use String
# nah, let's use [use] for it's intended purposes.
# wait...

for [
    open  [...]
    close [...]
] [use it] -here
# or?
for [
    open  [...]
    close [...]
] fn[use it]

let my-list ls[1 2 3 4 5]
let my-func fn[1 2 3 4 5]

# equivalent?!
let [[my-func]] [print\n "hello"]
let [my-func] fn[print\n "hello"]

args [[func] list]  # maybe?

fn     nb value  # error: cannot convert number to function.
fn any nb value  # ok
fn! nb value     # ?
# maybe I should just have types, what with the whole putting [fn] everywhere and stuff...

let func fn[
    args [value]
    print\n str value
]
func "hello"  # outputs "hello\n"
func 123      # error: expected [string], but got [number 123]
# [number 123]... I guess that's how they are represented?
# and any is just 123?

let Vector3 fields[x y z]
let vec: Vector3 [1 2 3]

match type value [
    u32 or u64 or i32 or i64 []
    _ [error "not found"]
]

let func fn[
    args [String value]  # maybe I could?
    print\n value
]

# in any case, it's interesting, but it doesn't work, again.
let func fn[
    [print\n "hello"]
]
fn func  # ... or I guess it does?

# fn, str, char, obj, num, list, type, any

let nums u32[1 2 3 4 5]
let other-nums u64 nums

# uh... I think I need to take a step back.

let str."Hello, World!\n"
print str
# ^ actually works!
let [str] "Hello, World!\n"
# and much shorter.
# maybe the solution was here all along?
# I'm not adding any feature. just using what was already there.
# I'm postponing the whole type fiasco, and using this.

let vec.[x y z] 1 2 3  # wait, what happens here?
# I don't think this is valid.

let str."Hello, World!\n"
str.Hello,  # technically valid, but will crash.

let [vec] [x 1, y 2, z 3]
let [vec] mut vec.[x 10]  # [x 10, y 2, z 3]

if [then] [else] condition

let func [
    if [
        print "bigger than 0\n"
    ] [
        print "smaller than 0\n"
    ] < 0
]
func  123  # outputs "bigger than 0\n"
func -123  # outputs "smaller than 0\n"
let func [
    if [ print "between 0 and 100\n" ] [ print "not\n" ] && < 100 > 0 .
    if [ print "bigger than 0\n" ] [ print "smaller than 0\n" ] < 0
]
func  123  # outputs  "bigger than 0\n" "not\n"
func -123  # outputs "smaller than 0\n" "not\n"
func   66  # outputs  "bigger than 0\n" "between 0 and 100\n"
# this is such a pain.

let Vector.[x y z]
let vec: Vector [1 2 3]
# I love it. I just love how it gives the illusion of a type.

let arr .[1 2 3]  # even better!

let true [
    args [a b]
    .. a
]
let false [
    args [a b]
    .. b
]
true [print\n "yay"] [print\n "nay"]
let if [
    args [condition true-branch false-branch]
    .. condition true-branch false-branch
]
print\n < 1 0  # outputs [false]
.. < 1 0 [print\n "yay"] [print\n "nay"]  # ... so [if] is just [..] in disguise?
# no... it works so much better in scheme, where passing functions by value is easier.

let POINTER_LIST.[0x0 ."value1" 0x1 ."value2]
let ptr 0x0
get ptr  # returns "value1" ?
# because how do you represent pointers otherwise?
# so any number in the env is effectively a pointer?
# it makes sense, since a program should only be able to access it's own memory.

let func ptr-to [print "hello\n"]
func  # outputs "hello\n"
val-of func  # returns 0x...
let [func] ptr-to [print "hello\n"]
print\n func  # outputs 0x...
# so like, quoted numbers behave like values?

# that's an interesting thought, but no.
let a 1
+ 1 1
+ a a
# ^ equivalent, so no choice but to make them normal.
# and anyway, it doesn't bring anything to the table.
# pass by reference functions are dumb.

let [obj.field .sub-field1 .sub-field2] 1 2
obj.field.sub-field1  # returns 1

# the best model
list: 5   # actual index
list:"5"  # key

let list.[0 1 2 3 4 5 6 7 8 9 10 11 12 13]
reduce [for 10 [get it] list]  # returns [0 1 2 3 4 5 6 7 8 9]
# btw list only copied once.

let obj: Object [1 2 3]
for 0 [import "Debug" .step-into it code let [_] read-key]
map [reduce [args 3]] [1 2 3 4 5 6]  # returns [[1 2 3] [4 5 6]]

print object []  # better?
# no, I think I should do this.
print-object [x 1, y 2, z 3]
print-function [print "Hello, World!\n"]
print-bool T
# this is useful – not just for the formatting, but also if it has [%] inside.
# maybe even this?
debug-object [x 1, y 2, z 3]
debug-function [print "Hello, World!\n"]
debug-bool T

(define x 1 2 3)
(define  x  "calculate")  # calculate called as func (eager)
(define (x) "calculate")  # calculate is string
# so a function is just lazy... there is no difference otherwise
(define (square) * .)  # can you do this? probably not.
(define x print 123) (x) # outputs 123, x equivalent to (print 123)

(let (x) 1 2 3)      # multiple return.
(let (x y z) 1 2 3)  # multiple assign.

(let (say-hello) (print "hello\n"))

(let (func) (for args (print\n it)))
(func 1 2 3 4)  # outputs "1\n2\n3\n4\n"
(let (func) (print args))
(func 1 2 3 4)  # outputs 1 2 3 4
(func print "hello\n")  # outputs print "hello\n"
(let (func) (args))
(func print "hello\n")  # outputs "hello\n"

(for (1 2 3) (print\n it))
(let list 1 2 3)
(for (list) (print\n it))
(let (a b c) 1 2 3)
(for (a b c) (print\n it))

(let value (+ 1 1))
value -> 2

(let (value) (+ 1 1))
value   -> (+ 1 1)
(value) -> 2

(let (func)
    (print\n "hello")
    (print\n "goodbye"))
(func) -> (print\n "hello") (print\n "goodbye")

# (scheme)
(define func (quote (display "Hello, World!\n")))
(eval func)
# equivalent:
(let (func) (print "Hello, World!\n"))
(func)
# also equivalent
(define func (lambda () (display "Hello, World!\n")))
(let func (quote (print "Hello, World!\n")))
(let func (delay (print "Hello, World!\n")))  # better?
(let func (async (print "Hello, World!\n")))  # also possible.
(func)
# or any function can be called normally, or asynchronously?

(let (if) (args))
(if true (print\n "true") (print\n "false"))
(let (true ) ((get 0 args)))
(let (false) ((get 1 args)))
((< 0 1) (print\n "true") (print\n "false"))

(let (func) (+ args))
(func 1 2)  # returns 3

(for (1 2 3) (print\n it))
(for (delay (1 2 3)) (print\n it))
(let (for) (args list body)
    (when (not (empty? list))  # god, this is verbose.
        (let it (car list) (body))  # hmm... I don't think so. but I don't know how else yet.
        (for (cdr list) body)))
(for (1 2 3) (as value (print\n value)))
for [1 2 3] as value [print\n value]
# damn, model 1 is so much cleaner. I don't think anything will come of model 2, but let's continue
# observing. it's very intersting.

(when (not (empty? list)) (print\n "not empty"))
if list [print\n "not empty"] []
# I mean, wtf?

(map (+ 1) (map (+ 2) (1 2 3)))  # here, the inner map is treated as a list, not a function.
# it won't be called, because of that. and therefore, there's a bug.
# unless I can figure this out, this model is DOOMed.

(map [+ 1] (map [+ 2] [1 2 3]))  # this maybe makes more sense?

# but it causes problems? (while solving others)
(let  func  (+ 1 1))
func -> 2
(let [func] (+ 1 1))
 func  -> (+ 1 1)
(func) -> 2
(let symbol "func")
(let (symbol) (+ 1 1))
(func) or (symbol) or ([func])
# so like, [] is equivalent to delay.
(let [func] (print "Hello, World!\n"))
(let func [(print "Hello, World!\n")])
# equivalent:
(let (delay func) (print "Hello, World!\n"))
(let func (delay (print "Hello, World!\n")))

(let [func] (* (dup)))
(func 2) -> 4  # because [dup] is called first?

(let func [(args name) (print\n name)])
(let [func] (args name)
    (print\n name))
(func "John")  # outputs "John"
([(args name) (print\n name)] "John")  # outputs "John"

(let print-line print\n)
(print-line "hello")
(let [print-line] print\n)
((print-line) "hello")

(let value)  # declaration, but not definition
(value 123)  # error: "value" is not a function.

()  # nothing happens?
[]  # empty string, basically.
""  # ^

(for (args) [print\n it])
(let [func] (+ (args)))
(func 1 2)  # returns 3
# there's a problem here.

(let [func]
    (for args [print\n it]))
(func 1 2 3) -> ((for args [print\n it]) 1 2 3) (for [1 2 3] [print\n it])
(let [func] (+ (first 2 args)))
(func 1 2)

let func [+ 2]
func 3
(let [func] (+ 2))
(func 3)

((for args [print\n it]) 1 2 3)  # outputs "1\n2\n3\n"
# it reduces to () so nothing happens.
# also.
(let func [(print\n "hello")])
(func)  # becomes (print\n "hello"), not [(print\n "hello")]
# (delay (print\n "hello")) has already been called.
(for args [print\n it]) 1 2 3

# wait
[1 2 3] -> 1 2 3  # right? since [] isn't actually a list or anything.
(for args [print\n it])
(+ args)  # both are valid!

(+ [1 2])
(+ 1 2)
# okay, nvm. this shouldn't be the same.

(+ 1 2)
(((+) 1) 2)  # equivalent?

(let [func] (print\n args) (print\n args))
(func 1 2 3)
([(print\n args) (print\n args)] 1 2 3)
# yeah, you need [], otherwise...

# should I throw an error if the arguments are unused? I should, but then again...

# something has been bothering me for a while.
(let x 1 2)
x -> 1 2
(+ x) -> 3

(let [list] 1 2 3)
 list  -> [1 2 3]
(list) ->  1 2 3
# right?
# so like
(let [func] (+ (args)))
(func 1 2)
# it works a bit like [..].
# ... not 'a bit', a LOT!
.. [print\n "hello"]
([(print\n "hello")])
.. [1 2 3]
([1 2 3])

(let [func]
    (print\n "started")
    (print\n args))
# ... I don't think I can do currying, though.

(let vec [1 2 3])
(let [x y z] (vec))
# but that doesn't work, since [] makes it lazy.
(let func
    (print\n "hello")
    (print\n "goodbye"))
# this is lazy then?

# btw.
(let [x y z] (args))
# also, we can do discards.
([(let [x y] (args))] 1 2 3)

# I think it makes more sense for just the function to be able to do multiple return.
# variables should be capable of discards instead. it works well with (args)

(let x 1)
x -> [1]  # that's... well, weird.
(x) -> 1
# I... can't proceed, unless I figure this out.

(let func [
    (print\n "hello")
])
(func)
(let str "hello")

(let x 1 2 3)
x -> 1 2 3
(let [x] 1 2 3)
x -> 1

(let func  [(print\n "hello")] 1 2 3)
(func) -> ([(print\n "hello")] 1 2 3)
# I think this is good.

(let [x y z] 1)  # error: insuffient argument count

(let print\n [(print "%\n" (format (args)))])
let print\n [print "%\n" format]

(let square [(* (dup (args)))])
(let square [(* . dup . args)])  # surprisingly the same char count.
(let square $ (* . dup . args))  # in other words, useless feature... though it looks nice.
(let square $ . * . dup . args)
(let square $.*.dup.args)        # maybe?
let square [* dup]
(square 5) -> 25
 square 5  -> 25

# I've played with this shit a lot, but it's obvious I'll never implement it.
# maybe it's time to put it to rest?

let map [
    let [list] reduce + args 2
    + car list, if cdr list [map func, cdr list] [[]]
]
let [list] [1 2 3 4]
car list -> 1
cdr list -> [2 3 4]
map [+] list -> [3 7]
# what if list is a pointer?

(let apply [
    (let [operator operands] (car args) (cdr args))
    (operator (operands))
])
(apply + [1 2 3 4])
# honestly, I'm starting to think scheme is cleaner.
# well, I could probably make it cleaner, but at that point, I'd rather use scheme.

let my-queue: Queue []
my-queue.insert 1
my-queue.insert 2
my-queue.insert 3
my-queue.insert 4
my-queue.delete
my-queue.delete
print\n my-queue.get
# I don't know about this.
# anyway, if I did do it this way, there shouldn't be an overhead from the carrying the methods.
let my-queue.[]
use Queue
insert my-queue 1
insert my-queue 2
insert my-queue 3
insert my-queue 4
delete my-queue
delete my-queue
print\n my-queue
# you know, not going full OOP and stuff, but still having structures; seperating data and logic.
Queue.insert my-queue 5
# this is... nice.

use Queue
insert my-queue 5
delete Queue
insert my-queue 5  # error: Queue.insert is not bound. (or defaulting to basic list insert)
# so I guess [use] has to remember things.

# I should be able to do this.
import "Debug" .step-into [print "Hello, World!\n"]
import "Debug" .step-into 2 [print "Hello, World!\n"]
# but the program should able to detect bugs due to variable argument count.
let func [
    import "Debug" .step-into args 1
    print\n "fucking whatever"
]
func [print\n "hello"]
func 2  # error: expected string, got number.
# that or...
func [print\n "hello"]
func 2 [print\n "hello"]  # still valid. [args] is smart, and can figure things out?
# I think the second one is ideal.
# then again, isn't the first one already implemented?
# [.step-into] expects two arguments, but will only get one.
print
let x 1
# ^ like this.

let func [
    import "Debug" .step-into .. args 1
    print\n "fucking whatever"
]
func [[print\n "hello"]]
func [2 [print\n "hello"]]
# also works, I suppose.

# I love how I'm not using [/] anymore. I guess it was just a passing fad.
Queue/insert my-queue 1
# yeah, I don't like it.

use import "Basic"  # this might be required.

let [Basic] import "Basic"
Basic.+ 1 [2 3]  # returns [1 2 3]

# I should try making [Basic] as small as possible, so as to not have too much overlap.
# in other words, no pow operator – not that I need it with [* .].

using Queue [
    insert my-queue 1
    insert my-queue 2
    insert my-queue 3
    delete my-queue
    delete my-queue
]
# yeah, C# style is good too.

using [Queue Math] [
    insert my-queue 1
    delete my-queue
    log 10
]
# right, I can't forget that like [let], [use] is overloaded of the symbol type, not value.
# same with [using].

use list [File OS HTTP String]  # [list] removes quotes?
# I think I like this. although, it should probably be another value then [list], the whole
# chaining functions thing is extremely nice.

use list-of [File OS HTTP String]
use concat [File OS HTTP String]
use flat [File OS HTTP String]
# I need to find a good name...

use-for [File OS HTTP String]
using-for [File OS HTTP String] [
    open "file.txt"
]

# optional args?
use -for [File OS HTTP String]
use -$ [File OS HTTP String]

# maybe?! I mean, isn't it clever?
for [File OS HTTP String] use it
# no, the body should only be called once, if it's a symbol: to get the actual body.

# um, no. unfortunately.
for [Queue Math] using it [
    insert my-queue 1
    delete my-queue
    log 10
]

map [use  ] [File OS HTTP String] -here  # this works but...
map [using] [File OS HTTP String] -here  # this doesn't

use flat    [File OS HTTP String]  # only one layer?
use flatten [File OS HTTP String]  # flatten completely?
# ^ aside from the name, this seems to be the cleanest way of doing things.
using flat [File OS HTTP String] []

using in [File OS HTTP String] []
# [in] is pretty nice. typically used in [for] loops.

# it's still debatable if this is better than just using a macro.
use [File OS HTTP String]
use import [File OS HTTP String]
# ^ both valid.

let [File  ] import "File  "
let [OS    ] import "OS    "
let [HTTP  ] import "HTTP  "
let [String] import "String"

use in [File OS HTTP String]
use import [File OS HTTP String]
# I think, since I expect [use] to be used a lot, for it to be a macro like [let].
# it's not like macros are bad, or anything. they just have to be used in moderation.

let my-macro [
    let x 1
    let y 2
    let z 3
] -here
my-macro
print\n "x=%, y=%, z=%" x y z

print\n "#=%, #=%, #=%" x y z  # [#] for symbol – actually, while making this comment, I remembered
# that [#] was for making comments...

print\n "%=%, %=%, %=%" sym-val [x y z]

for fields obj []
for values obj []

for keys obj []
for vals obj []

html [
    <div>Hello, World!\n</div>
]

map (+) [1 2 3 4]  # returns [3 7]
# (+) being equivalent to [unquote []].
let func (
    print "Hello, World!\n"
)
func  # outputs "Hello, World!\n"
let func [
    print "Hello, World!\n"
]
func  # returns [print "Hello, World!\n"]
# if I do that, everything now has to also overload over functions as well...

# ...
let square [* .]
square  # returns [* .]
let square (* .)
square 5  # returns 25

let value [square]
let (value) (* .)
square 5  # returns 25
# so like, when it's a macro, {} allows you to circumvent it?

map (+) (1 2 3 4)  # and yet...

let func [
    import "Debug" .step-into args 1
    print\n "fucking whatever"
]
func ([print\n "hello"])
func (2 [print\n "hello"])
# you know, the earlier thing?
# anyway, it would just work. but also break things.

# wait, does it work? no, right? I mean, you have to run the thing, or bind it to a variable,
# then run it...
# I guess everything is a function, and everything is always run, you just don't realize it.
# it's not obvious.

let list [4 3 2 1 0]
set list: (1 2 3) [10 20 30]
print\n list  # outputs [4 10 20 30 0]

let obj []
set obj: [1 2 3] (10 20 30)
print\n obj   # outputs [1 (10) 2 (20) 3 (30)]
set obj: [1 2 3] [10 20 30]
print\n obj   # outputs [1 [10] 2 [20] 3 [30]]
# maybe I should seriously consider it?

use [
    open  (...)
    close (...)
]
use (File OS HTTP String)

# () is like a bubble: it pops easily.
# [] is more solid, harder to break.

let print\n (print "%\n" format)
let my-print (print)

set list: (1 2 3) [10 20 30]
let indices (1 2 3)
set list:  indices  [10 20 30]  # won't work!
set list: (indices) [10 20 30]  # better.

set list: $[1 2 3] [10 20 30]
let indices [1 2 3]
set list:   indices [10 20 30]  # also won't work!
set list: $ indices [10 20 30]  # also better.

let Vector3 [x y z]
let vec:   Vector3 [1 2 3]  # [x 1 y 2 z 3]
let vec: $ Vector3 [1 2 3]  # [x $ 1 y $ 2 z $ 3]
# like, they are functions and stuff?
let vec:   Vector3 [[...] [...] [...]]  # [x  [...] y  [...] z  [...]]
let vec: $ Vector3 [[...] [...] [...]]  # [x $[...] y $[...] z $[...]]
# because of the way tables work, [$] is run everytime you try to get a value.

# $[] symbol for the language?

let list: index-list:: index-index-list::: 0 123
# I guess this works? though it's hella ugly.
# but so is [..] for field access.

let list: index-list:index-index-list::0 123  # valid?

# anyway, I have a good feeling about [$]. I'll figure out [:] at a later date.
# [$] is solving one of my major gripes actually... you know, [:0] vs [:"0"].

# damn, that also means this.
let  value  [print\n "hello"]
let [value] [print\n "hello"]
# ^ now behave the same.

let [square] [* .]
let square $ [* .]
let square [* .]
let square.[* .]

[x  [...] y  [...] z  [...]]
[x $[...] y $[...] z $[...]]

[x [...] y [...] z [...]]
[x.[...] y.[...] z.[...]]

 square   # symbol
[square]  # list of symbols

map 1 [1 2 3 4]  # returns [1 1 1 1 1 1 1 1 1 1 1 1 1 ...]
# if
map [+] [1 2 3 4]  # returns [3 7]
# then again, no. not if you keep a copy of the original.

map $[+] [1 2 3 4]
# vs
map [+] [1 2 3 4]

map [+] $[1 2 3 4]

# [$] is now required when passing, because you can't do this.
args [[func] value]
# well, you can, but it's not very consistent.

# can't forget about this.
let value [[]]
let [value] []

let value []
let value.[]

# it is the shortest one, at the end of the day.
# it's unfortunate for [:], but I'll figure something out.

let func [
    args [[f]]
    f "hello"
]
func [print\n]

let func $[
    args [f]
    f "hello"
]
func $[print\n]
# these two are the same char length...
# a function is only defined once, but can be called multiple times.
# it's obvious which I should pick.

let func [
    args [f]
    .. f "hello"
]
func [print\n]

let func [
    .. arg "hello"
]
func [print\n]

let func $[
    let f arg
    f "hello"
]
func $[print\n]

let func $[
    arg "hello"  # not possible?
]
func $[print\n]
# and shit gets real fucked when you do [args 2].

let [value] 123
let [square] $ [* .]
let value 123
let square [* .]

func $[random]
func [random]
# ^ get random value everytime.

# convention: a function should only ever return a number or a quote. the same goes for passing
#             arguments to a function.

# instead of it being [unquote], how about making [$] be [quote]?

let Vector3 [x y z]
$ Vector3  # returns ["x" "y" "z"]
# or
$ Vector3  # returns [$ x $ y $ z]
# same length! though it doesn't really work, because of how tables work.
# [[x] [y] [z]] it is.

let vec:   Vector3 [1 2 3]  # [x 1 y 2 z 3]
let vec: $ Vector3 [1 2 3]  # [[x] 1, [y] 2, [z] 3]
let vec: Vector3 $ [1 2 3]  # [x [1], y [2], z [3]]
# yeah, I don't mind this. I was already using [quote] before. I just didn't like the word.

let vec:   Vector3 [[...] [...] [...]]  # [x [...] y [...] z [...]]
let vec: $ Vector3 [[...] [...] [...]]  # [x.[...] y.[...] z.[...]]
let vec: $ Vector3 [[...] [...] [...]]  # [[x] [...] [y] [...] [z] [...]]
let vec: Vector3 $ [[...] [...] [...]]  # [x [[...]] y [[...]] z [[...]]]
# I think I've taken a liking to this. now I just need to figure out how to do good indicing.

# [unquote] breaks things, [quote] can too, but in a chill way. (in a non-catastrophic way)

let list: [0 1 2] [1 2 3]  # [0 1, 1 2, 2 3]

let list.[0 1 2 3]
set list:  0  123  # [123 1 2 3]
set list: [0] 321  # error: field [0] not found.
set list: [2] 321  # [123 1 2 321]

set list: [[2]] 321  # [123 1 [2] 321]
set list: [2] [321]  # [123 1 2 [321]]

for $ fields obj []

# oh!
set list: [0 1 2] [1 2 3]  # [[0 1 2] [1 2 3]]
# I think I'm unto something.
set list: [0] 1  # [[0] 1]
set list: [0] [1]  # [[0] [1]]
# wait, no. I can't do that... [[0 1 2] 1 2 3] is how it works normally.
set list: [0 1] 1 2  # [[0 1] 1 2] ?

# maybe I really should just indexify everything?
# and the use [car] and [cdr] to actually parse things.

let list: Array [1 2 3]
for list [
    print\n "% %" id it
]

let list.[0 1 2 3]
set list: 0 123            # [123 1 2 3]
set [list: 1 2] 321 -123   # [123 321 -123 3]
# because technically, they're unquoted right?
set [list: [-123]]  -321   # [123 321, -123  -321 ]
set [list: [-123]] [-321]  # [123 321, -123 [-321]]

let [list:   [x]] "Hello, World!\n"  # [123 321, -123 [-321], x "Hello, World!\n"]
let [list: $ [x]] "Hello, World!\n"  # [123 321, -123 [-321], x."Hello, World!\n"]
let [list: [[x]]] "Hello, World!\n"  # [123 321, -123 [-321], x."Hello, World!\n"]
let [list: [x]] ["Hello, World!\n"]  # [123 321, -123 [-321], x."Hello, World!\n"]

let [list: $ [x y]] "hello" "bye"  # [123 321, -123 [-321], [x y] "hello" "bye"]
let [list:   [x y]] "hello" "bye"  # [123 321, -123 [-321], x "hello", y "bye"]

# I think I figured it out. though I still don't know about this.
let vec: Vector3 [1 2 3]
# vs
let vec: Vector3 1 2 3

let  obj:   "0"   1   # [ 0   1 ]
let  obj:   "x"   1   # [ x   1 ]
let  obj: $ "0"   1   # [[0]  1 ]
let  obj: $ "x"   1   # [[x]  1 ]
let  obj: $ "0"  [1]  # [[0] [1]]
let  obj: $ "x"  [1]  # [[x] [1]]
let  obj:   "0"  [1]  # [ 0  [1]]
let  obj:   "x"  [1]  # [ x  [1]]
let [obj:   "0"] [1]  # [ 0  [1]]
let [obj:   "x"] [1]  # [ x  [1]]
let [obj:    0 ] [1]  # [    [1]]
let  obj:    0   [1]  # [     1 ]
let  obj:    0    1   # [     1 ]
let [obj:    0 ]  1   # [     1 ]

# yeah, I think this is it. I don't see how I could improve upon it.
# you can get a [range] in the index list, you can expand the list.

let list.[1 2 3 4 5]
set [list: .. range 0 3] 10 20 30  # [10 20 30 4 5]
set [list: 0] [100 200 300]  # [[100 200 300] 20 30 4 5]
set  list: 0  [100 200 300]  # [ 100 200 300  20 30 4 5]
# I see.
set [list: 0 1 2] 10 20 30   # multiple indices.
set [list: 0] [100 200 300]  # just one index.
set  list: 0  [100 200 300]  # same here.
# how can I use this?
set  obj: [x y z]   [1 2 3]  # [[x y z]  1 2 3 ]
set [obj: [x y z]]  [1 2 3]  # [[x y z] [1 2 3]]
# I unironically feel so smart right now...
# did I seriously just do this?!

# wait.
let  obj:   "0"   1   # [ 0   1 ]
let  obj:   "x"   1   # [ x   1 ]
let  obj: $ "0"   1   # [[0]  1 ]
let  obj: $ "x"   1   # [[x]  1 ]
let  obj: $ "0"  [1]  # [[0]  1 ]
let  obj: $ "x"  [1]  # [[x]  1 ]
let  obj:   "0"  [1]  # [ 0   1 ]
let  obj:   "x"  [1]  # [ x   1 ]
let [obj:   "0"] [1]  # [ 0  [1]]
let [obj:   "x"] [1]  # [ x  [1]]
let [obj:    0 ] [1]  # [    [1]]
let  obj:    0   [1]  # [     1 ]
let  obj:    0    1   # [     1 ]
let [obj:    0 ]  1   # [     1 ]
# had to change a few of them, but it still works.

let  vec:      [x y z] [1 2 3]  # [[x y z] 1 2 3]
let [vec: .. $ [x y z]] 1 2 3   # [x 1 y 2 z 3]

let Vector3.[x y z]
let vec: Vector3 [1 2 3]  # [[x y z] 1 2 3]
# yep, got what I wanted. even better, actually, since I don't have to do [$ Vector3].
# wait, no... what am I smoking? if I don't have to use [$], how do assign a function?

let  vec:   [x y z]  [1 2 3]  # [ x  1  y  2  z  3]
let  vec: $ [x y z]  [1 2 3]  # [[x] 1 [y] 2 [z] 3]
let [vec:   [x y z]] [1 2 3]  # [ x  [1]  y  [2]  z  [3]]
let [vec: $ [x y z]] [1 2 3]  # [[x] [1] [y] [2] [z] [3]]
# not as elegant as before, but as hard to implement either.
# also, there would be a bug, if [x] in [x y z] was assigned, but not the other fields.
# it was never going to work out.

let Vector3.[x y z]
let vec:   Vector3 [1 2 3]  # [ x  1  y  2  z  3]
let vec: $ Vector3 [1 2 3]  # [[x] 1 [y] 2 [z] 3]
# I still got what I wanted. not "even better", but whatever.
# at least for [Vector3] I don't expect to use [$].

map $[+    ] $[1 2 3 4]  # [+ + + +]
map  [+    ] $[1 2 3 4]  # ["12" "34"]
map  [+ "."] $[1 2 3 4]  # [".1" ".2" ".3" ".4"]
# then maybe [to-num] to change it back to a number?
map [to-num + "."] $[1 2 3 4]  # [.1 .2 .3 .4]
map [/ arg 10    ] $[1 2 3 4]  # [.1 .2 .3 .4]

let Vector3.[
    x [i32]
    y [i32]
    z [i32]
]
new Vector3[1 2 3]        # [x 1 y 2 z 3]
new Vector3["1" "2" "3"]  # [x 1 y 2 z 3]
new Vector3["hello" 2 3]  # error: function [i32] tried to convert "hello" into a number.
# basically, the name of the field, and the function called on it at the time of initialization.

$ [x y z]  # [[x] [y] [z]]
$ [x y z]  # [[x   y   z]]
# which is better? I'm thinking the second one, since [$] can now accept numbers.

let vec.[x 1, y 2, z 3]
vec: "x"  # 1
vec: "x y"  # 1 2

compile [] [] -run
compile [] [] args
# 0 main.txt -run
# though [args]?

# i32 throws an error if type can't be converted?
i32 "hello"  # error

type Vector3 [x [i32], y [i32], z [i32]]
let [vec] Vector3[x 1, y 2, z 3]

# I really need to find use cases for types. [Number] vs [i32] is one example.

# if I do add types, it would completely change the language...
args [[x]]  # would not behave the same.
args [[x i32] [y u64]]
args [x i32, y u64]  # better.

# [typed-args] ?
# or maybe like haskell.
let square Fn[i32 i32 i32] [* .]
square 123 123  # Fn[] check the types before any code is called in the function.

# I've been trying to rethink the language but with types; that said, I don't think I really need
# to abandon the current model? what if we use the superset idea? like with javascript and typescript?

set Types.Object []

# [-type], the function itself doesn't check for types, it validates the passed args, the

print Object []  # type casting?

# maybe I can do overloading since default [Any]?

loop as it [break it]
for 0 [
    import "Debug" .step-into it [
        print "Hello, World!\n"
    ]
    read-key
]

let bool enum [F T]
let [T F] 1 0
# how do I do enums again?

import "Types"  # this might the strongest idea for the 'superset' faction.

mut list:0 1
mut list 0 1
# ?

get 0 list
mut 0 list 1
mut list:0 1  # still works?
# I don't see why not. though it is redundant.

let NewType [i32]
let RefType 0xfff...  # i.e. pointer

import "Types"
let square Fn[i32 i32] [* .]
square  5  # 25
square .5  # error: cannot convert .5 into [i32]

let square Fn[i32 i32] [f32 * .]
square 5  # error: expected a return value of type [i32], got [f32].

Fn[i32 i32] [f32 * .]  # returns [
    i32 (.. [f32 * .], i32 arg)
]
# ... so types are just wrapper functions.

let value i32 123
type value  # Fn[i32] or function that takes nothing, and returns and [i32].
# you can't overload it, since overloading is done one a argument basis.
let + Fn[i32 i32][i32] [i32.add]
let + Fn[f32 f32][f32] [f32.add]

# then again.
let func1 Fn[MyType][] [...]
let func2 Fn[MyType][] [...]
let func3 Fn[MyType][] [...]

let x MyType[]

func1 x
func2 x
func3 x

# vs
let MyType.[
    func1 [...]
    func2 [...]
    func3 [...]
]

let x []

MyType.func1 x
MyType.func2 x
MyType.func3 x

use MyType
func1 x
func2 x
func3 x
# the second model is just simpler and more consistent.

# I guess I can do overload, just not in the typical multiple [let] assignments way?
let print [
    args [first-arg]
    match type first-arg [
        [Number] or [String] [print-as-is format]
        [Object] [print-as-is format-object]
        [Array] [print-as-is format-array]
    ] first-arg
]
# like this?

# but I don't know. I really need to analyse typescript. there's a lot of lessons to take from there.

let . [
    args [value]
    value value
]
type [.]  # inferred as Fn[Any][Any Any]

Array[i32]
Array 10 [i32]

# maybe [use] is overloaded on function types?
use File
use [File]
use [File.open]
# all allow:
open "file.txt"
# although [use [File.open]] only does this for [open].
close file  # doesn't work for the last one.
# then again...
let open ["Hello, World1\n"]
let [open] [something [...]]
# I don't think I can do this.
extract [open] File
extract [File.open]  # same length if the function name was shorter.

let func [
    reduce [
        for 100 [arg]
    ]
]
func 1 2 3 4 5 6 7 8 9 10 ...

# the whole inserting a number when expecting a list thing is clever bug dodgy.
# I'll have to figure it out one of these days. one of these days...

Fn[i32 i32] [f32 * .]  # returns [
    i32 (.. [f32 * .], i32 arg) end
]
# [end] is like [let], but it does nothing, returns nothing. if the function block tries to get
# more arguments than the specified block, there will be an error.

= a b .then [print "yay"] .else [print "nay"]
# now this reminds me of the io programming language.
# but this isn't good. if I just do [.then], it will still return the object.
# how do I get rid of it?
if = a b [print "yay"] [print "nay"]
# this, is just the most elegant fucking thing.
let [answer] if = a b ["yay"] ["nay"]
print if = a b ["yay"] ["nay"]

print if = a b ["yay"] ["nay"] -no\n

# I guess [unqote] is just [..].
   ["hello"]  # returns ["hello"]
.. ["hello"]  # returns  "hello"

# then again, maybe not?
let [value] .. ["hello"]  # it works.
let [value] "hello"       # it works.
let [value] .. [print\n "hello"]  # doesn't work.

let new-let [
    let [symbol value] get-token, arg
    if quote? symbol [
        env.next.next: (unquote symbol) value
    ] [
        env.next.next: symbol (unquote value)
    ]
]
new-let [value] [print "hello"]
print value  # outputs [print "hello"]
new-let  value  [print "hello"]
value  # outputs "hello"

# I really do need a [unquote] function...
# I guess I'll go back to what I said earlier: it's a convention not to use [unquote].

# maybe [$] is a toggle quote?
$   [print]  # returns  print
$ $ [print]  # returns [print]
# it first checks if it's quoted (starts and end with brackets), then applies the correct
# procedure: [quote] or [unquote].

for   [x 1 y 2 z 3] [print\n it]  # error: symbol [x] not bound.
for $ [x 1 y 2 z 3] [print\n it]  # outputs "x\n1\ny\n2\nz\n3\n"

# equivalent?
let obj: unquote [x y z] [1 2 3]
let obj:   quote [x y z] [1 2 3]
# because [x] and [[[x]]] are the same?

# again, it's a convention not to do this, but you can do it.

# btw
for quote [x 1 y 2 z 3] [print\n it]
# so
quote [x 1 y 2 z 3]  # returns [[x] [1] [y] [2] [z] [3]]
# not [[x 1 y 2 z 3]], otherwise it would be treated as a string.

let $ [
    args [value]
    if quote? value [unquote value] [quote value]
]
# simple right?

use identity [
    open  [...]
    close [...]
]

# what if you did know the args count?
let [add a b] + a b
add 1 2
# but you can't do this anymore.
let square [* .]
# but maybe that's good thing? or at least, I could try to figure it could later.

args [list:0]  # what happens here?
let func [
    args [obj .x .y]
    print "% %\n" obj.x obj.y
]
func 1 2  # outputs "1 2\n"
# I think this makes sense.

let func fn [a b] + a b

# the language will be far safer if you can't do the [square] thing. though less powerful too. and
# more verbose.

# honestly, I dont like [args 1] much...
# it will be real awkward when I go back to it.

fn [] {}
fn {}  # no args.
# hmm, no. the new model should take a fixed number of args, always. unless...

# I want to test this out the same way I tested out parentheses.
# also, I should test this new model but with parentheses as well, though I'm not expecting much.
# parentheses might work better though: no .. [] everywhere, after all~

let [obj field] match field [
    .field1 print "hello"
]

print "%" 123 though...
# I can no longer do variable length shit. unless I have parentheses. or string interpolation. or
print "%" [123]
(print "%" 123)

print "" []
(print "")  # shorter!

let [func 1 y] + 10 y
let [func x y] + x y
.field1  # quoted
let [obj .field1] 123
# old idea but it's been a while.

let [func #]  # number overload
let [func @]  # string overload

# or just this
let [func x:i32]  # number overload
let [let x:Symbol y:Value]

map $+ []
# [$] is shorthand for fn [whatever-arguments] func whatever-arguments. not a pointer.
# you're creating a new function.

# I want to compare this old model to the new one.


if true, let x 1, .. []
print\n x
# because .. [] creates a new scope?
# or manybe not. [fn [a b]] already belong to a new scope, so its already created. [.. []] is not
# the thing creating scopes. it groups function.

# equivalent
if true {} {}
if true .. [] .. []

# hmm, problem.
func fn [a b] + a b
let [func f] f 1 2  # ok

func fn [a] + a 1
let [func f] f 1 2  # not ok...
# hell, how do you even know the type of [f] before it's called?
# this model is inherently flawed, like my previous one.
# the parentheses are just better in this respect. no ambiguity. no need for types!

map {
    let [add x y] + x y
    $ add
} [1 2 3 4]

map + 1 $ [1 2 3 4]  # [2 3 4 5]

(let (add x y) + x y)
(let add (fn (x y) + x y))
let [add x y] + x y
let add fn [x y] + x y

(let (func f) (f 1 2))
(func (fn (a) (+ a 1)))
let [func f] f 1 2
func fn [a] + a 1

(let file ((import "File") .open "file.txt"))
let file import "File" .open "file.txt"

(let File (import "File"))
let [File] import "File"  # but this doesn't work, does it? does it return? does it run?
# and how is [.open] passed?
# also, so I AM doing variable length params?
# honestly, not really worth considering without the parentheses. too many flaws.

(define (collect . args) args)
(collect 1 2 3 4)  # (1 2 3 4)

# I should try with the quotation+parentheses model again, but more strict args.
(let [hello] (print "Hello, World!\n"))
(let hello [(print "Hello, World!\n")])
 hello   # [(print "Hello, World!\n")]
(hello)  # "Hello, World!\n"

(let [square] (* (. (args 1))))
# no. it just doesn't make sense. type checking should be at the type level.
# not the body.
(let [square] (* (. (car args))))  # this makes more sense.
(let (square x) (* (. x)))  # this makes even more sense.

# I guess that's why there is no such thing as truthy and falsy in scheme. the language is already
# dynamic and shit, we don't need any more weirdness to it.

# is that the final lesson of this language? just use scheme? I wasted my time?

(let (square x) (* (. x)))
let square [* .]  # then again...

(let (obj field . args)
    (match field
        'field1 (apply + args)
        'field2 (apply - args)))
(obj 'field1 1 2)

(for 0 ((import "Debug") 'step-into it '(print "Hello, World!\n")))
for 0 [import "Debug" .step-into it [print "Hello, World!\n"]]

# these are both really good models, and they both come with their own pros and cons.
# as intersting as the scheme model is, the whole reason I created this language was because it
# wasn't satisfying.

# it fundamentely comes down to this:
let [a b] .. [1 2]
# vs
let [a b] + 1 b
# you can't have both, unless you create separate functions. and change how returns work.
# if you have multiple return, you must have multiple assign.

let list.[for 100 0]
(let list [(for 100 0)])

# I guess the no parentheses+quotation model is also kind of good, since if you don't pass the
# right argument count, it just breaks the program.

(let obj (object 'field1 (print "Hello, World!\n") 'field2 (print "Goodbye, World!\n")))
(obj 'field1)
(obj 'field2)

((obj 'field1) 1 2)  # message passing style is better.
# without it, you can do arg count checking...
# or can you? wait, you could right? all . args is doing is applying it to the function.
# the args count is checked then.

(let obj (object
    'field1 (apply + args)
    'field2 (print "Goodbye, World!\n")))
(let (obj field . args)
    (match field
        'field1 (begin (apply + args) obj)
        'field2 (print "Goodbye, World!\n")))
(obj 'field1 1 2)
((obj 'field1 1 2) 'field2)
# single return is better if we don't have multiple assign, and therefore no way to spread.
# this is just scheme at this point...

(define (func) func)
(eq? func (func))  ; => #t

# anyway, message passing style is still better.
(define field1 (obj 'field1))
# vs
(define (field1 x y) (obj 'field1 x y))

(field1 1 2)

((((iter vec) 'map) (lambda (x) (+ 1 x))) 'collect)

;; Create an iterator from a vector (list in this example)
(define (iter xs)
    (lambda (msg)
        (cond
            [(eq? msg 'map) (lambda (f) (iter (map f xs)))]
            [(eq? msg 'collect) xs]
            [else (error "unknown message" msg)])))

(display ((((iter '(1 2 3)) 'map) (lambda (x) (+ 1 x))) 'collect)) (newline)
;; => (2 3 4)

(define (obj msg)
    (case msg
        [(add) (lambda (x y) (+ x y))]
        [(sub) (lambda (x y) (- x y))]
        [else (error "unknown message" msg)]))

((obj 'add) 1 2)
((obj 'sub) 1 2)

(define-syntax define-object
    (syntax-rules () (
        (_ name (
            (msg1 body1)
            (msg2 body2)
            ...
        ))
        (define (name msg)
            (case msg
                [(msg1) body1]
                [(msg2) body2]
                ...
                [else (error 'name "unknown message" msg)]
            )
        )
    ))
)

;; Example usage:
(define-object my-obj (
    (add   (lambda (x y)  (+ x y)))
    (sub   (lambda (x y)  (- x y)))
    (greet (lambda (name) (string-append "Hello, " name ".")))
))

;; Calling methods:
(display ((my-obj 'add)      2 3)) (newline)  ;; => 5
(display ((my-obj 'sub)     10 4)) (newline)  ;; => 6
(display ((my-obj 'greet) "John")) (newline)  ;; => "Hello, John."
(display ((my-obj 'mul)      2 2)) (newline)  ;; => error "unknown message"

# I think I have a new found appreciation for scheme.
# I understand now that, for the model it chose, it is extremely well thought out.
# I'll make sure to learn scheme well.

let func [
    @[x y -opt-arg 123]
    + x y
    opt-arg
]
let [added opt] func 1 2 -opt-arg 321
print\n added  # 3
print\n opt    # 321
# that's great, but how do I do toggles?
# or macros... I think it's better to use different functions.

# that a great aspect of the programming language: the function decides how to process it's own
# arguments. every function can be a macro if it wants.

args [argument]
toks [token]

# or maybe I should just...
let func [
    next-token program
    peek-token program
]

let func [
    if T [
        args 1  # [args] here works for [func], not [if].
    ] []
]
# I guess the rule is that [args] called for where the string was first initialized?

# I still think variables should be constant by default.

let [vec] [x 1 y 2 z 3]
print\n vec.x  # outputs 1
set vec.x 10   # error: tried to mutate an immutable value.

let [vec] mut [x 1 y 2 z 3]  # [mut] is a type signature.
set vec.x 10
print\n vec.x  # outputs 10

type vec  # Object + Mutable ?

let [vec] [x 1, y 2, z 3]  # immutable
let [vec vec.x] mut vec, 5  # maybe?
# before, [mut] was for exactly that: mutate the copied value.
alter vec [x 10, y 20]

let [vec] [x 1, y 2, z 3]
let [vec] vec.[x 10]
# because, I mean.
vec:[x]     # returns 1
vec.[x 10]  # returns [x 10, y 2, z 3]
# if they did the same thing, it would be redundant.

let [vec] [x 1, y 2, z 3]
vec. x     # 1
vec.[x]    # error: expecting value for [x], got nothing.
vec:[x]    # 1
vec:[x y]  # 1 2
vec:[1]    # error: field [1] not found on object [vec].
vec: 1     # error: [x] is not bound.

let [vec] [1 2 3]
vec:    0   # 2
vec:   [0]  # error: field [0] not found on object [vec].
vec: $ [0]  # 1
vec: [[0]]  # 1
vec: [[0 1 2]]  # 1 2 3

(let func [
    (let [a b] (args))
])
(func 1 2  )  # valid
(func 1 2 3)  # invalid (throws an error)
# but how do I do optional args?
# or maybe not?
(let func [
    (let [a b] (args) 1 2)
])
(func 1 2)  # valid
(func)      # valid
# no, that will cause a lot of problems.
# it has to match it exactly.

# huh.
(let a b 1 2)  # valid.
(print a b)    # outputs 1 2
# I mean, why not? then again, I don't see the benefits.

(let func (print "Hello, World!\n"))  # lazy
(let [value] (+ 1 2))                 # eager

(let (value) (+ 1 2) (+ 1 2))  # error: symbol to value count mismatch.
# I guess assigning args like that is, well, optional.
(let func (for args (print\n it)))
# or just
(let func (print\n (args)))

(let func (for 100 (get it args)))

(let func
    (let [x y] (first 2 args))
    # or
    (remove-args [x y] args)

    (opts (rest 2 args)
        'optional-param1 123  # default
        'optional-param2 321
    )
)

(set obj.field1.sub-field1 123)  # valid?

(let [a] 123)  # this should be the only way to initialize a value.
(let [func] [
    (print "Hello, World!\n")
])
# I mean, with the parentheses and all that, where's the problem?

map [(+ 1 (args))] [1 2 3 4]  # this though...
# I should have a way to 'consume' a list. it's really awkward otherwise.

((import "File").open "file.txt")
# I guess I can also define optional types in type signatures?
(use (import "File" "HTTP" "String"))

(let [func] [
    (sign a b)  # 'signature'
    (print a b)
])

# honestly, I'm kind of liking this.
let func []  # has constantly fucked with me.

(let [obj] [x 1 y 2 z 3])
# since this model use parentheses everywhere, I have to selectively trim some other part of code
# to make it more terse.

# damn, you can easily pass types as values. even in the old model!

# wait.
(let [a])  # that was valid, right?
(let [a] 1 2)  # but this isn't?

(let [a] (u32))  # huh.
(let [a] (u32 123))

(let [func] [
    (let [type value] (args))
    (type value)
])
(func u32 123)

(let [func] [
    (print\n args)
])
(func 1 2 3 4)  # outputs [1 2 3 4]

(for 0 [
    ((import "Debug").step-into it [
        (print "Hello, World!\n")
    ])
])

for 0 [
    import "Debug" .step-into it [
        print "Hello, World!\n"
    ]
]

# inversely
(let 'x 1)
[1 2 3 4].1  # 2
[1 2 3 4].x  # error: field [x] not found on literal object [1 2 3 4].
[1 2 3 4].(x)  # 2

[1 2 3 4]:0  # 1
# well anyway, it works largely the same.

(let [x y] (args))  # it would be nice if this code just removed the first 2 values from [args].
# you know what? I'll do that. and I'll see what happens.

# if that's what I need, I'll make it happen.

(let [] (args))  # [] discards everything?

(display ((((iter '(1 2 3)) 'map) (lambda (x) (+ 1 x))) 'collect)) (newline)
(print (((iter [1 2 3]).map [+ 1 (args)]).collect)) (print\n)

(newline)
(print\n)  # damn!

# wait, if it consumes...
map [(+ (args))] [1 2 3 4]  # [3 7]
# right? because it CONSUMES!!!
map [
    (let [x y] (args))
    (+ x y)
] [1 2 3 4]
# ^ this makes more sense.
map [(+ (get 2 args))] [1 2 3 4]

(print\n args)    # [1 2 3 4]
(print\n (args))  # 1 2 3 4

# I think I should focus more on what would be nice first, then try to implement it.

# both valid.
(let [file err] ((import "File").open "file.txt"))
(let [file] ((import "File").open "file.txt"))

(if err (throw err))
# or just
(throw err)  # only throws if [err] is not nil.

# can't forget about [unwrap]!
(let [file] (unwrap ((import "File").open "file.txt")))  # throws if [err].

# I guess (args) behaves a bit like [yield]?

# I know I said to make it short... but this fall more in line with the rest of the language.
(let [vec] [[x] 1 [y] 2 [z] 3])

(let [print\n] [
    (for args [(print it " ")])
    (print "\n")
])

(for args [(print my-iter " ")] [my-iter])

(reduce [(for 100 it)])

# I know this is scary, but I am seriously – I mean SERIOUSLY considering switching to parentheses
# for my main model. it's insanely verbose, but if you ignore that: DAMN, is it nice!

# if I do that, I'll have to redo the interpreter from scratch... again. not that I dislike it.

(let [a b] (u32))  # both are [u32]?

(let [spread] [(args)])
(spread 1 2 3)  # 1 2 3
(spread (spread 1 2 3))  # identical.

(let [obj] [])
(var [obj] [])  # I think I prefer this for the parentheses model.

[[x][y][z]]  # this ain't so bad~

(let [func] [
    (for 100 [
        (if (= 88 value) [(return "passed")])
    ] [value])
    (exit 1)
])
(print\n (func))  # outputs "passed"
# [return] returns for the function where the quote was initialized first.
# like [args]... but will it be that simple?
# what about [break]? [continue]?
# maybe the sub-quote inherits those values from the super quote?

# I guess my language has swizzling now.

(let [a b] (args))  # what if [args], or any such function was required to return something?
(let [a b])         # this is still valid.
(let [a b] (return-nothing))  # this isn't.

# man, since I don't do unquoting anymore, a lot of things have to be reworked.

(print\n it: 0 )  # index
(print\n it: x )  # index or field
(print\n it:[0])  # field
(print\n it:[x])  # field

(print\n it.0)  # field
(print\n it.x)  # field

(print\n it.[x 10])  # mutates object, and returns it

(print\n it:[0 1])  # field
(print\n it:[x y])  # field
(print\n it:[x y])  # field

# then again...
(let [x] [1])
(print\n it.(x))  # field
# so [:] would only be for indices.
# but also...
(print\n it.(x))  # will become
(print\n it.[x])  # right?
# and () is exclusively for function calls. you're not calling [x].

# unless...
(let [vec] [[x] 1 [y] 2 [z] 3])
(let [new-vec] (mut vec [x 1]))
# but that doesn't solve the issue.

# () only works on [].
(let [f] []) (f) or ([])

(var [it] [[x] 1 [y] 2 [z] 3])
(set [it.x] 10)
it  # returns [[x] 10 [y] 2 [z] 3])
(set [it.[x y]] 100 20)
it  # returns [[x] 100 [y] 20 [z] 3])

it.x  # returns 100
it.y  # returns 20

it.[x y]  # returns 100 20
# ^ list of symbols.
it:[x y]  # list of values.

# that seems coherent.

it:[[x]]  # to get symbol?
(let [symbol] [x])
it:[symbol]
it:symbol  # invalid?
# then again, you've already 'evaluated' the thing...

it:(range 10)  # equivalent to
it:[0 1 2 3 4 5 6 7 8 9]
# this won't change. I have to work around this.
it:[(+ 1 1) (- 5 2)]  # should be valid.
it:[(dup index)]
(dup it:index)

# ... alright, I've decide: [reduce] will be call on it.
# that makes things simple.
# it:[[1]] and it:[1] are no longer the same.
# it:[[[1]]] will just throw an "invalid symbol name" error.

(let [fields] (get-fields [[x] 1 [y] 2 [z] 3]))
fields  # [[x] [y] [z]]
(print\n (fields))  # "x" "y" "z"
(for fields [(print it) (print\n)])  # "x" "y" "z"

# wait, no. what if I do allow it?
(if (let [x] (= a b)) x [
    (print "They are equal!\n")
])
# this... should be allowed?
# of course, [x] is only available in the [if] call.

# [let] in this language is evaluated in parallel. in other words, you can't refer to a variable
# defined earlier in the same [let].
(let [x y] 1 2)
(let [x y] 10 x)
(print\n x y)  # outputs 10 1, not 10 10.

(let [x] [x])
(x)  # infinite loop.

(let [x])
x  # []
(let [x y] 1)
x  # 1
y  # []

(let [func] [
    (let [x y z] (args))
    (print\n x y z)
    (manage-opt-args z)
    (if z (print\n z.opt-arg1))
])
(func 1 2)  # 1 2 []
(func 1 2 [[opt-arg1] 123])  # 1 2 [[opt-arg1] 123]
                             # 123
# I think this is a clever way to do optional arguments?
(let [new-preset-opt-args] (mut preset-opt-args z))
(set [new-preset-opt-args:(get-fields z)] (get-values z))

(if F [(print\n "hello")])  # warning: the expression will always resolve to the same outcome.

(define-syntax define-object
    (syntax-rules () (
        (_ name (msg body ...))
        (define (name m)
            (case m
                [(msg) body ...]
                [else (error 'name "unknown message" m)]
            )
        )
    ))
)

(define count 0)
(define-object counter (inc (set! count (+ count 1)) count))

(counter 'hello)  # Exception in counter: unknown message with irritant hello
(counter 'inc)    # 1


; okay, NOW it's fixed!
(define-syntax define-object
    (syntax-rules () (
        (_ name (msg body ...) ...)
        (define (name m)
            (case m
                [(msg) body ...]
                ...
                [else (error 'name "unknown message" m)]
            )
        )
    ))
)

(define count 0)
(define-object counter
    (inc (set! count (+ count 1)) count)
    (test (display "Hello, World!\n"))
)

; (counter 'hello)
(display (counter 'inc)) (newline)
(counter 'test)
(display (counter 'inc)) (newline)


; that said... I want this.
(define-object my-obj (
    (add   (x y)  (+ x y))
    (sub   (x y)  (- x y))
    (greet (name) (string-append "Hello, " name "."))
))

(display ((my-obj 'add)      2 3)) (newline)  ;; => 5
(display ((my-obj 'sub)     10 4)) (newline)  ;; => 6
(display ((my-obj 'greet) "John")) (newline)  ;; => "Hello, John."
(display ((my-obj 'mul)      2 2)) (newline)  ;; => error "unknown message"

(define x 10)
(define (square n) (* n n))
(define (sum-of-squares a b) (+ (square a) (square b)))
(display (sum-of-squares x 5)) ; → 125

((lambda (x)
    ((lambda (square)
        ((lambda (sum-of-squares) (display (sum-of-squares x 5)))
            (lambda (a b) (+ (square a) (square b)))
        )
    ) (lambda (n) (* n n)))
) 10)

# btw, I think there is merit to this model:
(print\n (((Iter [1 2 3]).map [+ 1 (args)]).collect))
# vs
(print\n (Iter.collect (Iter.map [+ 1 (args)] [1 2 3])))
# then again, it's one less parenthesis.
(use Iter)
(use Iter List)  # basically function type signature.
# not to mention: data-oriented programming.

(exec 0xff 0xfa 0xbb ...)  # most primitive function.
(let [Asm.aarch64] [
    [mov] [(exec (insert-complicated-logic-here args))]
    (...)
])

[(lambda [x y]) (print\n x y)]  # ... I guess?
(lambda [x y] [(print\n x y)])  # both could be valid, lol.
(lambda [x y] [(print\n x y)] [])  # optional arguments, maybe?

(let [func] [
    (lambda [x y])
    (print\n x y)
])
(let [func] (lambda [x y] [
    (print\n x y)
]))

(let [func] (lambda [x y] [
    (print\n x y)
    (print\n option)
] [option 123]))
(func 1 2 3)  # 1 2\n3\n
(func 1 2)  # 1 2\n123\n

# btw, [args] is still available, even with [lambda]. [lambda], of course, consumes a few values.

# can't forget about this!
[1 2 3 (next 4 [(+ 1 (args))])]

# I guess I can do this.
(mv "file1" "file2" "file3" "folder/")

# ah... the pros and cons of parentheses.

# wait, what happens when you print this?
(lambda [x y] [(print\n x y)])
# ... maybe it's better if I omit the body.
(lambda [mandatory-args] [optional-args] [toggle-args])

(lambda [man-arg1 man-arg2 [opt-arg1 123] [opt-arg2 321] [tog-arg])

# I guess I can do this?
(lambda [x y z])  # equivalent to
(lambda [x] [y] [z])

(lambda [[x 1] [y 2] [z 3]])
(lambda [[x (u32)] [y (u32)] [z (u32)]])  # clever way to do typing?

(lambda [x y z] 1 2 3)  # though this is cleaner.
# and honestly, I haven't addressed how I actually pass the optional args.
# I can't just do this:
(func [opt-arg 1])
# what if [func] expects a string there?

# the better way to do this, is as I've mentioned before. passing the object.
(let [func] [
    (lambda [x y optional])
])
(func 1 2)  # optional == []
(func 1 2 [[opt-arg1 123]])  # I think there might a benefit to doing objects like this.
(func 1 2 [[opt-arg1 123] [tog-arg1]])  # like this.
# I guess you can't do both optional arguments and variable args?

(func 1 2 [[opt-arg1] 123])
# or
(func 1 2 [[[opt-arg1] 123]])
(func 1 2 [[[opt-arg1] 123] [[tog-arg1]]])

[[[x] 1] [[y] 2] [[z] 3]]  # these objects are getting real complicated. all for some toggles.

# I think it's faster to just pass a boolean to an optional arg.
(func 1 2 [[opt-arg1] 123])
(func 1 2 [[opt-arg1] 123 [opt-arg2] T)

[
    [[field1] 1]
    [[field2] 2]
    [[field3] 3]
]
# vs
[
    [field1] 1
    [field2] 2
    [field3] 3
]

# null values
[
    [[field1]]
    [[field2]]
    [[field3]]
]
[
    [field1] []
    [field2] []
    [field3] []
]

# what if you're not supposed to iniliaze these objects by hand?
(let [obj: [x y z]] 1 2 3)
obj.x

# I guess I could do this.
(let [Vector3] [[x] [y] [z]]
(let [obj.(Vector3)] 1 2 3)
# nvm, it doesn't really work.
(let [obj.[x] [y] [z]] 1 2 3)

# ... I say not to initialize by hand, but I have to for optional args.

(func 1 2 [[opt-arg1] 123 [tog-arg1]])  # not arg at the end? not sure how that'll work though.
# hmm, though that might work.

(func 1 2 [
    [opt-arg1 opt-arg2] 123 321
    [tog-arg1 tog-arg2]
])
# the field doesn't necessarily have to be a boolean, right?
# just the fact that the field exist should be enough, right?

(func 1 2 [
    [[opt-arg1] 123]
    [[opt-arg2] 321]
    [[tog-arg1]]
    [[tog-arg2]]
])

(let [obj] [
    [[field1] 1]
    [[field2] 2]
    [[field3] 3]
])
obj.field1
(for obj [
    (print\n it)
])
# I'm starting to think, not matter how ugly and cumbersome it is, that it's better.
(for obj [
    (print\n it:0 it:1)
])
# like, a hashmap is an array of key/value pairs, right?

(func 1 2 [
    [[opt-arg1 opt-arg2] 123 321]
    [[tog-arg1] [tog-arg2]]  # wait, no. this doesn't work.
])

(for obj [(print\n it)])  # prints fields and values, one after another.
(for (fields obj) [(print\n it)])  # prints only fields.
(for (values obj) [(print\n it)])  # prints only values.

(for obj [
    (let [field value] (it))
    (print\n field " = " value)
])
# I think this might have just decided it for me. (pun not intented)

# I guess I can still do this:
[[opt-arg1 opt-arg2] 123 321]
# just that for
(print\n field " = " value)  # outputs [opt-arg1 opt-arg2 = 123 321]
# I guess that's fine. whatever.

(let [arr] [1 2 3 4])
(for (enumerate arr) [
    (let [index value] (it))
    (print\n index ": " value)
])
# e.g. [1: 2]
# this is honestly so nice...

# I think this file is becoming too big. it's getting laggy in here.

(define (func x y)
    (display (+ x y)) (newline))
func
# instead of printing #<procedure func>, which is somewhat useless,
# it will print (lambda (x y) (display (+ x y)) (newline)),
# or better yet, (lambda (x y) ((lambda (...) ...) (+ x y)) ((lambda (...) ...))).
# all the code until assembly and shit.
# of course, if the function calls itself, it will simply remain a symbol.

(lambda [x y])  # 2 obligatory args, args list is also functional
(lambda [x y] [[[x] 123]])  # 2 obligatory args, 1 optional. args list is matched with optionals.

# or maybe it's better if I had a 'if this field doesn't exist' matching style function?
(lambda [x y opts])  # 2 obligatory args, 1 optional. args list is matched with optionals.
(bind opts [
    [[opt-arg1] 123]  # will assign if field doesn't exist.
])

(lambda [x y] [opt-arg1 123] [opt-arg2 321] [tog-arg1] [tog-arg2])  # this though...
# I think this is the best model. the least amount of nesting too.

# I should try writing pmatch in this language eventually.

(print\n ([1 2 3 (next 4 [(+ 1 (args))])]))  # [print\n] should print things progressively.

# could I do this, then?
fibs :: [Integer]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

fib :: Int -> Integer
fib n = fibs !! n

(let [fibs] [0 1 (zip-with + fibs (tail fibs))])
# ... so that's it? is it really that nice?
# wait no. I think I have to double call it, since [zip-with] returns a list.
(let [fibs] [0 1 ((zip-with + fibs (tail fibs)))])
# still pretty good.
(let [fibs] (append [0 1] (zip-with + fibs (tail fibs))))

(let [fibs] [
    0 1 ((zip-with + fibs (tail fibs)))
])

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
(= fibs [0 1 ((zipWith + fibs (tail fibs)))])
(= fibs (: 0 (: 1 (zipWith + fibs (tail fibs)))))
(= fibs (: 0 1 (zipWith + fibs (tail fibs))))
# suprising.

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
(= [fibs] [0 1 ((zipWith + fibs (tail fibs)))])
= fibs.[0 1 .. zipWith [+] fibs tail fibs]
# it's also suprising that the old model isn't that much shorter.

# I guess [fibs] should also be memoized and shit.

fib n = fibs !! n
(let [fib] [(lambda [n]) fibs:n])
(let [fib] [fibs:(args)])
(= fib [fibs:(args)])
(= fib [fibs:(get 1 args)])
(= fib [fibs:(car args)])

#
#                       _oo0oo_
#                      o8888888o
#                      88" . "88
#                      (| -_- |)
#                      0\  =  /0
#                    ___/`---'\___
#                  .' \\|     |// '.
#                 / \\|||  :  |||// \
#                / _||||| -:- |||||- \
#               |   | \\\  -  /// |   |
#               | \_|  ''\---/''  |_/ |
#               \  .-\__  '-'  ___/-. /
#             ___'. .'  /--.--\  `. .'___
#          ."" '<  `.___\_<|>_/___.' >' "".
#         | | :  `- \`.;`\ _ /`;.`/ - ` : | |
#         \  \ `_.   \_ __\ /__ _/   .-` /  /
#     =====`-.____`.___ \_____/___.-`___.-'=====
#                       `=---=' 
#
#
#     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#               Buddha bless the code
#

(let [f100] (take 100 Natural))
f100  # [1 2 3 4 .. 99 100]
# where [Natural] is a lazy list.
(let [Natural] [1 (next 2 [(+ (args))])])  # or something.

# I really need to figure out [args]. it's so awkward.

(map [(+ 1] [1) 2) 3) 4)])  # maybe I'm unto something?

# I guess [.] should be a sort of syntax plugin? would be nice if I could add and remove them.
# like adding [..] for ranges.
# I suppose it's fine to just make it a macro.

(Syntax.disable [ array-notation])
(Syntax.disable [object-notation])
# only takes effect after the function calls.
(Syntax.disable [object-notation])  # error: variable [Syntax.disable] not bound.
# ^ treats it as one symbol.

# since I'm willing to do parentheses and stuff, might as well try the old model again.

let [square] $[* .]

let [obj] [
    [[x] 1]
    [[y] 2]
    [[z] 3]
]
obj.x

# wait a second.
let [func] $ [
    args [f]
    f 1 2
]
func $[+]

let [func] $ [
    args [f]
    (f 1 2)
]
func [+]
# what if I do add parentheses, but only selectively?
# then again, no. I'm already using [$] everywhere...

# then AGAIN, [import] can be a little weird?
for 0 [
    import "Debug" .step-into it [
        print "Hello, World!\n"
    ]
    read-key
]
# ok
for 0 [
    (identity import "Debug").step-into it [
        print "Hello, World!\n"
    ]
    read-key
]
# I guess () is only there for precedence?
# ..step-into was very ugly.
# you know what? you can use parentheses everywhere. you can.

# or not?
let [func] $ [
    arg
]
func $[+]
# what happened here again?
# I guess it just returns.
# unless...
let [func] $ [
    (arg 1 2)
]
func [+]
# maybe the best is really to mix it up?

# think about it
(identiy import "Debug").step-into it [
    print "Hello, World!\n"
]
# say [identity] is a quote; then the () runs it.
# if it's not a quote, then as per the language's usual movements, it runs and call [import] in
# turn... hmm. no, something doesn't click. I thought I had it.

( [+] 1 2)  # returns [+] 1 2
($[+] 1 2)  # returns 3
# this might be it. it runs unquoted stuff.

(f)
.. f

$[+]
$ [
    +
]
# this should be the convention?

# although, will I still have this?
(for obj [
    (let [field value] (it))
    (print\n field " = " value)
])
for obj [
    let [field value] .. it  # arguably even better?
    print\n strcat [field " = " value]
]

(let [arr] [1 2 3 4])
(for (enumerate arr) [
    (let [index value] (it))
    (print\n index ": " value)
])
# e.g. [1: 2]
let [arr] [1 2 3 4]
for enumerate arr [
    let [index value] .. it
    print\n strcat [index ": " value]
]

for 100 as [index] [
    print\n index
]

use [
    [[open ] $[...]]
    [[close] $[...]]
]

(print\n field " = " value)  # this is really nice though...
# what if you can still do this?

(mv "file1" "file2" "folder/")
mv "file1" "folder/"  # both valid?

(let [x y])
let [x y] 1 2

let [field value] .. it
(let [field] .. it)  # discard?

let [func] $ [
    for args [
        print\n it
    ]
]
func 1 2 3 4 5 6 ...  # until the end of the application.
(func 1 2 3) 5 6 ...  # until 3
# but how does it work? how can I make it work?

let [field value] .. it;
(let [field value] .. it)

# for a language without syntax, it sure has a lot of it.
# anyway, [;] is no good. I've been thinking about it, and I have to choose either fixed argument
# count, or unfixed.

let [func] $ [
    for args 1 [
        print\n it
    ]
]
func [1 2 3 4]

# honestly, they're both just as bad.
args 1
(args)

# you know what? I think I'm going to stick with parentheses for a while.
# there is a lot of really nice code there. there is also ugly code, but the old model isn't
# innocent in that respect either.

(map (lambda [x] [+ 1 x]) [1 2 3 4])  # [2 3 4 5]
# maybe this is the way?
(map [(lambda [x]) [+ 1 x]] [1 2 3 4])
# yeah, it's clean. I like it.

(let [func] [
    (lambda [x y -z 3 -toggle])
    (print\n x y z)  # no, seriously, I love the [print\n] in this model.
    (if toggle [(print\n "Hello, World!\n")])
])
(func 1 2)          # 1 2 3
(func 1 2 -z 30)    # 1 2 30
(func 1 2 -toggle)  # 1 2 3\nHello, World!\n

# all I have to do is use a few 'macros' here and there,
# and I'll reduce the parentheses significantly.

(lambda [x] [+ 1 x])  # returns [(lambda [x]) [+ 1 x]]
# I mean, why not?

# I'll have to work hard to make the the language as readable as possible.
# I should look at Haskell, and it's function composition thingies. it may prove useful.

(let [square] * $ dup)

# maybe [$] is like in Haskell?

print (sqrt (1 + 2))
print $ sqrt (1 + 2)

print (map (*2) (filter even [1..10]))
print $ map (*2) $ filter even [1..10]

result = sum $ map (^2) [1..10]
main = print . sum . map (^2) $ [1..5]

# I should try this language but with actual currying, and therefore fixed arguments.

(print\n (sqrt (+ 1 2)))
(print\n $ sqrt (+ 1 2))
(print\n $ sqrt $ + 1 2)
# basically, [$] put the rest of the arguments in parentheses.

(print\n (sqrt (+ 1 2)))
(print\n . sqrt (+ 1 2))
(print\n . sqrt . + 1 2)
# [.] looks nicer. but isn't there an overlap?

(map (lambda [x] [+ 1 x]) [1 2 3 4])
(map [+ 1 $ car args] [1 2 3 4])

(let [field value] (it))
(let [field value] . it)

(let [square] [(* (dup (args)))])
(let [square] [$ * (dup (args))])
(let [square] [$ * $ dup (args)])
(let [square] [$ * $ dup $ args])

(let [square] [(* (dup (args)))])
(let [square] [. * (dup (args))])
(let [square] [. * . dup (args)])
(let [square] [. * . dup . args])
# yeah, I prefer the point by a long shot. [$] is almost as visually noisy as the parentheses.

# by the way, this isn't a new feature. I clearly remember having tested this out.

(let [square] [(* . dup . args)])  # this is probably the best. I shouldn't abuse it.
(let [square] [(*.dup.args)])  # what would I have to do to make this work?

# hmm, I should probably keep the space. no just because I can't make this work, but also, I like
# the fact that it's the same character count, with or without the parentheses. in other words, if
# people choose to use it, it will only be to make it easier to read, not because the code will
# become shorter.

# see? very clean.
(let [fibs] [0 1 . (zip-with + fibs . tail fibs)])
(let [fibs] [0 1 ((zip-with + fibs (tail fibs)))])

(let [++] . lambda [x] [x x])
(print\n (++ 5))      # 5 5
(print\n (* (++ 5)))  # 25
(print\n (* . ++ 5))  # 25
(print\n (square 5))  # 25

(let [fibs] [0 1 .. zip-with + fibs . tail fibs])
# intersting... but again, the character count should be the same.

(let [x y z] 1 2 3)
(print\n x y z)  # 1 2 3
(print\n x y z -no-spaces)  # 123

(print\n)  # if I don't do parentheses, I won't have this...

(let [fibs] [0 1 . (zip-with + fibs . tail fibs)])
(let [fibs] $ 0 1 . (zip-with + fibs . tail fibs))
(let [fibs] $ 0 1 . . zip-with + fibs . tail fibs)

(if T [(print\n "Hello, World!\n")])
(if T $ (print\n "Hello, World!\n"))
# I should add [$] for quoting the rest. that said, I doubt I'll use it much.

(Vector3.new [1 2 3])  # [
    [[x] 1]
    [[y] 1]
    [[z] 1]
]

(define (square x) (* x x))
(define (square x) (* x x))
(define [square] . lambda [x] [(* x x)])
(define square (lambda (x) (* x x)))
# I should figure how to make it shorter.
(let [square] . fn [x] [(* x x)])
# this is one way.
(let [square] . λ [x] [(* x x)])
(define square (λ (x) (* x x)))

(let [λ] lambda)

(define-syntax λ
    (syntax-rules () (
        (_ args body ...)
        (lambda args body ...)
    ))
)
(define square (λ (x) (* x x)))
(square 5) ; => 25

(define add (λ (x y) (+ x y)))
(add 2 3) ; => 5

(let [square] . λ [x] [
    (* x x)
])

(= fibs $ 0 1 . . zipWith + fibs . tail fibs)
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
= fibs.[0 1 .. zipWith [+] fibs tail fibs]

(define (square x) (* x x))
(let square . λ x [(* x x)])

(define (square x y) (* x x))
(let square . λ [x y] [(* x x)])
# I shouldn't stive for these small wins.

# this is the shortest [square] function possible.
(let [square] . λ [x] [(* x x)])
let square [* .]
# damn...

# is this really the way to go?

(define [x y z] 1 2 3)
(define square [x] (* x x))
(define (square x) (* x x))
# what if I make [let] a macro?

(let square [x] (* x x))
(define (square x) (* x x))

(let square [x] (* x x))
let square [* .]

(define func[] (display "hello"))
(define (func) (display "hello"))

(define square[x] (* x x))
(define (square x) (* x x))

# I can't forget that, while it is more verbose, it is also more powerful.
(print\n)
print "\n"
print \n  # then again...

(let [x y z] 1 2 3)
(print\n x y z)
let [x y z] 1 2 3
print\n "% % %" x y z
print\n reduce [x y z]

(use File OS HTTP String)
use [File OS HTTP String]
(use [
    [[x] 1] [[y] 2] [[z] 3]
])  # can't do this in a clean way.
use [
    [[x 1] [y 2] [z 3]]
]  # ?

# it is far less dangerous, of course.

# btw, I don't really like this.
(let square [x]
    (* x x)
)
# better.
(let square [x] [
    (* x x)
])
(let [square] . λ [x] [
    (* x x)
])
(let [square] [
    (* . get 2 args)
])

(print)    # not allowed?
(print\n)  # allowed?

# (old model)
print "% % %" x y z
(print "% % %" x y z)
(print "% % %" x) y z  # error: insuffient argument count?
# still fixed arguments, but will throw instead of destroying the application?

print\n [x y z]
(print\n x y z)

let func [
    args [f]
    (.. f 1 2)  # ideal?
]
func [+]  # 3

let func [
    args [f]
    (f 1 2)  # I'm still thinking this is possble.
]
func [+]  # 3
# here's what I'm thinking: if the value of [f] is unquoted, it is simply called, the result from
# the call is ignored by the (); if it's a quote, [..] is applied to it – and again, the result of
# the call is ignored by ().

let [func] [
    args [f]
    (f 1 2)  # I'm still thinking this is possble.
]
(func [+])
.. func [+]

(let [field value] .. it)
(let [field] .. it)  # what happens here? I'm thinking discard?

let mul-ret [
    [x 1, y 2, z 3]
    [field1 123, field2 321]
]
[mul-ret]:0 .x       # 1
[mul-ret]:1 .field1  # 123

(let [map] [
    (args [f l]) . while l [(f . l)]
])
(map + [1 2 3 4])  # [3 7]
# if function take a fixed number of arguments... and we can do currying, that might fix things?

(+ 1 2)  # 3
(+ 1 2 3)  # error: incorrect argument count ?
# or 3 is just ignored?

(take 50 (map + Natural))  # [3 7 11 15 19 23 27 31 35 39 43 47 51 55 59 63 67 71 75 79 83 87 91 95 99 103 107 111 115 119 123 127 131 135 139 143 147 151 155 159 163 167 171 175 179 183 187 191 195 199]

# equivalent to

(define nums (cdr (iota 101)))
(define (sum-pairs lst)
    (if (or (null? lst) (null? (cdr lst)))
        '()
        (cons (+ (car lst) (cadr lst))
              (sum-pairs (cddr lst)))))
(sum-pairs nums)

# curried.
(map (+ 1) [1 2 3 4])  # [2 3 4 5]
(map (- (swap 1)) [1 2 3 4])  # [0 1 2 3]
(map (- . swap 1) [1 2 3 4])  # [0 1 2 3]

map [+ 1] [1 2 3 4]
map [- swap 1] [1 2 3 4]
# the thing is: ^, the currying feels extremly natural.
# it is a consequence of design choices.
# with (), you forced it to happen.

(let [print\n] [
    (for args [
        (print it " ")
    ])
    (print "\b" "\n")
])
# wait, do I even have to do "\b"?
printf "xx\b \n"

(let [print\n] [
    (for args [
        (print it " ")
    ])
    (print "\n")
])
(let [name] "John")
(print\n "Hello," name ".")  # "Hello, John.\n"
# ^ now THIS, this here is beautiful code. no ugly parts of the language.

# I should make a list of all the beautiful parts of the program; as well as the ugly parts.

# yeah, I really can't do currying.
(let [x y z])

(let square [x] (* x x))
(let (square x) [* x x])

(let [func] [(print "Hello, World!\n")])
(let (func) (print "Hello, World!\n"))

# I guess I should make this a general rule for macros?
(let square [x] (* x x))
(let [symbol] [square])
(let (symbol) [x] (* x x))  # (symbol) is not a function call. ((symbol)) is.

# in other words...
obj.(x)  # is valid, because it is a macro.

# alright. macros are a thing now. and they always were – I was just reticent towards admitting it.
(lambda [x y -z 3 -toggle])
(lambda [x . args])  # like scheme?

(let func [name] (print "Hello," name ".\n"))
(let [func] [(print "Hello," (args) ".\n")])

(let [new-let] [
    (λ [symbols])
    (let [next-env.(symbols)] . args)
])

(let [my-func] [
    (λ [list obj fn]) (use Iter List Matrix)
    (...)
])
# I suppose this is what a professional function would look like.
(let my-func [list obj fn] (use Iter List Matrix)
    (...))
# or this... but I hate it.
# worst: there are fewer characters. and even worse, far fewer.

# this is still fewer, but at least it's cleaner.
(let my-func [list obj fn] [
    (use Iter List Matrix)
    (...)
])
# hmm... I hate how it reminds of common lisp, but I think it's clever.
# I'll probably keep it.

(...)  # error: not implemented yet.

(use (import "File" "HTTP" "String" "OS"))
(use . import "File" "HTTP" "String" "OS")
# clean.

(123)  # error: cannot apply a non-quote type.
([123])  # 123

# nah... there's no reason not to have a shorthand for arguments.
(let [my-func] [
    (let [list obj fn] . args) (use Iter List Matrix)
    (...)
])

(for args (as [value] [(print\n value)]))
(for args . as [value] [(print\n value)])
(for args [(print\n value)] [value])  # this is just better.
# it's unfortunate, but whatever.

(break it)
(break value)

(return func-name)  # becomes pointer, so it still works when you rename the function.

(import "File" "HTTP" "String" "OS")  # returns env, but also assigns?
(use . import "File" "HTTP" "String" "OS")
(File.open "file.txt")
(open "file.txt")

# hmm... maybe not?
(let [File] . import "File")
(let [SomethingElse] . import "File")  # we should have both [File] and [SomethingElse].

((import "File").open "file.txt")  # *chef's kiss*
# I guess the macro only applies after the object?
# or rather, the macro/syntax is only [.open]
((import "File")
    .open "file.txt")  # still valid.
((import "File").
    open "file.txt")   # still valid?
# I mean, I guess I don't really see why not.
# alright, it is valid. it's decided. until I see a reason not to.

# once this language becomes more refined, one of the tests of it's capabilities will be to
# recreate Jai in it, syntax and all.

(let [File] . import "File")  # is there a way to avoid duplicate values?

(as "File" import)
(let as [symbol function] [
    (let [next-env.(symbol)] . function symbol)  # maybe?
])
# I think I have the right idea, but maybe I can rearrange it better?

(import as "File")

# for [if] statements, what if [next-env] is skips the [if] statement's environment?

# what if the top-level automatically assigns add a parenthesis to the start and end of the file?
# and [;] is equivalent to [)(]?
as "File" import;
let [File] . import "File";

let as [symbol function] [
    (let [next-env.(symbol)] . function symbol)  # maybe?
];
# if I do a cli, it will be like this.
# ... you know, the more I think about it, isn't this like, real good?
# I mean, you know, it removes A LOT of parentheses.
# it make my code look like the old model, but it isn't really.
# it's like that 'middle ground' I was seeking.
# the best of both worlds.

(let (square x) (* x x))
let square [x] [(* x x)]  # ... I mean, I should.

# ... what if all [] are like that?
[* x x]  # () are automatically add at the start and end.

let square [x] [* x x]  # bro, this is starting to look an awful lot like the old model.
# I'm getting rid of the parentheses using stupid syntaxic sugar...

let my-func [list obj fn] [
    use Iter List Matrix;
    ...
]
# why... just why.
# and you know what? () does nothing, but it is still valid syntax.
# and so, I present you with:
let my-func [list obj fn] [
    use Iter List Matrix;
    ...;
]
# what the fuck is even going on anymore.

# top-level, so this...
[
    print "Hello, World!\n";
    print . args;
] 1 2 3
# outputs:
# "Hello, World!\n"
# 1 2 3

# I want to cry. I seriously want to cry.
# I'm pretty sure not even [;] is a new idea. why did I forget it?
# probably because I didn't find enough reason to consider the switch.

# ... wait, shit.
let [list] [1 2 3];
let [x y z] . list;  # right?
# wrong!
# you cannot run [1] as a function!

let [list] [[1] [2] [3]];
let [x y z] . list;
print x y z;
# maybe I'm abusing it. maybe it should only be on the top-level?

# this works...
let [list] [[1 2 3]];
let [x y z] . list;
print x y z;

print "Hello, World!\n";

let square [* .]
let square [x] [* x x]
let square [args [x] * x x]  # suprising like suck when there are named variables.
let [square] [* . d . args]  # [d] is for [dup].

(let [fibs] [0 1 . (zip-with + fibs . tail fibs)])

# what if [args] is renamed to something shorter? like [@] or [%] or... [_].

(let [print\n] [
    (for _ [
        (print it " ")
    ])
    (print "\n")
])
(let [name] "John")
(print\n "Hello," name ".")

let [print\n] [
    for _ [
        print it " ";
    ];
    print "\n";
];
let [name] "John";
print\n "Hello," name ".";

# ... you know, the semi-colons are not that much better.
# but anyway, I'm really liking [_] for [args].

let [square] [* . d . _];

# wait, what about {}?
# what if '{' was equivalent to '[('?
# and anyway: ';' and '{' and '}' just go hand in hand!

let [print\n] {
    for _ {
        print it " ";
    };
    print "\n";
};

# again, it's just a macro. treat {} as [()].
# yeah, I think I like this. you can basically choose your style.
# I might've accidentally created something incredibly sexy – forgive me, World!

[(print "hello"; print\n)]

# I suppose I should also make it so that [] is syntax.
[1 2 3]
(quote 1 2 3)
# same goes for "".
"hello"
(quote hello)

# I guess I'll call it 'evaluating a quote'.

for _ {
    print\n it;
} -as [it];

# btw
let [symbol] [it];
for _ {
    print\n it;
} -as [(symbol)];
# you can do this.
# though this is arguably better...
for _ {
    print\n it;
} -as symbol;

let [func] {
    for . _
};
func [1 2 3] {print value} -as [value]  # this should work.

# though this is arguably far simpler.
let [func] for;

# anyway, I think this settles it. this is most likely going to become the main model.
# I cannot find anyway the old model is better than this (expect currying and terseness).

let [value] . take 50 . map + Natural;

# the REPL should be extremely powerful.
# I should look nice (like my current one), have colors and shit, as well as plugins to change the
# font and whatever. maybe even an editor more. anyway, then some sort of auto completion as well.
# and everything should be configurable easily from the terminal or a file, using that very same
# language.
# hell, like a Jupyter Notebook, you should even be able to edit old code (although you can't undo
# a file deletion or whatever).
# no more shit REPLs!!

print Numbers.Natural;  # [ (next 1 { + 1 . _ }) ] or something.
use Numbers;

map (λ [x y] { + x y }) [1 2 3 4]
map (λ [x y] [(+ x y)]) [1 2 3 4]

let [add-all] $ . let [i] 0; for _ $ . set [i] + i it;
let [add-all] $ . let [i] 0; for _ { set [i] + i it };  # looks better and matches with spaces...
add-all 1 2 3 4 5 6 7 8 9;  # 45
# wait, no. I don't think it works... there cannot be 2 semi-colons.
let [add-all] $ . let [i] 0; for _ $ . set [i] + i it;
let [add-all] [(let [i] 0)(for _ [(set [i] + i it)])];  # yeah, [let [i] 0] would be the only part.
let [add-all] [(for _ (let [i] 0) [(set [i] + i it)])];
# ^ like this?
let [add-all] { for _ (let [i] 0) { set [i] + i it } };
let [add-all] $ . for _ (let [i] 0) $ . set [i] + i it;  # it's a little longer, but it works.
# I guess I'll make it standard to space {}.

# what if this was valid?
let [add-all] $ . for _ . let [i] 0 $ . set [i] + i it;
# like, 'let' takes in the body... but maybe it also returns it if unused?
# I feel like if that's the case I'll have to rethink some things.

# either that or I come up with an alternative to ';'.
# like ';' is for ')(', but maybe I also need ')['?
# then again, no. I don't see a way to make it work with '$'. it's not like it replaces it.
# you still the ']' thing at the end. nevermind I guess.

# eh?
for _ (let [i] 0) [(set [i] + i it)]
for _ (as value) [(set [i] + i value)]
for _ . as value [(set [i] + i value)]  # wait, no. doesn't work. or does it? I can overload it?
for _ [(set [i] + i value)] . as value
# ok.

# btw, top-level so...
for _ {
    print it " ";
};
# shell:

    $ 0 main.txt 123 321 "Hello, World1"

# outputs main.txt 123 321 "Hello, World1"

# wait a second... I want the shell to behave like the language, so...
load "file.txt"

    $ load "file.txt"

# I mean, right?
# so the binary used for other shell should be called 'load'.

# this doesn't work, btw.

    $ load file.txt  # error: variable 'file' not bound.

# this does.

    $ load (print\n "hello") "file.txt"

# hmm, so the first argument is the file you want to load, then the arguments you want to pass to
# the file. I think I like that. nice.

# what was the test again? for if something is lazy evaluated or not?
(define (p) (p))
(define (test x y) (if (= x 0) 0 y))
(test 0 (p))

p = p
test x y = if x == 0 then 0 else y
main = print (test 0 p)

let [p] $ . p;
let test [x y] $ if (= x 0) 0 y;
test 0 (p);
# ... I would imagine that it's eager. it's pretty obvious when it's not eager.
# the only reason why my language has infinite lists, is because of quotation.

# then again... is it that obvious?
(func (+ 1 1) (- 1 1))  # everything is eager.
let [x y] . [(print "1 called, ") 1 (print "2 called, ") 2 (print "3 called, ") 3];
# outputs "1 called, 2 called, "
# but if that's the case, why is this fully evaluated?
([(print "hello") (print " ")])
# because 'eval' is running in a loop?
# what if it semi-evaluates?
# ([(print "hello") (print " ")]) -> (print "hello") (print " ") ?

# maybe the reason this works is because the rest in put in [_]? which it itself is quoted?
let [func] {
    print\n _;  # outputs [(print "1 called, ") 1 (print "2 called, ") 2 (print "3 called, ") 3]
};
func (print "1 called, ") 1 (print "2 called, ") 2 (print "3 called, ") 3;
# know that I think about it, you don't even need to evaluate shit.
# unlike the old model, you know the argument count!
# ... or not. sometimes things don't return anything, or returns multiple values.

# so all the arguments are simply in a quoted list...
let [func] {
    for _ { print it ", intermediate action, " }
};
func (print "1 called, ") 1 (print "2 called, ") 2 (print "3 called, ") 3;
# outputs "1 called, 1, intermediate action, 2 called, 2, intermediate action, 3 called, 3, intermediate action, "

# (quote) == [] ?
# a large portion of the interpreter will have to be defined without macros...

# this code might not be possible...
for _ { set [i] + i value } . as value;
# then again, maybe it is?? argh...

for _ { set [i] + i value } . as value;
# ... maybe it's easier if I just say the language is lazy?

let [-opt-arg1 123 -opt-args2 321];  # this works too.

# ??
let func [x y];
# like in C? define the signature, but don't assign it yet?

# oh.
let [a b] . mut;  # both are mutable? because both [] are passed to 'mut'?
let [a b] (mut [] []);
let [a b] (int 12 21);
print\n a b;  # outputs 12 21

let [a b] (int 12) (f32 21);

# put '$' at the top of the file make it so that you have to use ()s everywhere again.
# you can just turn {} mode off. although it fucks with CLI args...

# the ideas just keep on coming. it's been a few days, and I can't stop thinking about this shit.

# what if every function is yielded by default? but once you reach the end of it, it loops back?
let [a b] . _;
for _ [];
# ^ other this doesn't work.

let [list] [1 2 3];
let [x] . list;
let [y] . list;
let [z] . list;
print x y z;  # 1 2 3
# do I want this?

let [value err] . func;
let [value] . func;  # you can do this, if you expect you won't be using 'func' again?

# this works, btw. it loops back around.
for _ [];
for _ [];

# basically 'eval'?
for _;

# I should really detect it though. there should be a way to find out if all the arguments have
# been used in a function, and throw and error in not. some sort of dependant typing, maybe.

for _ { set [i] + i value } . as value;
# what if it's an error that '. as value' is unused?

# how about this:
let [a b] . [1 2 3];
# the entire list is evaluated, like a function.
# but after evaluation, the things not assigned are put back into the list?

# here though, it's different. it works a bit like the old language model.
let [a b] . take 2 [1 2 3];
# notice that at no point in time is the list itself evaluation.
# only 'take' is being evaluated.

# wait, wait, wait. no, wait a second.
let [fibs] [0 1 . (zip-with + fibs . tail fibs)]
take 10 fibs;  # [0 1 1 2 3 5 8 13 21 34]

for 0 $ . print\n it ": " . reduce [0 1 . (zip-with + fibs . tail fibs)];
# 0: [0 1 1 . (zip-with + fibs . tail fibs)]
# 1: [0 1 1 2 . (zip-with + fibs . tail fibs)]
# 2: [0 1 1 2 3 . (zip-with + fibs . tail fibs)]
# 3: [0 1 1 2 3 5 . (zip-with + fibs . tail fibs)]
# 4: [0 1 1 2 3 5 8 . (zip-with + fibs . tail fibs)]
# 5: [0 1 1 2 3 5 8 13 . (zip-with + fibs . tail fibs)]
# 6: [0 1 1 2 3 5 8 13 21 . (zip-with + fibs . tail fibs)]
# 7: [0 1 1 2 3 5 8 13 21 34 . (zip-with + fibs . tail fibs)]
# ...
# does that fix it? and do parameters really work like this?
# maybe it's a consequence of how 'zip-with' is defined?

# side-effect are eager, value are not?
# I think I am over-complicating the situation.
# how about: it's just lazy. and don't put side-effect function or whatever at the end.
# lesson learned!

# this is still valid, right?
((print "hello") (print "\n"))

# in other words, no need for '$' at the start of the file.
# as long as no function call returns any thing, we're good.
let [x] 1 ;
(let [y] 2)
# (both valid at top-level)

print "Hello, World!\n" ;
# you know, this is weird, yes, but I feel like ';' should be spaced...

print "hello" ; print "\n" ;
(print "hello") (print "\n")

let [list] [1 2 3];
let [x] . list;
let [y] . list;
let [z] . list;
print x y z;

let [list] [1 2 3] ;
let [x] . list ;
let [y] . list ;
let [z] . list ;
print x y z ;

for _ { print\n it };
for _ { print\n it } ;
(for _ { print\n it })

# then again, maybe not.

let [func] {
    let [a b] . _;  # everything is run here.
    print\n a b;  # outputs 2 4
    let [c d] . _;  # everything has already been run. the arg list is memoised.
    print\n c d;  # outputs 6 8
    for _ { print\n it }
};
func (+ 1 1) (+ 2 2) (+ 3 3) (+ 4 4) (+ 5 5) (+ 6 6) (+ 7 7) (+ 8 8);
# you know what? no. why should it be run in the function?
# run it before they are passed to the function. keep it simple.
# fuck it.

λ [a b]

# is everything lambda calculus underneath?

# there's this thing though.
let [fibs] [0 1 . (zip-with + fibs . tail fibs)];

let new-let [symbols] {
    
};
new-let [x y z] . fibs;

# in scheme.
(define (zip-with f xs ys)
    (if (or (null? xs) (null? ys))
        '()
        (cons (f (car xs) (car ys))
              (zip-with f (cdr xs) (cdr ys)))))

(zip-with + '(1 2 3) '(4 5 6))                                               ; => (5 7 9)
(zip-with * '(1 2 3 4) '(5 6 7 8))                                           ; => (5 12 21 32)
(zip-with (lambda (x y) (string-append x y)) '("a" "b" "c") '("x" "y" "z"))  ; => ("ax" "by" "cz")

# should I call my language 'load'?
let zip-with [f xs yz] {
    if (or xs ys) [[]] [
        (cons (f (car xs) (car ys)) (zip-with f (cdr xs) (cdr ys)))
    ]
};
print\n . zip-with + [1 2 3] [4 5 6];                                            # [5 7 9]
print\n . zip-with * [1 2 3 4] [5 6 7 8];                                        # [5 12 21 32]
print\n . zip-with (λ [x y] { string-append x y }) ["a" "b" "c"] ["x" "y" "z"];  # ["ax" "by" "cz"]
# anyway, with this definition, it would obviously take forever to evaluate.

# worst case scenario, even scheme can create 'infinite lists'.

# shit, I just realized.
let [func] {
    [(print "Hello, World!\n")];
    # and so, I can't return a string.
    "Hello, World!\n"
}
# wait... I can't even return a number...
# damn, things were going SO WELL! too well, really...

let [func] {
    return "Hello, World!\n" 123 321;  # should I?
};
# you know what? why the fuck not! the world is your orchard!! DO IT, MOTHERFUCKER!!!

# ... I guess now I have to figure out how 'return' determines which function to return.
# so, {} forces explicit return...?

let [i] 10;
while i {
    set [i] - i 1; print\n it
};
let [i] 10;
while i (set [i] - i 1) {
    print\n it
};

let [func] {
    print\n _;  # [2 4 6 8 10 12 14 16]
};
func (+ 1 1) (+ 2 2) (+ 3 3) (+ 4 4) (+ 5 5) (+ 6 6) (+ 7 7) (+ 8 8);

let [list] [(+ 1 1) (+ 2 2) (+ 3 3) (+ 4 4) (+ 5 5) (+ 6 6) (+ 7 7) (+ 8 8)];
print\n list;  # [(+ 1 1) (+ 2 2) (+ 3 3) (+ 4 4) (+ 5 5) (+ 6 6) (+ 7 7) (+ 8 8)]
# at this point, it is still a string.
let [a b] . list;
print\n list;  # [(+ 3 3) (+ 4 4) (+ 5 5) (+ 6 6) (+ 7 7) (+ 8 8)]
# maybe?

# okay, let's think about what's different.
([(+ 1 1) (+ 2 2)] (+ 3 3) (+ 4 4) [(+ 5 5) (+ 6 6)] (+ 7 7) (+ 8 8))
# first off, the arguments are evaluated.
([(+ 1 1) (+ 2 2)] 6 8 [(+ 5 5) (+ 6 6)] 14 16)
# the strings remain the same – because they are strings.
# and now, the operator is applied to operands.
let [operator] [(+ 1 1) (+ 2 2)];
let [operands] [6 8 [(+ 5 5) (+ 6 6)] 14 16];
# oh, I like how they are the same character count. never noticed.
(operator . operands)
# but maybe because of how eval works, operator is evaluated lazily?
for operator it;  # evaluates every thing?

let [a b] . _;
# is something like
let [symbols] [[a] [b]];
for symbols {
    let [next-env.(symbols)] . get _;
}

let [func] [
    (_)    # lazy?
    ((_))  # eager?
    # it will crash if the first argument is not a function,
    # but only after the operands are all be evaluated.
]
# of course, this will never return.

# ...
let [fibs] [0 1 . (zip-with + fibs . tail fibs)];
print\n . fibs;
# wait, so I can't do this?

# actually, it changes nothing. eventually, it will be passed to a function as an argument, and be
# evaluated in the argument list.
# I can't do it. I can't make this work. I thought I had it, but I didn't.

(print\n (fibs))
# becomes
([...] 0 1 1 2 3 5 8 13 21 34 ...)  # it never start executing the body of 'print\n'.
# but if this doesn't work...
# no, maybe I can save it.
# let's think about it.

(print\n (+ 1 2) (+ (- 2 5) (- 22 3)) (fibs))
([...] (+ 1 2) (+ (- 2 5) (- 22 3)) (fibs))
([...] ([...] 1 2) (+ (- 2 5) (- 22 3)) (fibs))
([...] 3 ([...] (- 2 5) (- 22 3)) (fibs))
([...] 3 ([...] ([...] 2 5) (- 22 3)) (fibs))
([...] 3 ([...] -3 ([...] 22 3)) (fibs))
([...] 3 ([...] -3 19) (fibs))
([...] 3 16 (fibs))
([...] 3 16 ([0 1 . (zip-with + fibs . tail fibs)]))  # no arguments to evaluate.
([...] 3 16 0 ([1 . (zip-with + fibs . tail fibs)]))  # start by returning 0
([...] 3 16 0 1 ([. (zip-with + fibs . tail fibs)]))  # then 1
([...] 3 16 0 1 ([. (zip-with + fibs . tail fibs)]))  # then starts evaluating 'zip-with'.
([...] 3 16 0 1 ([((zip-with + fibs (tail fibs)))]))
([...] 3 16 0 1 ([(([...] + fibs (tail fibs)))]))
([...] 3 16 0 1 ([(([...] [...] fibs (tail fibs)))]))
([...] 3 16 0 1 ([(([...] [...] [...] ([...] fibs)))]))
([...] 3 16 0 1 ([(([...] [...] [...] ([...] [...])))]))
([...] 3 16 0 1 ([(([...] [...] [...] [...]))]))
# I can't, man. no matter how I look at it, 'zip-with' with go on forever.
# it will keep doing 'cons' and creating the list without returning anything.
# I don't know. either arguments returned from the body of the function are lazy,
# or everytime the function calls itself, it freezes?
# or checks if the calling function is satisfied?
# maybe it only works when you're spreading a list?
# or maybe the function is put on hold the moment it returns a value?

# at least I have this. *sob*
for fibs {
    print fibs " "
};
print\n;
# and this.
let [a b] . . take 10 fibs;

# ...
# let's see how scheme does it.
(define-syntax cons-stream
    (syntax-rules () (
        (_ a b)
        (cons a (lambda () b))  ; delay the tail
    ))
)

(define (stream-car s) (car s))
(define (stream-cdr s) ((cdr s)))  ; force evaluation

(define (from n)
    (cons-stream n (from (+ n 1)))
)

(define nums (from 0))

(define (stream-take s n)
    (if (zero? n)
        '()
        (cons (stream-car s)
              (stream-take (stream-cdr s) (- n 1)))
    )
)

(stream-take nums 10)  ; => (0 1 2 3 4 5 6 7 8 9)

(define fibs
    (cons-stream 0
        (cons-stream 1 (add-streams fibs (stream-cdr fibs)))
    )
)

(define (add-streams s1 s2)
    (cons-stream
        (+ (stream-car s1) (stream-car s2))
        (add-streams (stream-cdr s1) (stream-cdr s2))
    )
)

(stream-take fibs 10)  ; => (0 1 1 2 3 5 8 13 21 34)

# if it's overly complicated, maybe I shouldn't do it?

# Go enums are intersting.
type Direction int
const (
    North Direction = iota
    East
    South
    West
)
North == 0  // returns false. or throw an error.

# anyway, the way the type is done is nice.
enum [North East South West];
print\n . = North 0;  # false.

# I can't do this:
let [x] 1;  # immutable
var [x] 1;  #   mutable
# because of this.
let func [x y];
# unless...
var func [x y];
# no, only 'func' becomes mutable here.
# and it's equivalent to this, anyway:
let [func] { λ [x y] };
# though this works...
let [func] { let [x y] . _ };
let [func] { var [x y] . _ };

# the more I think about it... the more it should behave that way.
let [value err] . function-that-can-fail;
# obviously, 'function-that-can-fail' should run from start to finish.
# not doing so is ridiculous.
# but I suppose we could also memoize it?

let [list] [1 2 3 4 5 6];

let [x y z] . list;
print x y z;  # [1 2 3]

let [x y z] . list;
print x y z;  # [1 2 3], returns the same thing.

# but, you can do this:
for list {
    print it " ";
};
# [4 5 6]

# ... or not.
let [x y z] . list;
print x y z;  # [1 2 3]

let [x y z] . list;
print x y z;  # [1 2 3], returns the same thing.

for list {
    print it " "
};
# [1 2 3 4 5 6]
# how about we be sane, and not allow a thing to mutate itself weirdly?

let [func] $ . for _ { print it " " };
func 1 2 3 4;  # 1 2 3 4

let func [x] {
    print "x =" x "\b, and the rest =";  # I guess this is a nice way to remove the space.
    for _ { print it " " };
};
func 1 2 3 4;  # x = 1, and the rest = 1 2 3 4
# here, '_' is still bound to the full list?

let func [x . the-rest] {
    print "x =" x "\b, and the rest =";
    for the-rest { print it " " };
}
func 1 2 3 4;  # x = 1, and the rest = 2 3 4

let [func] {
    λ [x . the-rest];
    print "x =" x "\b, and the rest =";
    for the-rest { print it " " };
}
func 1 2 3 4;  # x = 1, and the rest = 2 3 4

let [func] {
    let [x . the-rest] . _;
    print "x =" x "\b, and the rest =";
    for the-rest { print it " " };
}
func 1 2 3 4;  # x = 1, and the rest = 2 3 4
# again, the arguments are only evaluated once. '(_)' is only for spreading.
# not as fun. but more sane? sure.

let func [x . _] {
    print "x =" x "\b, and the rest =";
    for _ { print it " " };
}

# hah... I still have infinite lists. I do... but damn.
print\n take 10 fibs;
# wait, do I? I do... but I might have to rewrite fibs...
# no, I can't figure out how to do this... I might have to give up...
# unless there is a way to return a function which is not quoted.

let [Natural] [(next 1 { + 1 . _ })];
let next [before after] {
    return before . unquote [next (after before) after];
};
print\n . get 0 Natural;  # 1
print\n . get 1 Natural;  # 2
print\n . get 2 Natural;  # 3

print\n . car Natural;  # 1
print\n . cdr Natural;  # [(next 2 { + 1 . _ })], quoted but not double quoted.
print\n . car cdr Natural;  # 2
print\n . cdr cdr Natural;  # [(next 3 { + 1 . _ })]

print\n . take 10 Natural;  # [1 2 3 4 5 6 7 8 9 10]

print\n . Natural;  # 1 2 3 4 5 6 7 8 9 10 ...
print\n . 1 2 3 (next 4 { + 1 . _ });
print\n . 1 2 3 4 (next 5 { + 1 . _ });
# it is possible. now I just need to figure out 'fibs'.

# I love how this is taking so much of my time. I need to go to sleep.

# also, I love the implications.
(func arg1 arg2 arg3)     # all the arguments get executed.
let [_] [arg1 arg2 arg3]  # then they become part of a list.
for _ { ... }             # and that list is iterated over.
# you would be none the wiser if someone inserted something that can still be evaluated in there.

# what if 'int' and other types are also macro, but with side-effects?
# i.e. they can be placed anywhere. when you compile, the macros go away,
# but they change the type of the symbol that came after or before it.
let [x y z] 1 2 3;
let [x int, y int, z int] 1 2 3;
# here, the it's in a quote. when you run it, it might as well not be there.
# though the type is now enforced.

# why don't I experiment with lazy evaluation?
(print\n (fibs))
(print\n 0 1 1 2 3 5 8 13 21 34 (fibs))
# so I guess the args list keeps running until the expected count is reached.

# as a rule, I can this:
(+ (print "something") 1 1)
# but not this:
(+ 1 1 (print "something"))
# unless the function expects an infinite number of arguments.
# same goes inside functions. don't put code you want executed after the return values.
# you should list all the return value.
# there is no discards, only delays.
let [value err] . func;
# if there is code after the return values, it will be executed the second time you run a function?

# in other words, you can do the original thing I liked.
let [a b] . _;
for _ { print\n _ };  # print the rest of the values.

# I guess you're not mutating it?
# it's just a slice. memoized, yes, but everything is memoized.

for 1.. { print it " " };  # equivalent to 'Natural'.
# I sure use '.' for syntax a lot.

print\n . reduce fibs;  # can you also do this?
# I mean, a string is just something you print character by character. so I guess, yeah?

# it's either,
for _ {
    print\n value
} . as value;
# or
let [fibs] . reduce [0 1 . (zip-with + fibs . tail fibs)];
print\n fibs;

(define (f x y)
    (if (= x 0) 0 y))
(f 0 (/ 1 0))  ; → error: division by zero

# I just realized.
print it " ";  # puts two spaces in...
# also, I've been thinking.
print 1 2;  # 1 2
print "x=" 2;  # x=2
# right?
# because, otherwise how do you do it?

(filter even . takeWhile (< 5)) [1..4]
filter even . take-while { < 5 . _ } [1..4]

# you know, in the lazy language, everything function is technically 'quote'...
let [func] {
    print _
};
func Hello, World!\n;  # outputs Hello, World!\n
# I mean, it's a string? so does '\n' get converted?

# oh my god.
let [mv] {
    print\n _
};
mv file1 file2 folder/;  # file1 file2 folder/ ...
# right? so basically, I can literally call functions like the CLI.
let [mv] {
    let [dest] . reverse . quote _;
    for _ {
        file-move it dest
    }
};
# hmm. even though I can do this, I don't think I should.
# wait.
mv (my-file-variable) file2 folder/;
# because it's essentially a macro...
# so I guess when you call quote on it...
# but how do I only quote the first value?
# then again, it's lazy, so only the first value is quoted?
# again, it's not like '_' is *actually* mutated. it's only yielded.

# I know this language is supposed to be a scheme, and therefore eager...
# but damn. just damn. look at THIS, man. maybe I should commit to it.
# and eager just made me depressed, honestly. it was boring.
# now this, this puts a smile on my face.

load (print "Hello, World!\n")  # equivalent to [py -c 'print("Hello, World!\n")']
# but in python, you can't do this: [py main.py -c 'print("hello")'].
# it's simple here.
load (print "Hello, World!\n") "main.txt"
# warning: put you executable code before 'main.txt'
# does that mean optional args should be put before everything?
# I think I can make it so it doesn't have to be like that.
# ^ (what a mouthful...)

# then again...
load (print "Hello, World!\n") "main.txt" arg1 arg2 arg3
# we can't forget about this.
# I guess the order this matters, but you either run it before running the file, or you pass it to
# the file to be run.

print . quote Hello, World!\n;  # outputs "Hello, World!\n"
let [mv] {
    let [list] . map quote _;
    print\n list;
};
mv file1 file2 folder/;  # outputs ["file1" "file2" "folder/"]
# I think this makes more sense.

# huh.
let [quote] { _ }
print . quote Hello, World!\n;  # outputs "Hello, World!\n"
for (quote 1 2 3) {
    print it " "
};  # 1 2 3
# ^ basically a list.

# shit. I don't think I can use 'load' like that... the shell with probably convert stuff like ()
# and $ to it's own things.

# maybe '{' is not '[(' but '[(apply'? and that's why you can still do implicit return?
# or maybe '[(return' or '[(print' for the top-level.
# I guess ';' would have to be like that too. ')(return'
# I guess I can make it return for the top-level as well, just with a return to the print function.
# or '[(push Stack'...
# anyway, if I do that, implicit return doesn't stop the execution of the function,
# 'return' does do it. again, if I do implement them.
# '[(return (' maybe the best?
# anyway, at the end, I think printing the stack is also good. that's how the REPL works.

# jesus fucking christ. I keep writing and writing...

# if I do things lazily, does that mean I can compose functions?
# how does it even work?

# scheme if lazy.
(define ones (cons 1 ones))
(take 5 ones)  ; => (1 1 1 1 1)

(define fibs
    (cons 0
          (cons 1
                (zip-with + fibs (cdr fibs)))))
(define (zip-with f xs ys)
    (cons (f (car xs) (car ys))
          (zip-with f (cdr xs) (cdr ys))))
(take 10 fibs)  ; => (0 1 1 2 3 5 8 13 21 34)

(define (safe-div x y)
  (if (= y 0)
      'undefined
      (/ x y)))
(safe-div 10 0) ; => 'undefined

(define (from n)
    (cons n (from (+ n 1))))
(define naturals (from 0))
(take 10 (filter even? naturals))
; => (0 2 4 6 8 10 12 14 16 18)

(define (my-if cond then else)
    (if cond then else))
(my-if #t (/ 1 0) 42) ; => 42

(define big-list (from 0))
(define (sum n xs)
  (if (= n 0)
      0
      (+ (car xs) (sum (- n 1) (cdr xs)))))
(sum 5 big-list) ; => 10

(define (nats)
    (cons 0 (map add1 (nats))))
(take 6 (nats)) ; => (0 1 2 3 4 5)

(define squares
    (map (lambda (x) (* x x)) (from 1)))
(define evens
    (filter even? squares))
(take 5 evens) ; => (4 16 36 64 100)

(define lines (read-lines "bigfile.txt"))
(display (take 3 lines))

# maybe?
map (unquote [+ 1]) [1 2 3 4]

let [x y z] 1 2 3;
print "x=%, y=%, z=%" 1 2 3;  # "x=1, y=2, z=3"
# this still works.

print . reduce obj;

# both work?
break;
break it;

# my god, macros are so easy.
let [macro] {
    syntax _ [
        [[a + b] [+ a b]]
    ]
}
macro 1 + 1;
# or something like that.

(u32 123)  # returns (u32 123)
# it's something that follows it everywhere.

# I think this might better than the old model...
# in the old model you had 'args' and 'tokens' or whatever.
# but here, you just a string of operands.
# because you know the size of the argument list,
# you can just put it all in one variable.

# I should first push this language to the extreme,
# then decide what to keep, and what to throw away.
# test every possible combinations, and keep the good ones.

import "File" "String" "HTTP" "OS";
let [file] . File.open "file.txt";
use File String HTTP OS;
# this might actually be the better way of doing things.

let [Modules] [File String HTTP OS];
import Modules; use . Modules;
# I don't any poing in renaming them.

import File String HTTP OS;  # what if?
# no... don't know how to use it.

import "File" "String" "HTTP" "OS" -use;
import -use "File" "String" "HTTP" "OS";
# you know, that might be the cleaned way to do it.
# I mean, you can always 'use' them later, but if you want to do it immediately? this is better.

# delay/force, huh. it's the same character count.
# maybe all I need to make scheme is redefine 'cdr' to force things, and 'cons' to delay the tail?

import "File" "String" "HTTP" "OS" "File" "String" "HTTP" "OS" "File" "String" "HTTP" "OS" -use;
# wait. everything is lazy, right? so what is to say that I can import everything in my package
# forder automatically? it already deals with name overlap, and stuff, since you can't have two
# folders with the same name. the hierarchy and stuff is already done... to begin with, I did the
# "" thing with 'import' because I wanted to copy Jai. but clearly I'm not doing that anymore.

# this is all you need. no 'import' or anything.
use File String HTTP OS;

# lol.
print\n File;  # [import "File'] or something. it has not been evaluated yet.

type Integer Integer IO;
let func [x y] {
    print\n x y;
};
func 1 2;

type [Integer] IO;
let func [x] {
    print\n . x;
};
func [1 2];

type Integer Integer;
let [x y] 1 2;

type [Integer];
let [x] [1 2];

# what if the rest of the list is automatically returned?
let add [x y] {
    + x y
};
map [(add . _)] [1 2 3 4]
([(add . [1 2 3 4])])
([3 3 4])
# so like, that a way to for you to be force to use your arguments.
# but also to do cool things.
if (let [i] . dup 10) {
    print\n i
};
# otherwise, you have to do this.
if (let [i] 10) i {
    print\n i
};
# not the best example, but you see what I mean.
# problem is here.
let [a b] . _;
# or is it?

# it's interesting, but it works best with fixed arguments.
# I'll think about it some other time.

# if '+' takes 2 arguments, doesn't this just work?
map + [1 2 3 4]  # [3 7]
# but it shouldn't, otherwise polynomials and stuff won't be as nice.
3x^4 − 2x^3 +5x − 7
(define (p x)
    (+ (* 3 (expt x 4)) (* -2 (expt x 3)) (* 5 x) -7))
let p [x] $
    (+ (* 3 (expt x 4)) (* -2 (expt x 3)) (* 5 x) -7);
# '**' for 'expt'?

# wait, 'quote' is actually defined like this.
let [quote] [_]
# not like this.
let [quote] { _ }
# if it was like this, it would have weird behavior.
quote print "Hello, World!\n";  # returns 2 values: print "Hello, World!\n"
quote (print "Hello, World!\n");  # outputs "Hello, World!\n"
let [quote] [(_)]

use File.[open close];  # like rust. again.

use std::{
    ffi::CString,
    fs::{File, OpenOptions},
    os::{
        fd::{AsRawFd, FromRawFd},
        unix::fs::MetadataExt,
    },
};
use std.[
    ffi.[CString]
    fs.[File OpenOptions]
    os.[
        fd.[AsRawFd FromRawFd]
        unix.fs.MetadataExt
    ]
]
# should I do it like this? no capital letters or anything?

# 'use' is easy to define?
let [use] {
    for _ {
        for modules {
            let [field value] . it;
            let [next-env.next-env.next-env.(field)] value;
        }
    } [modules]  # simplest way, honestly.
};

# it's literally impossible to do implicit return with {}...
let [func] {
    let [a b] . _;
};
# 'let' here is really just a string. and because it is just a string, I just can't do it.
# you have to call anything that is 'implicitly returned'.
# well, at least {} won't get anymore complicated that that.

let [func] {
    # guard. it only executes the rest of the code if true. come on, it's clever.
    if (! condition) $ .

    let [a b] . _;
}
# better than some 'return;' bs, at least.
# no need to add anything new to the language. literally just using what's already there.
# wait, fuck. it's only until ';'. damn, I thought I did something clever there...
# I guess I have to implement a 'return' that short-circuits the code. otherwise,
# it's the extremely lame 'put everything in {}, which I think everyone agree is shit.
let [func] {
    if condition $ . return;
    let [a b] . _;
}
# *sigh*

# btw, while it short-circuits, it only does so for the current scope.
let [func] {
    {
        return;
        print "this will never print\n";  # it really won't.
    }
    print "this will print!";
}
# you won't ever have to see this if you stick with an imperative style,
# but if you want to return from an 'if' statement with {}s...
# though I suppose it's not very imperative when return doesn't return from the function...

# maybe there 'ret' and 'return'?
# oh.
let [func] {
    let [value] . if condition {
        $ "true"
    } {
        ["true"]
    };
    print\n value;
}
# isn't that, like way better than 'return'?
# far shorter; and you can still return multiple values.
# and philosophically, it's nice. with [], every function call has to have ()s;
# with {}, every return value has to have []s. that's kind of... that's kind of nice!
# not to mention that return values should be at the end, so '$' is extremely fitting.

# maybe the language is called '[]s'. or '()s'. it is a LISP (in some way).

λ [x y] [];  # isn't [] the default if the argument is now passed?
# so how is λ supposed to resolve this?
λ [x y];
# well, I guess it's not 'impossible' impossible: I'll maybe have to check the arg count and stuff.

# call the language 'zeta'? after the 'Riemann zeta function'? or after the REPL's 'ζ' symbol?
# probably better than 'load'?

let [func] {
    λ [x y];
    lambda [x y];
    let [x y] . _;  # only one character shorter!
};

# I guess 'push-stack' checks if the function should be put on hold? that's one way to do it.
# now that I think about it, isn't a scope just a 'Program' struct? isn't it kind of easy to delay
# a function? we already know the position within the scope. though, 'easy' is a misnomer.
# once I start doing memory management... oh boy.
# I think I'll start with a garbage collector. anything else, and I'll have to go deep in the type
# system rabbit hole.

# I'm not going to like, I've been looking up LISP without the parentheses, # and I getting vibes.
# then again, no. it seems '\n' == function call. but what if you want to pass as argument, without
# calling? you can't. or at least put it on the same line as the function call.

define
 fac x
 if
  = x 0
  1
  * x
    fac
     - x 1

let
 group
  foo
   + 1 2
  bar
   + 3 4
 + foo bar

# Denser equivalents using more traditional S-expressions:

define (fac x)
 if (= x 0) 1
  * x
   fac (- x 1)

let
 group
  foo (+ 1 2)
  bar (+ 3 4)
 + foo bar

# it's nice, but I struggle to fully grasp it.
# this might be the solution.
(define-syntax identity
    (syntax-rules () ((_ x) x)))
(identity 123)  ; => 123
# yep. tested it, and it worked. wonderful.

(define-syntax $
  (syntax-rules () ((_ x) x)))
# vs
define-syntax identity
  syntax-rules () ((_ x) x)

(define (fac x)
  (if (= x 0)
    1
    (* x
      (fac
        (- x 1)))))
# vs
define (fac x)
  if (= x 0)
    $ 1
    * x
      fac
        - x 1

(let (
    (foo (+ 1 2))
    (bar (+ 3 4))
) (+ foo bar))
# vs
let
  group
    foo
      + 1 2
    bar
      + 3 4
  + foo bar

# I can make it a rule that the identation can be anything, as long as it's higher than one?
# then again, 2 spaces everywhere is kind of nice.

# then again... what if the number of spaces was the amount of parentheses?
let
    foo
      + 1 2
    bar
      + 3 4
  + foo bar
# I'd like to say it's kind of gross, but... I kind of like it?
# but with 'group' it's so much more readable... so maybe not.

# when in doubt, use a macro.
(define-syntax group
  (syntax-rules ()
    ((_ x ...) (x ...))))
# vs
define-syntax group
  syntax-rules ()
    (_ x ...) (x ...)
# even if I don't add this to my language, I want to try and do this in scheme.

# hmm... it's not possible to do this.
$ 123 321 123 321
# only this.
$ 123
$ 321
$ 123
$ 321
# which fucking sucks.

(map
  (lambda (x) (* x x))
  '(1 2 3 4 5 6 7 8 9))
# vs
map
  lambda (x) (* x x)
  quote 1 2 3 4 5 6 7 8 9
# shorthand for 'quote' doesn't really work.

# anyway, enough scheme. let's get to the juice.
let [func] {
    let [value] . if condition {
        $ "true"
    } {
        ["true"]
    };
    print\n value;
}
# vs
let [func]
  $
    let [value]
      if condition ["true"] ["true"]
    print\n value

let [func] {
    for _ {
        print\n it
    }
};
# vs
let [func]
    for _
        print\n it
# if the space difference is divisible by 4, it's quoted and then called? like with the {}?

# this is valid, for example.
let [func]
    let [value]
      if condition ["true"] ["true"]
    print\n value

print\n . map (λ [x] [(+ x x)]) [1 2 3 4 5 6];
# vs
print\n
  map
    λ [x] [(+ x x)]
    $ [1 2 3 4 5 6]
# the matching character count was completely by accident...

# btw, is this valid?
print\n
  map
    λ [x] [
      + x x
    ]
    $ [1 2 3 4 5 6]
# I feel like it should be. also, the implications of that...
let [func] [
    let [value]
        if condition ["true"] ["true"]
    print\n value
]
# right? I feel like this is clever: indentation is ()s; []s are what they are.
# not to say you can't use '$'. it behaves like any other function. just like '.' does.
let [a b]
    . _
# kind of redundant...
# right, there is no way to call a function without parentheses.
# '.' might be useless now...

# heh, '\n\n' is the new ';'.
# well, not really. you can have statements right next to each other.

# I don't like this. I might actually prefer this over the old new model. it's just so clean!

# this doesn't work.
λ [x]
[
    + x x
]
# equivalent to
λ [x];
[(+ x x)];
# this does
λ [x] [
    + x x
]
# it feels like go...
λ [x] [
    + x x
] 123 321
# ^ btw, 123 and 321 are passed to λ.

print\n
    $ 1 2 3 4
# unlike filthy scheme, this works.
# though it clearly behave differently...
print\n
    [1 2 3 4]
# okay, this is what we want: multiple return.

for _ [
    print\n it
]
for _ [(print\n it)]
# I'm seriously considering the switch...

# I guess '   ' are now a macro like '.'?
# that's one way to do it. not to mention, again, that () does nothing when empty,
# so any other whitespace anywhere else is ignored.
    [
    print\n it
]
# ^ this is an error by the way.
# although, we can't forget about this.
for _ [
    print\n it

    print\n it

    print\n it
]
# 0 indentation between the 'print\n's.
# in other words, a new block is not started unless we have call with 0 indentation.

# ah, I just realized: '.' is now useless, and therefore not a macro, and therefore can be used
# exclusively for object notation! that's good!

print\n
    map (λ [x] [(+ x x)]) [1 2 3 4 5 6]
print\n
    map (λ [x] [
        + x x
    ]) [1 2 3 4 5 6]
# still valid? I would say yes. '])' is very (relatively) old model... before the {}s.
print\n (map (λ [x] [
    + x x
]) [1 2 3 4 5 6])
# I really don't like though.

print\n . map (λ [x] [(+ x x)]) [1 2 3 4 5 6]
# maybe '.' still exists?
print\n . map
    (λ [x] [(+ x x)])
    [1 2 3 4 5 6]
# ^ indentation does not matter inside ()s.
# nvm, it does. otherwise, how can you tell if they are arguments for 'map'?
# but anyway, you don't have to use '$' for values! — but you have to use ()s to call...

# damn, I've been using the 'en' dash instead of the 'em' dash this whole time...

print\n . map
    . λ [x] [(+ x x)]
    [1 2 3 4 5 6]
# can I?
print\n . map
    (λ [x] [(+ x x)])
    [1 2 3 4 5 6];
# this might be something that was impossible in the old model...
# '.' is not that intuitive, but I want it to behave like this.
# then again, is it really not? for all the arguments passed to 'print\n', they now belong to the
# function that '.' decides.
print\n . map (λ [x] [(+ x x)]) [1 2 3 4 5 6]

# anyway, I'm officially getting rid of {} and ';'. goodbye! your service will be remembered!

# ... and we are back to square one. the thing that started it all.
print "Hello, World!\n"

let [func] $
    let [value] . if condition ["true"] ["true"]
    print\n value
# I think this should be valid as well, following on the legacy of '.'.
# actually, I'll go further, and say this here is NOT VALID!
let [func]
    $
        let [value]
            if condition ["true"] ["true"]
        print\n value
# it is a macro, it will behave like one.
# ... I just realized, but isn't '$' just 'quote'? like actually?
quote Hello, World!\n  # "Hello, World!\n"
$     Hello, World!\n  # "Hello, World!\n"
# I really think it is...
# and so '$' can be defined similarly!
let [$] [_]  # actually beautiful...

    $ 'load "main.txt"' | zeta

# 'zeta' or the programming language binary only has the ability to open the REPL?
# but if you pipe it, you can execute commands?

print "hello "; print "there\n"  # maybe I'll allow this?
print "hello "; print "there\n"
    1 2 3 4
# it's just, you know.
# I guess 1 2 3 4 goes to the second print. no need to hurt yourself with this.
# my language is looking more and modern...

let [identity] [. _]
print\n . identity  1 2 3 4   # outputs  1 2 3 4
print\n . identity [1 2 3 4]  # outputs [1 2 3 4]

map indentity [1 2 3 4 5]  # [1 2 3 4 5]

print\n ((my-func))
print\n
        my-func
print\n (other-thing) ((my-func))
print\n
    other-thing
        my-func  # wrong!
print\n
    other-thing
    group
        my-func  # possible solution.
print\n
    other-thing
    . . my-func  # possible solution as well.
# wait, no.
print\n
    other-thing
    . my-func    # this is equivalent to (. my-func)! it's already double called!

# wait, I just realized, the definition of '$' doesn't work! '$' is a macro, and runs without ()s!
let [quote] [_]  # this is the definition of 'quote'!
# also, there is a real difference between 'quote' and '$' in use.
func
    quote 1 2 3 4  # [1 2 3 4]
    $     1 2 3 4  #  1 2 3 4 — becomes list, then the list gets evaluated.

# I really love how '$' and '.' are opposites.
# like yin & yang.

let [func]
    $
        let [value]
            if condition ["true"] ["true"]
        print\n value
# ... '$' returns a quote, and then it's evaluated. so, I guess it does nothing?
let [func] ([ (let [value] (if condition ["true"] ["true"])) (print\n value) ])  # "true"
# ^ equivalent to this
print\n func  # []

# one big advantage of significan whitespace, is the fact that the code essentially looks the same
# for everyone. you don't even need a formatter!

let [value] 1
. match value [
    [1 [print "the value is 1\n"]]
    [2 [print "the value is 2\n"]]
    [3 [print "the value is 3\n"]]
]
# "the value is 1"

# nice and clean.

let [value] 1
. match value [
    for 1..4 [
        $ [it [print\n "the value is " it]]
    ]
]
# "the value is 1"

# I guess for anything more complicated, we use 'cond'?
# I sure say 'I guess' a lot...

let [MyEnum] enum [North East South West]
let [MyEnum] enum [[North 1] East South West]  # set first value?
# anyway...
print\n MyEnum  # [[[North] 0] [[East] 1] [[South] 2] [[West] 3]]

let [value] MyEnum.North
print\n . match value $ for MyEnum [
    let [field value] . it
    $ [value [print\n "the value is MyEnum." field]]
]
# "the value is MyEnum.North"

# this is interesting, but how is it useful? I need use cases.

. match value [
    use MyEnum  # probably not necessary if you pass it the other way?

    [North [...]]
    [East  [...]]
    [South [...]]
    [West  [...]]
] MyEnum
# is it that simple? you pass in a type, and 'match' will check if it's exhaustive?

. match value [
    [North      [...]]
    [East       [...]]
    [South West [...]]  # maybe?
] MyEnum

. match value [
    [North [...]]
    [East  [...]]
    [_     [...]]  # this seems like the best for default.
] MyEnum
# '_' is just equal to value.

# assigning something but not using it is an error?
use MyEnum

# maybe I should try UFCS?
# no, it only works if there's overloading.

echo 'print("hello")' | py
echo 'print\n "hello"' | zeta

py -c 'print("hello")'
zeta 'print\n "hello"'  # same length, nice.

zeta 'load "main.txt" arg1 arg2'
zeta 'print "Hello, " "World!\n"'

# I guess 'zeta' is a function that just takes a string and runs it?
# or start the REPL if no arguments?
# maybe it's like '.', but not a macro.
(zeta [print "Hello, " "World!\n"])

# how about we can't declare the same symbol twice in the same scope?
let [x] 1
let [x] 2
# that will prevent collisions when importing modules.

# I think Jai wasn't about type theory, it was about running code at compile-time and doing some
# fancy type logic?
# I think zig also kind of has dependant types to an extent?

for (enumerate [
    let [x y z] 1 2 3
    x y z
]) [
    let [index value] . it
    print\n index ": " value
]
# 0: 1
# 1: 2
# 2: 3
# debug-stack, basically?

let [debug-stack] [
    for (enumerate . _) [
        let [index value] . it
        print\n index ": " value
    ]
]
debug-stack [
    let [x y z] 1 2 3
    x y z
]
# 0: 1
# 1: 2
# 2: 3

let [.] [
    syntax _ [
        [[. a ...] [(a ...)]]
        [[a.b] [a. b] [a .b] [get [b] a]]
    ]
]
# is it that simple?
# wait, no, it doesn't work since you have to call it.
let [.] unquote []  # maybe?
# or just
syntax . [
    [[_ a ...] [(a ...)]]
    [[a_b] [a_ b] [a _b] [get [b] a]]
]
# or even
let [.] syntax [
    [[_ a ...] [(a ...)]]
    [[a_b] [a_ b] [a _b] [get [b] a]]
]
# like with enum?
# but how do I do set 'vec.x'? are they separate things that look the same?
# I guess I don't see why not.

let [#] syntax [
    [[_...] []]
]
# comments?
# and what if it behaves differently if when it's [#...] or [# ...]?
# I guess it does print with the string, when part of it,
# but when the string evals, it's no longer there? same with '.'.

# I think unquote [] might be the right way to go for functions that run by themselves.

# ?
@before
@after
# quote of eveything before and after a macro. makes the macro more procedural?
# though it is not for the whole program, just the scope.
# I guess my language has both procedural and declarative macros...?
# and declarative macros are simpler, and use a DSL, but they get converted to procedural?
# I need to learn more aobut rust macros, and maybe macros in general.
# I'll have to test out macros by executing them and seeing how they expand.

# maybe 'for _' is called at the end?
# like 'if _ . for _' ? (if the list hasn't be fully evaluated)
# maybe it's a convention to handle '_': either discard but still evaluate,
# or make it part of the function?
let [a b] . take-or-error 2 _
# ^ force 2 arguments?
let func [x y] [
    if _ [. error ""]
]

# part the the compilation is putting everything on one line?

zeta '' ''  # separate statements?

# no matter how I think about it, you must pass through twice for the macros.
# I guess 'get' has to work like a macro too.
obj.field
(get field obj)

obj.field.sub-field
(get sub-field (get field obj))

map [. + . take 2 _]
# what happens if you don't give a list?

let p [x] $
    +
        *  3 . expt x 4
        * -2 . expt x 3
        *  5        x
        $ -7
# that is... one way of doing it?
let p [x] $ . + -7
    *  3 . expt x 4
    * -2 . expt x 3
    *  5        x
# or
let p [x] $ . + (*  3 . expt x 4) (* -2 . expt x 3) (* 5 x) -7
# ^ probably the best.

let [print\n] [
    for _ [
        print it " "
    ]
    print "\n"
]
# or just
let [print\n] [
    print . _
    print "\n"
]

# I should try building a garbage collector for once. that'll help me learn stuff.
# next version of this language will have a garbage collector.
# I should implement at least one garbage collector within my lifetime.

# because $ is a macro, it precedes other macros?
let [func]
let $ func
# wait, are there higher-order macro around?
# ... probably not. higher-order function work because (operator operands...).

# 'a _ b' cannot become '_ a b', _ has to go.

let [fibs] [0 1 . (zip-with + fibs . tail fibs)];
let [fibs] $ 1 2
    . zip-with + fibs . tail fibs
# I like $, it's like ':' (or cons in haskell) but better.
= fibs $ 1 2 . . zipWith + fibs . tail fibs
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

# you know, I guess I can do '=' like haskell, if it's a macro for 'let'.
fibs = $ 1 2 . . zipWith + fibs . tail fibs
print "hello"  # still valid.
a, b = 1, 2
func x y = $ . + x y
func x y = [
    print\n x y
]
# this is actually kind of nice.
func x y :: [
    print\n x y
]
a, b := 1, 2
# wait, if everything is lazy, isn't this lazy too?
func x y =
    print\n x y
# nah, harder to understand. let's keep things simple.
# at the end of the day, I like the idea that you can print functions.
# ... I just realized, but functions will always be formatted, right?
# or not. maybe I can do it like html and ignore newline and stuff. but then, what about spaces?

func x y =
    print\n x y
func x y = $
    print\n x y
# if everything is memoised, is there really any difference?

let [a b] 1 2
let a, b 1 2
# equivalent macro?
# but you can't do this
func x, y =
func [x y] =
fibs = 1, 2, . zipWith + fibs . tail fibs
fibs = $ 1 2 . . zipWith + fibs . tail fibs
# I guess the macros behave a bit like the old model when you chain them.

# equivalent?
1, [2]
[1 2]

a, b = 1, 2
[a b] = [1 2]
# hmm.
[x y] = _
# that's nice...

# if _ == [1 2] and [x y] = _, now _ == []
# but (_) == 1 2 still
# maybe.

let [str] "Hello, World!\n"  # invalid
let  str  "Hello, World!\n"  #   valid?

func = (print\n 1 2)
let func [] (print\n x y)
func x y = (print\n x y)
let func [x y] (print\n x y)
x, y = 1 2
[x y] = 1 2
let [x y] 1 2
str = "Hello, World!\n"
let str [] "Hello, World!\n"  # if the parameters of λ are empty, the 'function' is unchanged.
# I don't like how consistent this all is...

func x y = (+ x y)
func 1 2

print\n func  # (λ [x y] (+ x y))
# yes, this is what it returns.
# everything is lazy.
# or maybe not... it's not very useful.

func [x y] = . print\n x y
let func [x y] . print\n x y
x y = 1 2
let [x y] 1 2

x, y = 1, 2
[x y] = [1 2]
x, y = 1, "hello"
[x y] = [1 "hello"]
# ^ this is probably best.
# wait, but you can't chain then...
x, y, z = 1, "hello", +
[x y z] = [1 "hello" +]
# then again, it is a macro.
# it's very generic: it only looks for tokens or grouped tokens.
# this is valid, but I can't do the fibs trick. it's better to have an actual cons function.
# I guess macros can be recursive? where _ is still in the result, for example.

# I am now second guessing myself...
# if x, y = _ works, then what's the point of multiple return?
for obj [
    field, value = it
]
# maybe I still have it, but functions in general avoid doing it?
# I basically have to for this:
let [func] [
    print\n . _
]
# to pass the argument list to a function.
# although...
let [func] [
    apply print\n _
]
# this also works, and is very lispy...

x, y = _
λ [x y]
λ x, y
λ x, y [. + x y]
map (λ x, y [. + x y]) [1 2 3 4]
# now that's just vicious...

let func x, y [
    print\n x y
]

func = [
    x, y, [_] = _
]
let func [] [
    let [x y [_]] _
    for _ [
        print\n it
    ]
]
# syntax for taking the rest of the arguments?

# it's not really much shorter.
x, y = 1, 2
[x y] = [1 2]
x, y, z = 1, 2, 3
[x y z] = [1 2 3]
x, y, z, a = 1, 2, 3, 4
[x y z a] = [1 2 3 4]
# well, I double I'll assign so many arguments on one line much.

# if there wasn't mutation, this syntax would make so much more sense...
# ..., wait.
next-env.value = 123
# this... this IS mutation!

let [\n] "\n"
print x y \n

# replace $ with :, and you have python...

1 + 2
1 + 2 3 4 5 6 7 8 9
+ 1 2
+ 1 2 3 4 5 6 7 8 9
let [+] . syntax [
    [[a _ b ...] [_ a b ...] [Math.add a b ...]]
]
let [-] . syntax [
    [[a _ b ...] [_ a ...] [Math.subtract a b ...]]
]
# also valid, but uglier.
let [-]
    syntax [
        [[a _ b ...] [_ a ...] [Math.subtract a b ...]]
    ]
# I still don't know how operator precedence works though.

# maybe everything should be mutable? otherwise you can't do this:
print "Hello, World!\n"
set [eval] my-new-evaluator
print('Hello, World!');
# or some shit.

for _ [
print\n  # error: cannot start a new scope without exiting the quote.
]
# or
# contradiction: function call claims to be at the same level despite being inside function.
# I think it's better if we just say [] doesn't allow a new scope. no need to get fancy here.
# error: cannot end 'for' function call while still inside [].
# error: cannot end 'for' function call while still inside it.
# my programming language is gonna be like go and python, no freedom whatsoever.
# though I guess python isn't as bad.

for _ [
  print\n  # error: invalid indentation. only accepting multiples of 4
]
for _ [
	print\n  # error: only spaces can be used for indentation.
]
# this might too tyranical, honestly. but whatever.

# I should test how python handles indentation errors.
IndentationError: unindent does not match any outer indentation level
IndentationError: unexpected indent

let [a b] 1 2
    -where ...

# what if I combine '.' and ';' inline?
let [x] . + 1 2; print "hello"
# no, it does nothing. rather it works as usual
let [x] . + 1 2
print "hello"
# ^ equivalent to this
# but what if '.' ignores it?

# do you really need mutation? maybe I should test it out.

# I mean, if you think about it...
a, b = 1, 2
[a b] = [1 2]
str = "Hello, World!\n"
func = (print "hello")

# wait. it is still multiple return!
[value err] = my-func
# you have to partially run the function to get the value.
[x y] = [1 2]
[x y] = [(+ 1 2) (- 1 2)]

[value err] = my-func
if (err) [] []
[value] = my-func
if my-func [] []
# I don't want (begin ...) so I guess 'if' keeps the []s.
# you know what? so does every other function.

map (λ x, y (+ x y)) [1 2 3 4]
map
    λ x, y
        value = 123
        + x y value
    $ [1 2 3 4]
map (λ x, y [(+ x y)]) [1 2 3 4]
map
    λ x, y [
        value = 123
        + x y value
    ]
    $ [1 2 3 4]

# or maybe not?
x, y, z = 1, 2, 3
[x y], z = [1 2], 3
[[x y] z] = [[1 2] 3]
# if [] is destructuring (or dearraying? idk), then [[]] is double so!
# it is valid! no need for complicated macros!
# wait, but what about this?
λ x, y, z []
# and this?
x, y = _
# nah... I need to make the macro recursive or something.

func x y = (+ x y)
x = (+ 2 (func 1 1))
print\n   x  # (+ 2 (func 1 1))
print\n . x  # 4
# I guess it's only really force when you write to a file?
# it just makes more sense with quotes.
func x y = [(+ x y)]
x = [(+ 2 (func 1 1))]
print\n   x  # (+ 2 (func 1 1))
print\n . x  # 4
# and again, more consistent with 'if'.

# wait a second.
obj.field
(get field obj)
let [obj.field]
let [(get field obj)]
# if we allowed function calls...
# wait an even longer second.
let [(get field obj)]
get field obj =
# doesn't it remind you of this?
# maybe there's something here.
# like obj is immutable, but the calling function keeps getting overloaded?
# but I don't know. I can't put my finger on it.

func x y = [
    + x y
]
let [func] λ [x y] [
    + x y
]
let [=] syntax [
    [[symbols     _] [let [symbols]]]
    [[symbols ... _] [let [symbols] λ [...]]]
]

vec = [[[x] 1] [[y] 2] [[z] 3]]  # 'let'
vec.x = 10                       # 'set'
# that is great because I always though there was some overlap.
# and this works very similarly to scheme! (set-car! ...) (set-cdr! ...)

# in other words, I don't need 'set' anymore?

# lol.
Globals = [
    [[x] 1]
    [[y] 2]
    [[z] 3]
]
func = [
    Globals.x = 10
]
func
print\n Globals  # [[x] 10 ...]

# I guess we have to clone things though...
# or not?
my-obj = []
func obj = [
    obj.x = 123
]
func my-obj
# ??
# I guess we can still overload on numbers. it's still (get x obj) under there.
# oh.
(get x obj)
(set x obj 123)
# but I have the idea of referencing and dereferencing things...
# I think 'clone' is just better.
# and anyway, if '=' is like 'set-car!' and 'set-cdr!', it should also work like that.
vec = [
    [[x] 1]
    [[y] 2]
    [[z] 3]
]
func obj = [
    obj.x = 10
]
func vec
print\n vec  # [[[x] 10] ...]
vec.x = 1
func clone vec
# that or the function does the cloning.
# I'll have to figure out the convention.
# wait, you can even have a function return it's 'Settings'!
# and change the behavior of the function like that! no need for function objects or whatever!

# I like the general idea.
obj        # by value
obj.field  # by reference

x y = 1 2
func = [
    x y = . _
]
x, y = 1, 2
func = [
    x y = _
]
func x y = []
# ^ this is the cleanest and nicest looking.
for obj [
    field, value = it
]
# and this should be added to my list of beautiful parts of the language.

obj, obj.x = [], 123
print\n obj  # [[[x] 123]]

let obj [] []
let obj
print\n obj  # []

let [x y z]

# you can only mutate objects or arrays.
# functions don't have to be made immutable since you just can't mutate them!
# that's why they are lower case. good luck trying to mutate it.

# 'export' might be required. otherwise, every module's 'Globals' will overlap.
# though I say 'export'... it's just this:
func1 = [...]
func2 = [...]
func3 = [...]

$ func1 func2 func3  # 'exporting'
# I mean, if we just run the file it's all good right?

# although...
export [func1 func2 func3]
# becoming
[[[func1] func1] [[func2] func2] [[func3] func3]]
# might be useful.

export list = [
    $ for (map quote list) [
        [[it . it]]
    ]
]

ptr = [123]
func ptr = [
    ptr:0 = 321
]
func ptr
print\n ptr  # [321]
# I mean, why the hell not, right?
# no need for this.
0xffff...:0 = 321
# number bs.
# then again, that means no pointer arithmetic...
# well, I can create a low-level interface for that. easy.

fib 0 = 0
fib 1 = 1
fib n = (+ (fib (- n 1)) (fib (- n 2)))
fib n = $ . + (fib . - n 1) (fib . - n 2)
print\n (fib 1000)

fib n = $ . . match n [
    [0 0]
    [1 1]
    [_ [. + (fib . - n 1) (fib . - n 2)]]
]
print\n . fib 1000

obj "x" = 1
obj "y" = 2
obj "z" = 3

obj.x
(obj [x])
# as interesting as the concept is, I'm never using functions as objects.

# still, objects aside, how do I do this?
fib 0 = 0
fib 1 = 1
fib n = $ . + (fib . - n 1) (fib . - n 2)
print\n fib  # what does 'fib' look like?
[
    [[0] 0]
    [[1] 1]
    [[n] []]
]
# no, I think I know how to implement it.
print\n fib 0  # 0
print\n fib n  # [(λ [n]) (+ (fib (- n 1)) (fib (- n 2)))]
# what I'm trying to say it that's it's in the name.
# but no, it's too much of a pain in the ass.

# types?!?
func [u32] value = [
    + value 123
]
func [u32] 321
func 321  # unknow.
# right, 'unknow'.
# but anyway, not very good.

x = . u32 123
print\n x  # [[[type] [u32]] [[value] 123]]
# maybe this is it? just make is convention?
# or maybe this is better
x = [123 u32]
value, type = x
value-of x = x:1
type-of x = x:1
print\n u32  # "u32"
# the type is equal to it's symbol in string form
# I mean, isn't that all low-level stuff really needs?
# but I guess you can't do this then:
+ "string1" "string2"
# which I guess is fine? there was impasse where I couldn't decide if it was strings or arrays.
# I'll have to thoroughly explore how this works...
# and something tells me it's gonna be a little weird.

# didn't the ODIN programming language do explicit overloading? isn't that kind of nice for this?
# also, types should be hidden, and put on every variable.
x = 1
print\n (meta x)  # [[[value] 1] [[type] [any]]
print\n (type x)  # [any]
&x = (meta x)  # hmm, I don't know~
print\n (meta x).type
+ x 2  # 3
((meta x)).type = "string"
+ x 2  # error: cannot add 2 of type "any" to 1 of type "string".
type x = (meta x).type

# what if u32 was a macro?
u32 = . syntax [
    [[_ x] [(((meta x)).type = "u32") x]]
]

# I've been thinking, do I seriously need types at this point?
# it's not like the old model: it won't break the application if you pass in the wrong number of
# arguments. duck typing is good. we already have 'use' which is de facto typing. the only reason
# we may want types, is overloading and making it harder to break the app, I guess.
# oh, and optimizations.

func x = [
    x, type = x
    if (== type "MyType") [. error "Wrong type."]
    ...
]

Arithmetic = . type [int int] [int]
add x y = Arithmetic [
    + x y
]
func f val1 val2 = type [Arithmetic int int] [int] [
    f val1 val2
]
func add 1 2  # 3, okay
func   + 1 2  # error: expected type [Arithmetic], got type [].

# alias type
Days = int

+ x y = [
    match (type x) [
        [[u32] [Intrinsics.u32.add x y]]
        ...
    ]
]
# or something.

# I'm really thinking I should make '+', '-'... you know — the whole shebang — into infix operators
Math.add 1 2 3 4 5 6  # works like normal.
1 + 2  # doesn't work like normal...
# I probably can't do operator precedence though...

# wait.
+ = syntax [
    [[_ a b] [Math.add a b]]
]
...
# and all the other operators.
+ - 1 2 - 3 4
# so I could do this?
(Math.add (Math.subtract 1 2) (Math.subtract 3 4))

# is 'syntax' a type?

# what if it was the old model, but with significant whitespace?
+ - 1 2 - 3 4
print\n 1 2 3 4
# how did it even work again?
# oh right.
let square [* .]
square = * .
# oh my god.
# to not have the [], just don't put them.
# wait, is this shorter? the fuck?
map [+] [1 2 3 4]
# I guess I'm doing fixed number of args, fuck it.
apply f x y = f x
apply [+] 1 2
# does it work like that?
# maybe. if it's the first arg, for example.
say-hello = print\n "Hello, World!\n"
+ x y = add x y
str = "hello"
# nah, it doesn't work.
apply f x y = . f x
# better.
apply f x y =
    f x
# no, there's just a lot of weirdness.

x = 123
str = "hello"

# wait, does this get evaluated immediately?
say-hello = print\n "Hello, World!\n"
calculate = + 1 2
# probably, right?
# then again, how about no?
add x y = + x y
add = λ [x y] + x y
. x = x x
square = * .
squared = square 25
add1 = + 1
add1 n = + 1 n  # both valid.
print\n add1 2  # 3
print\n "Value of add1 2:" add1 2  # "Value of add1 2: 3\n"
# so does the assignment determin if the function can run by itself?

# or like here, 'n' is assigned to something like 'promise' so '+' curries automatically?
add1 n = + 1 n

map f ls = [...]
map (λ [x y] [(value = y) (+ x val)]) [1 2 3 4]
map λ [x y] [val = y; + x val] [1 2 3 4]
# so like, indentation is only there to limit passed arguments.

# I can't forget. everything is a function.
x = 123
str = "hello"
# these two are functions. they just take no parameters and returns the same thing.
# the way you create a new function is by putting function inside a function.
say-hello = print "Hello, World!\n"
say-hello  # "Hello, World!\n"
say-hello  # "Hello, World!\n"
# it prints everytime, so you have to put things you only want executed once outside.
add x y = + x y
func f = f 1 2
func (add)  # better.
# looking more and more like haskell.
print\n (add)  # [λ [x y] + x y]
print\n (str)  # [λ [] "hello"]
# that's how you print a function.
print\n (add 1)  # [λ [y] + 1 y]
func = + 1 2 + 3 4
func  # 3 7 ?
# we already know the argument count.
map λ [x y] [val = y; + x val] [1 2 3 4]
# like this
+ - 1 2 - 3 4
# if _ is unused, it is run or returned or whatever..
# I think that's pretty clever.

map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs

fibs = [1 2 .. zipWith (+) fibs tail fibs]
= fibs.[0 1 .. zipWith [+] fibs tail fibs]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

fibs = : : 1 2 zipWith (+) fibs tail fibs]

take 10 fibs

# maybe it should throw an error to return more than one value?
# maybe not.
+ . _

for _ as arg [
    print\n arg
]

p x = (+ (* 3 (expt x 4)) (* -2 (expt x 3)) (* 5 x) -7)
p x = + + + * 3 expt x 4 * -2 expt x 3 * 5 x -7
# infinitely better.
# although... it is hard to read.
p x = 3 * x expt 4 + -2 * x expt 3 + 5 * x + -7
# the key is always to have a few parentheses.
p x = + + + (* 3 expt x 4) (* -2 expt x 3) (* 5 x) -7
# you know, even if + takes more than one argument, this still works.
p x = + (* 3 expt x 4) (* -2 expt x 3) (* 5 x) -7
# but it breaks the other one...
# the big question: if it is redundant with fold-left, should you do it?
p x = ford-left (+) [(* 3 expt x 4) (* -2 expt x 3) (* 5 x) -7]

# $ no longer works the same? though it will probably be easier to implement (just a function).

a, b = [], []
a, b = []  # error: no values to extract for [a b].

i = 10
white < 0 i [
    i = - i 1  # I can't do this...
]
# I just realized, but I never fixed the problem with 'while'.
i = [10]
white < 0 i:0 [
    i:0 = - i:0 1
]
i = 10
white < 0 i [
    .i = - i 1
]
# just realized I wrote 'white'... as intented.

while =
    bool, body = _
    if bool [
        .. body _
        while
    ]

# if it was like this, 'while' would be an argument for body.
.. body _
    while

while = (
    bool, body = _
    if bool [
        .. body _
        while
    ]
)

say-hello = print "Hello, World!\n"  # I like this.
say-hello = [
    print "Hello, World!\n"  # and I also like this.
]
# how do I put them together?
# I'm thinking it only accepts one function call?
array = [1 2 3 4]
func = [
    1 2 3 4
]
# maybe? maybe the indentation does something?
# but I don't think this is a good idea.
vec = [
    [[x] 1]
    [[y] 2]
    [[z] 3]
]

say-hello =
    print "Hello, World!\n"
# I guess this is still permitted.
say-hello =
    print "Hello, World!\n"
    print "Hello, World!\n"
# this isn't?

# I find it ugly, but I have no reason not to accept it...
# though it's so ugly, I might just not do it at all.

# I should be careful: the second 'print' runs first.
say-hello = print "Hello, World!\n" print "Hello, World!\n"
# wait, no it doesn't! since 'print' prints things progressively!
# anyway, be careful anyway.

while = .. [
    bool, body = _
    if bool [
        .. body _
        while
    ]
]

say-hello = .. [
    print "Hello, World!\n"
]
say-hello = do [
    print "Hello, World!\n"
]

Vector3 x y z = [
    [[x] x]
    [[y] y]
    [[z] z]
]
Vector3 1 2 3
# or
Vector3 [x y z] = [
    [[x] x]
    [[y] y]
    [[z] z]
]
Vector3 [1 2 3]

# a big problem is how 'if' and 'else' still use quotes... I need consistency.

while =
    bool, body = _
    if bool
        .. body _
        while
    else
        print\n "while over"


# I don't know. if I make 'else' a macro, I could probably make it work?
# what if it only look at new lines?

# no longer valid
while =
    bool, body = _
    if bool
        .. body _
        while
    else print\n "while over"

while = .. [
    bool, body = _
    if bool [
        .. body _
        while
    ] [
        print\n "while over"
    ]
]

print "Hello, World!\n"  # valid
                print "Hello, World!\n"  # also valid

# indentation doesn't matter anymore.
# ... though, I'll throw that back around and say: how does that help me?
# significant indentation has a purpose at least! fewer parentheses!

# going python style is probably the way.
while =
    bool, body = _
    if bool
        .. body _
        while
    else print\n "while over"
# honestly, I never expected the language to go in this direction...

# I guess '.' is no longer for calling stuff... so it can be for duplicate!

square = * .
# I still can wrap my head around how simple this is...
# I used 'square' to determine how powerful the language was, and damn!
# I should have a list of all the iterations of 'square'.

if condition
    do-this
else
    do-that
# maybe it's not that hard to implement?
if condition ...
print\n _internal.if-boolean-result
else ...
# where 'else' checks '_internal.if-boolean-result'?
# it's kind of like a global value, but as you can tell by the '_', it goes deeper than that.
# there's a worry about async, but I'll figure it out.

# btw, I can do this.
if condition
    do-this
else if other-condition
    do-that
else
    do-_-um-something?
finally
    do-shit
# or just 'final'?
# then again, ugh... I don't need it, do I?
# just de-indent 'do-shit'.

# I think I want '..' to be the range operator.
# and since I'm not going to be running quotes much, this might be good.
do [
    print "Hello, World!\n"
    print "Hello, World!\n"
    print "Hello, World!\n"
]

quote = _
expand quote = _  # let quote [] _

my-obj.x
my-obj
    .x
my-obj
.x  # invalid?

x, y = y, x
# this should be possible!

# oh! doesn't that mean I can mix functions and macros?
# so...
1 + 1
+ 1 1
# are both valid?
# no need for 'Math.add'?
# I'll try it, at least.

# I should really try this:
fib 0 = 0
fib 1 = 1
fib n = + fib (- n 1) fib (- n 2)

fib n = fib (n - 1) + fib (n - 2)
# it makes it so much cleaner!

fib n = match n
    [0 0]
    [1 1]
    [n [+ fib - n 1 fib - n 2]]
# this feels so fucking wrong...
match n [
    [0 0]
    [1 1]
    [n [+ fib - n 1 fib - n 2]]
]

fib n = match n [
    [0  0]
    [1  1]
    [n  + fib - n 1 fib - n 2]
]

# btw, 'as' works differently!
for _ as val
    print\n it
# okay, that's kind of sexy.
for _ as val  print\n it

λ [x y] [+ x y]
# is better than
λ [x y]  + x y
# (it's a way to convert a quote into a function?)

# then again, maybe not
add x y = + x y
add = λ [x y] [+ x y]
add x y = do [+ x y]
# there are actually many way to convert a quote into a function.

# still, there is a reason to do it.
map λ [x y] [+ x y] [1 2 3 4]
# this is *clean*.
map (+ .. take 2 _) [1 2 3 4]
# same count, surprisingly.
map (+ .. _) [1 2 3 4]
map (+) [1 2 3 4]

# I guess .. can both be a spread operator and a function? like '.', I mean.

map λ [x y] [+ x y] [1 2 3 4]
map
    λ [x y] [
        + x y
    ]
    [1 2 3 4]
map (λ [x y] + x y) [1 2 3 4]
map
    λ [x y]
        + x y
    [1 2 3 4]
# the second one might be better, honestly.
# it matches with (+), for example... and literally the rest of the language.
map λ [x y] + x y - y x print "hello\n"
    [1 2 3 4]

map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs

map _ [] = []  # _ isn't syntax or anything. it's convention for "I don't care about it".
map f x = : f car x map f cdr xs

# what if 'as' renames the last assignment?
import "File" as fi
# oh.
import "File" as F "String" as S "HTTP" as H "OS" as O
# I think I can do something so egregious...

import "File" "String" "HTTP" "OS" as [F S H O]

func
        inner-func  # error: missing intermediate function call(s).

# it's possible for a function to return nothing...
func = print ""
# but how do you assign that?
x, y =  # like this?
x, y = nil  # might be better.

x, y = 0   # zero for both
x, y = []  # []   for both
x, y = 10  # 10   for both

# html works again, but is weird.
div class [my-class1] style [background: black]
    content "Hello, World!" br

# wait we can't do this...
x, y = []
# it was already explained why.
x, y = [[] []]
x, y = [], []

bool x = if x "true" else "false"
# still works even though 'else' is inside true block?

vec.(symbol)  # can be both a function call, or a variable... although variables are functions.

# JS style objects?
[
    name: "age"
    age: 21
]
; separates inline things.
[ name: "age"; age: 21 ]

# 'as' is technically inside the body.

# best:
while (i=10) < 0 i
    print\n i
    i = - i 1

# wait
while (i = 10; < 0 i; i = - i 1)
    print\n i

# now this is just a classic for loop! (boomer loop)
# the fuck, I can even do do/while this way... as long as it doesn't return any value.
# though I can learn from if/else and do it the normal way too.

p x = + + + * 3 expt x 4 * -2 expt x 3 * 5 x -7
p x = + + + * expt x 4 3 * expt x 3 -2 * x 5 -7
# how do I put all the function calls on the left?

i = 10
i = while < 0 i
    print\n i
    - i 1
# no... it doesn't work.

obj
    .x = 123
...
obj.x = 123

# honestly, don't like .i = - i 1 as 'set' equivalent.

# anyway, the language heavily favors
x = if ...
# and stuff like that

do
    print\n "hello"
while condition

indentation->parentheses []

i = [10]
while [> i:0 0]
    print\n i
    i:0 = - i:0 1
# the only way it actually works.

    i:0 = - i:0 1
    *i = - *i 1
    i.* = - i.* 1
    &i = - &i 1

# maybe things should just be immutable, and the language requiring declarativeness?
# but then, no _internal.if-boolean-result...

# :: and := might be required...

func: print "hello"
# is better than
[[func] print "hello"]

field, value = it
print\n value  # prints properly even if function.
# 'get' is the thing that runs the function.

# it's always trade off after trade off after trade off: for one part of the language to look
# pretty, the other has to look ugly.

# one of the case for useful overloading: hashmaps. you can use all the standard functions, even
# print prints the thing like a normal list.

func = + 1 2 3 4
func -> 3 3 4
# I should try _ returning with the older model.

# returning _ forces you to handle it without exceptions. it's good! and even if you don't handle
# it, it still useful!

[[str] ["hello"]]  # everything is a function.
# this is probably the better way to do objects in the new model.

File = [
    open:  ...
    close: ...
]

Object = [
    say-hello:
        print "Hello, World!\n"
    say-goodbye:
        print "Goodbye, World!\n"
]
Object.say-hello
Object.say-goodbye
# this is kind of nice.

Arithmetic = [
    add      x y: + x y
    subtract x y: - x y
    multiply x y: * x y
    divide   x y: / x y
]
# no as nice.
Arithmetic = [
    add x y:
        + x y

    subtract x y:
        - x y

    multiply x y:
        * x y

    divide x y:
        / x y
]

Arithmetic = [
    add x y = + x y
    subtract x y = - x y
    multiply x y = * x y
    divide x y = / x y
]

Object = [
    say-hello =
        print "Hello, World!\n"
    say-goodbye =
        print "Goodbye, World!\n"
]
Object.say-hello
Object.say-goodbye

Object = [
    field say-hello
        print "Hello, World!\n"
    field say-goodbye
        print "Goodbye, World!\n"
]

vec = [ x: 1; y: 2; z: 3 ]
vec = [
    x: 1
    y: 2
    z: 3
]
vec = [
    x = 1
    y = 2
    z = 3
]

Object: [
    say-hello:
        print "Hello, World!\n"
    say-goodbye:
        print "Goodbye, World!\n"
]
# maybe I should go the 'red programming language' route?
vec: [ x: 1; y: 2; z: 3 ]

# maybe I should go back to that one old idea, where functions are objects? just quoted.
# I mean, it's looking an awful lot like a function here.
# wait, maybe I'm unto something?
Object :: [
    say-hello   :: print "Hello, World!\n"
    say-goodbye :: print "Goodbye, World!\n"
]
# right? you can make fields immutable this way.

vec: [ x: 1; y: 2; z: 3 ]
vec = [ x = 1; y = 2; z = 3 ]
# hmm. what if a single ':' is for mutable stuff?
x, y: y, x
# no, this looks ugly.
x, y := 1, 2
x, y = y, x

x, y: int

vec = [ x = 1; y = 2; z = 3 ]
# the problem I have with this is as follows:
for vec
    field, value = it
    print field "=" value
# right? if '=' returned a value, this might work. but it doesn't does it?
# if it did return a value, I would have to rework everything.
# even assuming '.x' ran the object as a function, and got the environment from it,
# how would I do mutation?

# what if '=' was just made to look like a function?
# but it's not actually? like the macro is replaced temporarily?
# to begin with, there's no way to accidentally access the field of a function, since functions run
# automatically. and since they run automatically, only actual object would have '=' in them.
# maybe there's something to be done with memoization?
# like you run 'vec', but then the value of 'vec' is replaced with it's environment?
# but then, how do you handle subsequent '.x's?

# and that doesn't explain this:
field, value = it
# this is extremely important.
vec = [
    [[x] [1]]
    [[y] [2]]
    [[z] [3]]
]
# this might be the only way.
# and yet...
Object = [
    [[say-hello]
        print "Hello, World!\n"
    ]
    [[say-goodbye]
        print "Goodbye, World!\n"
    ]
]

vec = object [ x = 1; y = 2; z = 3 ]
print\n vec  # [ [[x] [1]] [[y] [2]] [[z] [3]] ]
# as usual, macros make everything nicer.

# though, I considering this.
vec = object
    x = 1
    y = 2
    z = 3
# right? because []s are a taboo now.

Object = object
    say-hello
        print "Hello, World!\n"
    say-goodbye
        print "Goodbye, World!\n"
# maybe this is the best?

# then again, maybe not.
Object = object
    say-hello =
        print "Hello, World!\n"
    say-goodbye =
        print "Goodbye, World!\n"

    other-fields  # functions can be called like this.

vec = object (x = 1; y = 2; z = 3)
# very weird...

# when you do this,
vec.x = 10
# doesn't the whole object just get rebuilt?
vec = [
    x = 1
    y = 2
    z = 3

    env  # return environment
]

x: 1  # returns [[x] [1]]
# this maybe just be the right way to go...

Arithmetic = [
    add: +
    subtract: -
    multiply: *
    divide: /
]
# best of all:
Object = [
    say-hello:
        print "Hello, World!\n"
    say-goodbye:
        print "Goodbye, World!\n"

    other-fields  # here, 'other-fields' only has to multiple return [[field] [value]]!
    # or really, and bear with me...
    do any-object
]
# amazing.

# btw,
func x y:
    + x y
# is a little ugly.
func:
    x, y = _
    + x y
# might be the convention to follow.
# though, just in case, I should make ':' work kind of like '='.

# damn, that means I get to keeps this!
vec = [ x: 1; y: 2; z: 3 ]
# and this!
Object = [
    say-hello:
        print "Hello, World!\n"
    say-goodbye:
        print "Goodbye, World!\n"
]
# they were the most beautiful!
# though there is still that one problem of []s...
# but that can be saved with $!

# wait, fuck. what do I do for indexing now...

i = [10]
while [> i:0 0]
    print\n i
    i:0 = - i:0 1
# with immutability
loop [10]
    [i] = _
    print\n i
    it - i 1

else = T
if F [
    do-something
] F [
    do-something
] else [
    do-something
]
# builtin 'else if'!
# wait, do I even need 'cond' at this point?!
# even better, the 'else if' conditions don't even get run, since the language is lazy!

# I think I should one again consider doing the older model when functions are just strings.
# this is extremely interesting, mind you, but I've explored it enough to see some road blocks...

let p [x] $ . + (*  3 . expt x 4) (* -2 . expt x 3) (* 5 x) -7
p x = $ . + (*  3 . expt x 4) (* -2 . expt x 3) (* 5 x) -7

# how about this:
.x = 10
# equivalent to 'set'.
# but I figure out the details later.
i = 10
while [< 0 i] [
    print\n i
    .i = - i 1
]

vec = [[[x] 1] [[y] 2] [[z] 3]]
# huh.
i:0 =
[[i] 0] =
let [[i] 0]
# maybe they are less mutually exclusive than I thought...
# maybe I can make something of this.
i.x =
[[i] [x]] =
let [[i] [x]]
# the problem is 'get'.
i:0
(get-index i 0)
i.x
(get-field i "x")

vec = [x: 1; y: 2; z: 3]
vec = [(get-index x 1); (get-index y 2); (get-index z 3)]
# or not... I don't how to make this work.
i = []
i:0 = 10
get-index "i" 0 = 10
print\n i:0
print\n get-index "i" 0
# um, does that mean anything can be an array?
# no, this is too scuffed. the more I think about it, the more... ugh.

# btw, get-index is also often overloaded, so you can do low-level array shit too.

get-index-typed "HashMap" list index = HashMap.get-index list index
get-index list index = get-index-typed (type list) list index
get-index list index = get-index-typed type . list index  # duplicate list
# not gonna lie, this is a pretty suave to do overloading.

overload get-index [
    [[HashMap] HashMap.get-index]
    [[Array]     Array.get-index]  # low-level shit
]

Object = $
    say-hello:
        print "Hello, World!\n"
    say-goodbye:
        print "Goodbye, World!\n"

Object = [
    say-hello: [
        print "Hello, World!\n"
    ]
    say-goodbye: [
        print "Goodbye, World!\n"
    ]
]

Object = [
    $ [say-hello] [
        print "Hello, World!\n"
    ]
    $ [say-goodbye] [
        print "Goodbye, World!\n"
    ]
]
# this is ironically the most sensible.
# but ':' is just really nice. I probably won't do it though.

map [. + . take 2 _] [1 2 3 4]

# I just realized.
i:0 = 10  # this might be impossible.
# because the ':' macro runs first.
get-index i 0 = 10
# unless I actually do this.
get-index "i" 0 = 10

x = [] as HashMap  # 'as' is for typing?

# this works if _ automatically returns!
for _ . as val [
]
while . i = 10 [< 0 i] [
    print\n i
    i = - i 1
]
# here too.
loop . as my-loop . i = 10 [
    print\n i
    my-loop - i 1
]
# the '.' naturally separates things...
# though this doesn't work.
loop . as my-loop [
    i = . _
    print\n i
    my-loop - i 1
] 10
loop 10 as my-loop
    [i] = _
    print\n i
    my-loop - i 1
# ...

let [.] syntax [
    [[_ a ...] [(a ...)]]
    [[a_b] [a_ b] [a _b] [get [b] a]]
]
. = (syntax [
    [[_ a ...] [(a ...)]]
    for [[a_b] [a_ b] [a _b]] $ [it [get [b] a]]
])

# wait, I just realized.
bool x = if x "true" else "false"
# this DOESN'T work!
# since 'else' only inside the body of 'if', and therefore doesn't run when x is false!
# this was an interesting diversion, but let's go back to using parenthese everywhere, while also
# hiding them all with macros.

bool x = $ . if x ["true"] else ["false"]

map . λ [x y] [. + x y] [1 2 3 4]  # valid because _ returns!

 x = 1  # let
.x = 1  # set

obj.x
obj
    .x  # doesn't make sense.
# equivalent to this:
obj(.x)

# this means: let the interpreter figure out the number of 'next-env.next-env.next-end..' you need.
.x = 1

map .λ [x y] [.+ x y] [1 2 3 4]  # ...
# nah, I like that it's same the character count.

print\n . ((Iter [1 2 3]).map [+ 1 (args)]).collect

# maybe macros can set their own precedence?
# that or repeatedly expand into a list of things.

macro = . syntax [
    [[_ a ...] [5 _ a ...)]]
    [[5 _ a ...)] [4 _ a ...]]
    [[4 _ a ...)] [3 _ a ...]]
    [[3 _ a ...)] [2 _ a ...]]
    [[2 _ a ...)] [1 _ a ...]]
    [[1 _ a ...)] [(_ a ...)]]
]

# I still think numbers shouldn't be assignable to hashmaps.
vec = [
    [[x] 1]
    [[y] 2]
    [[z] 3]
]
# if that's the case, I can do this:
vec = [
    x: 1
    y: 2
    z: 3
]
# hell, they ARE assignable, just not like normal.
enumerate [1 2 3]  # [
    [[0] 1]
    [[1] 2]
    [[2] 3]
]
for . enumerate [1 2 3] [
    index, value = it
    print\n index ": " value
]
# 0: 1
# 1: 2
# 2: 3

# ... no. I shouldn't destroy something that works, just because I want some nice syntax. let's
# give up on ':' for objects.

# 'debug' shows the real stuff, like metadata with the type and content.
# 'print' overloads on the type, and prints accordingly.
# I guess some types can be printed unless you defined how to first?
# like rust traits.
# I should probably make things fairly easy to overload and 'derive' from.

# 'take' should probably multiple return.
map [. + . take 2 _] [1 2 3 4]
fib-10 = [. take 10 fibs]

# what if the old everything is a function model, but I don't remove []s?
for enumerate [1 2 3] [
    index, value = it
    print\n index ": " value
]
# 0: 1
# 1: 2
# 2: 3

func x y = [+ x y]
str = $ "hello"  # heh. $ for $tring
x = 123

say-hello = [
    print "Hello, World!\n"
]

for _ as arg [
    print\n arg
]

map [+ take 2 _] [1 2 3 4]
map λ [x y] [+ x y] [1 2 3 4]

Object = [
    $ [say-hello]
        print "Hello, World!\n"
    $ [say-goodbye]
        print "Goodbye, World!\n"
]

Object = [
    $ [say-hello] [
        print "Hello, World!\n"
    ]
    $ [say-goodbye] [
        print "Goodbye, World!\n"
    ]
]
# better, but you have to run for numbers and strings.

# ... no, I'm done with this for a while.
str = "hello"  # it has to look like this.
# it fails at something basic like this, so no thanks.
# plus the objects are ugly. just no thanks.

if condition
    do-something
else
    do-something-else
# it had some sexy code, I'll say that much.
if condition [
    do-something
] else [
    do-something-else
]

if condition [
    do-something
] condition [
    do-something
] else [
    do-something
]
# then again... well, sure. it is 'cond' basically.

if condition [ do-something ] [ do-something ]
if condition [ do-something ] . else-if condition [ do-something ]  # this might be nicer.
# wait, because the language is lazy... you don't even need 'else-if', just 'if'...
if condition [ do-something ] . if condition [ do-something ]

if condition [
    do-something
] . if condition [
    do-something
] [
    do-something
]
# I think this is it. especially considering how easy it is to refactor...

# maybe I should do this now?
true  x y = $ . x
false x y = $ . y

class [my-class1] . style [background: black] . div [
    $ "Hello, World!" . br
]
# uh. I don't know.

# what if macros run from the right? the only reason for that of course being this:
obj.x = 123
# but then...
x, y = y, x

# btw, let's just do currying.
map (+) [1 2 3 4]
(+)  # returns the function partially executed.

# wait a second. 'partially executed'?
square = . * . d
# so like, this works? I mean, they return 'functions', right?
let square [* .]
square = * .

# I should try 'let' again.
let [square] . * . d

x = 123 is u32
# 'compile' is also overloaded?
# oh my god:
if . my-cond = dup T [
]

say-hello = print "Hello, World!\n"
say-hello = {
    print "Hello, World!\n"
}
# maybe it is time for reintroductions?
# "why do we need this?" you may ask.
# here's why:
say-hello =
    print "Hello, World!\n"
    print "Hello, World!\n"
# this is no longer valid.
x = 1 2    # returns 2
print\n x  # outputs 1

# ... ok, I thought about it more thoroughly.
say-hello =
    print "Hello, World!\n"
    print "Hello, World!\n"
# this is not valid, because like the ()s model, it runs...
# okay, no. seriously, why is it not valid?

# fuck it, it is valid, but {} is equivalent to 'do []'.
say-hello = do [
    print "Hello, World!\n"
    print "Hello, World!\n"
]
say-hello = {
    print "Hello, World!\n"
    print "Hello, World!\n"
}

func =
    +
        + 1 2 + 3 4
    -
        - 1 2 - 3 4
# I guess this isn't valid??
# well, it can be, but '=' and 'let' decide not to do so.
# only one thing is being assigned to 'func'.
# but that doesn't work. the only way this works is this isn't a function anymore.
say-hello = print "Hello, World!\n"
# and this is unquoted:
say-hello = { print "Hello, World!\n" }
# but then, it doesn't follow the everything is a function thing...

# alright, here's what I'm thinking:
if condition {
    do-something
} if condition {
    do-something
} {
    do-something
}
if condition { do-something } if condition { do-something } { do-something }
# this should be possible.
if condition "my-string" if condition "my-string" "my-string"
# this as well.
if condition [1 2 3 4] if condition [1 2 3 4] [1 2 3 4]
# and this.
# now, does it actually works?
# my thinking is that {} returns an unquoted string.
# if doesn't overload on it, he just runs the body like a function, returns whatever.

let square [* .]
square = {* .}
# eh.
# wait, no. CURRYING!
square = * .  # this returns a curried function!
# this still fucking works!
# and this!
my-print = print
# Haskell Curry would be proud.

# still, I should be careful. this here is a function that returns a function!
square = {* .}

# $ should probably be for {}.
say-hello = $ print "Hello, World!\n"

# god, I want this to work.
# the best 'square' implementation.
# currying, short function chaining, no parentheses...
# no python style, functions with variable arg count, powerful macros (functions)...
# please, make it work.

say-hello = λ [] [print "Hello, World!\n"]  # maybe [] to convert?
say-hello  # outputs "Hello, World!\N"
λ [] [print "Hello, World!\n"]  # returns {print "Hello, World!\n"}
# but can you run it immediately?
(λ [] [print "Hello, World!\n"])  # do parentheses do the job?
# I don't know, though... ()s are used for currying and limiting the number of arguments.
# λ is still a function like any other.

unquote []
λ [] []
lambda [] []

quote = { _ }
quote = $ _

{ print\n .. _ }

# what if we combine {} and currying?
print123 = { print\n .. _ } 1 2 3
# no.
say-hello = {
    print "Hello, World!\n"
}
# doesn't work for side-effects, or in general.

# fucking unquote.
# I've been struggling with this fucking function for so fucking long...

.. [print\n .. _] 1 2 3  # outputs 1 2 3
# this is how you run a function inline.
# λ is exclusively for returning.
.. λ [] ["hello"]  # error: symbol 'hello' is not bound.
# because λ already unquoted the thing.

# even then. even then, I don't think this will work.
# the model where you explicitely call a string using ()s is just better.
# no ambiguity to anything. sure, it is more verbose, but I've seen how those '.'s could separate
# function calls and make it easier to read. it's not like it's impossible to be nice.

# I should let it die.
# I need to let it die.
# parentheses are the future.
# return to simplicity.
# even though it is verbose, it is simpler.
# it is easier to think about, and that is better than terseness.
# at this point, if I want 'everything is a function', I might as well go with python style.
# I might as well go all the way.
# but I don't want to.
# so I am keeping the parentheses.

say-hello = [
    print "Hello, World!\n"
]
say-hello
# there is nothing that can be done.
# this is the model I will likely keep.
# no matter how much I change my mind, this will not change.
# the end result is set in stone.

# my only complaint about this model is that it is (more) verbose...
# ((all hail the parentheses God!))

# wait a second.
if condition [
    do-something
] if condition [
    do-something
] [
    do-something
]
# I don't think I need '.' for this...
# 'if' runs the else block. the body of 'else' is the definition of 'if'.
# and the 'if' statement as a whole should be able to take extra arguments...
# or not?
if condition [
    do-something
] [...] condition [
    do-something
] [
    do-something
]
# hmm...
if condition [(print\n . _)] [(print . _)] "hello"
# here, "hello" should be returned as an unused argument.
# and the prints, should print the argument of the function or the top-level.

if condition [(do-something)] . if . _
# I guess it is equivalent to something like this?
# *sigh*, I haven't defined the rules for how _ works yet... I don't know.
# know what what? no, it doesn't work.
if condition [(do-something)] . if ["hello"]  # error: symbol 'hello' not bound.
# this returns an error, because the first 'if' excepts a string to run.
# huh.
if condition print\n "true"
# so... logical conclusion, is that this here works?
# that's, like, wild.

# dear lord, I have to define the rules for _.
# this is going nowhere.
# though it might be impossible without defining how 'if' works first.

func = [
    inner-func = [
        print\n . _
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4
# big question: what happens here.
# I think 'inner-func' should print '5 6 7 8'.
# there is no reason for it to behave differently than 'func'.
# it's not like there isn't a _ variable at the top-level. (cli args)
# if I did want this to work, I should rename _, or pass it as an argument.

# rename.
func = [
    rename _ args
    inner-func = [
        print\n . args
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4

# pass as arg.
func = [
    inner-func = [
        print\n . _
    ]
    inner-func . _
]
func 1 2 3 4

# ... I think this is good as a way to rename as well.
func [args] = [
    inner-func = [
        print\n . args
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4

# then again...
func = [
    [args] = _
    inner-func = [
        print\n . args
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4

# wait, no. this isn't what's happening!
func = [
    [[args]] = _
    inner-func = [
        print\n . args
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4

# okay, I think this works.
func = [
    x, y, [args] = _
    inner-func = [
        print\n . args
    ]
    inner-func 5 6 7 8
]
func 1 2 3 4

# ... I know. for a while now, I've failed to address the elephant in the room.
# "what about optional arguments?"
# what about them? I don't fucking know! that's fucking what!!
# trying to make them work with currying, with _ returning, with the = macro... dear lord.
# fuck. that reminds me. I have yet to figured out how to make '.' and ':' work with '='...

# I guess for 'if', _ is in fact like a new function, but 'if', when calling the new function, also
# passes in the the outer _?
new-if cond then else = [
    if cond [
        then . _
    ] [
        else . _
    ]
]
# I don't think that cleared anything up... I'm even more confused now.
# ... then again, maybe not. _ is clearly anything that comes after 'cond', 'then' and 'else'.

[(print\n . _)] 1 2 3 4  # 1 2 3 4
print\n   . _   1 2 3 4  # (outputs cli args) 1 2 3 4

add evaluation-steps [=]
# like, macros or syntax have to be added to a list of steps?
# I imagine significant indentation is in there too.

if condition
    [(print\n . _)] 1 2 3 4
    [(print\n . _)] 1 2 3 4
# returns curried if.

# is there a general rule that I can come up to make _ work both ways?
# like maybe it's not passed any arguments, it defaults to the upper scope?
# or the arguments of the upper scope is automatically appended at the end?
# but if I did that...
func = [
    [(print\n . _)] 1 2 3 4
]
func 5 6 7 8  # outputs 1 2 3 4 5 6 7 8
# do I want this?
# if I don't solve this... even the for loop would be affected...
for _ [
    print\n it
]
# then again, maybe not as much.

if condition [
    print\n . _
] [
    print . _
] . _
# I really need to figure this out...

if condition print\n "true"
# okay, I have a better undestanding of this.
# it doesn't work.
if condition print\n [] "true"
# but this does.
# just make sure the obligatory 'else' branch gets it's value, and you're good.

# hmm. I have to redefine 'new-if'.
# otherwise, it will be curried if the 'else' branch is not given.

# still, there's maybe a way for me to make it work differently?

# I just realized, even this doesn't work.
new-if cond then else = [
    if cond [
        then . _
    ] [
        else . _
    ]  # gotta add '. _' here.
]
# the inner 'if' has no extra arguments, lol.
new-if cond then else = [
    if cond [
        then . dynamic-scope._
    ] [
        else . dynamic-scope._
    ]
]

# should I fix it? or does it work as intended?

new-if cond then else = [
    if cond [
        then . _
    ] [
        else . _
    ] . _ . @_  # dynamic _?
]

# I suppose this works now, unfortunately.
if condition [
    do-something
] if condition [
    do-something
] [
    do-something
]
# it's consistent, at least.
