[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
   print a
   print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
   = n 0 0
   = n 1 1
   true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
   eprint msg
   exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functionnal and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
   ? | = n 0 = n 1
      n
      + fib - n 1 fib - n 2

(define (fib n)
   (if (or (= n 0) (= n 1))
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functionnal caracteristics.]

[Converted jai code]
atom [render] do [
   fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
   fill-rect bar-rect unpack-color BAR-COLOR
   for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
   print [Hello, World!]

   if true
      print [yes]
      print [no]

   loop print [loops forever]
   for 0 10 print format [prints 10 time. this is [i]]
   while condition [you know.]

   [<3]
]

[Procedural vs functionnal]
atom [main] do [
   add [x] 1 2
   eq [y] x 3
   if y print [truth] print [falsehood]
]
atom [main] do [
   if eq 3 add 1 2
      print [truth]
      print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
   format x [Hello [y], my name is [z]]
   print x
]
atom [complex x y z] do [
   atom x format [Hello [y], my name is [z]]
   print x
]

[Holy fuck! Procedural actually beats functionnal... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
   : [x] 1 1
   tail [y] fib:x
   zipWith [y] [+] fib:x fib:y
   : [x] x y
]
atom [fib out init] do [
   : out init out
   tail [t] out
   zipWith [z] [+] out t
   : [out] out z
   fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
   print [do stuff...]
   > bool a b
   if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
   atom [temp] x
   atom x y
   atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
   atom [low] 0
   len [high] items
   sub [high] high 1
   <= [cond] low high
   atom [continue?] true
   while cond do [
      add [mid] low high
      div [mid] mid 2

      cmp [c] mid target
      equal? c do [atom result mid atom [continue?] false]
      less? c do [atom [low] mid add [low] low 1]
      more? c do [atom [high] mid sub [high] high 1]

      <= [cond] low high
      && [cond] cond continue?
   ]
]

atom [binary-search target items] do [
   atom [low] 0
   atom [high] sub len items 1
   atom [continue?] true
   while && <= low high continue? do [
      atom [mid] div add low high 2

      atom [c] cmp mid target
      equal? c do [mid atom [continue?] false]
      less? c atom [low] add mid 1
      more? c atom [high] sub mid 1
   ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
   proj-rect [pr] proj-x proj-y
   unpack-color [pc] PROJ-COLOR
   fill-rect pr pc

   unpack-color [bc] BAR-COLOR
   fill-rect bar-rect bc

   for targets-pool do [
      target-rect [tr] it
      unpack-color [tc] TARGET-COLOR
      if !it.dead fill-rect tr tc
   ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
   add [x] x y
   print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functionnal...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
   add [x] x y
   print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
   add [x] x y
   print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
   add [z] x y
   format [f] [[x] + [y] = [z]]
   print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
   add [z] x y
   format [f] [[x] + [y] = [z]]
   print f
]

[vs]

atom [test] do [
   add [z] x y
   format [f] [[x] + [y] = [z]]
   print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
   add [z] x y
   format [f] [[x] + [y] = [z]]
   print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functionnal way for the bros:]
atom [test x y]
   print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
   print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functionnal translate on the lower level?]
atom [x] 1 atom [y] 2
   print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functionnal, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
   print [still true]
   break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
   sub n 1
   == n 0
   false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
   proc
   loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
   cmp [result] it to
   = error [[it] and [to] cannot be the same values; please try another combination.]
   > for-
   < for+
]
atom [for-] do [
   proc
   sub [it] 1
   cmp it to
   != for it to proc
]
atom [for+] do [
   proc
   add [it] 1
   cmp it to
   != for it to proc
]
atom [for-each items proc] do [
   get-len [len] items
   for 0 len proc
]
atom [while proc] do [
   atom [while?] true
   atom [label] while?
   while-arg
]
atom [while-arg] do [
   proc
   if label while-arg []
]

[But functionnal may actually come out of it as well...]
atom [+ x y] do [
   add [x] x y
   x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
   add [x] x y
   x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
   proc
   next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
   proc
   next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
   y
   add [x] x y
]
+ 1 + 2 3
[Should I consider functionnal again?]

