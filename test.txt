[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
   print a
   print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
   = n 0 0
   = n 1 1
   true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
   eprint msg
   exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functionnal and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
   ? | = n 0 = n 1
      n
      + fib - n 1 fib - n 2

(define (fib n)
   (if (or (= n 0) (= n 1))
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functionnal caracteristics.]

[Converted jai code]
atom [render] do [
   fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
   fill-rect bar-rect unpack-color BAR-COLOR
   for targets-poolif !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
   print [Hello, World!]

   if true
      print [yes]
      print [no]

   loop print [loops forever]
   for 0 10 print format [prints 10 time. this is [i]]
   while condition [you know.]

   [<3]
]

[Procedural vs functionnal]
atom [main] do [
   add [x] 1 2
   eq [y] x 3
   if y print [truth] print [falsehood]
]
atom [main] do [
   if eq 3 add 1 2
      print [truth]
      print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
   format x [Hello [y], my name is [z]]
   print x
]
atom [complex x y z] do [
   atom x format [Hello [y], my name is [z]]
   print x
]

[Holy fuck! Procedural actually beats functionnal... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
   : [x] 1 1
   tail [y] fib:x
   zipWith [y] [+] fib:x fib:y
   : [x] x y
]
atom [fib out init] do [
   : out init out
   tail [t] out
   zipWith [z] [+] out t
   : [out] out z
   fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
   print [do stuff...]
   > bool a b
   if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
   atom [temp] x
   atom x y
   atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
   atom [low] 0
   get-len [high] items
   sub [high] high 1
   <= [cond] low high
   while cond do [
      add [mid] low high
      div [mid] mid 2

      cmp [c] mid target
      equal? c atom result mid
      less? c do [atom [low] mid add [low] low 1]
      more? c do [atom [high] mid sub [high] high 1]

      <= [cond] low high
   ]
]

atom [binary-search target items] do [
   atom [low] 0
   atom [high] sub get-len items 1
   while <= low high do [
      atom [mid] div add low high 2

      atom [c] cmp mid target
      equal? c atom result mid
      less? c do [atom [low] add mid 1]
      more? c do [atom [high] sub mid 1]
   ]
]


