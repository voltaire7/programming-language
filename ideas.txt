[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
    print a
    print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
    eprint msg
    exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functionnal and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

(define (fib n)
    (if (or (= n 0) (= n 1))
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functionnal caracteristics.]

[Converted jai code]
atom [render] do [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
    print [Hello, World!]

    if true
        print [yes]
        print [no]

    loop print [loops forever]
    for 0 10 print format [prints 10 time. this is [i]]
    while condition [you know.]

    [<3]
]

[Procedural vs functionnal]
atom [main] do [
    add [x] 1 2
    eq [y] x 3
    if y print [truth] print [falsehood]
]
atom [main] do [
    if eq 3 add 1 2
        print [truth]
        print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
    format x [Hello [y], my name is [z]]
    print x
]
atom [complex x y z] do [
    atom x format [Hello [y], my name is [z]]
    print x
]

[Holy fuck! Procedural actually beats functionnal... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
    : [x] 1 1
    tail [y] fib:x
    zipWith [y] [+] fib:x fib:y
    : [x] x y
]
atom [fib out init] do [
    : out init out
    tail [t] out
    zipWith [z] [+] out t
    : [out] out z
    fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
    print [do stuff...]
    > bool a b
    if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
    atom [temp] x
    atom x y
    atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
    atom [low] 0
    len [high] items
    sub [high] high 1
    <= [cond] low high
    atom [continue?] true
    while cond do [
        add [mid] low high
        div [mid] mid 2

        cmp [c] mid target
        equal? c do [atom result mid atom [continue?] false]
        less? c do [atom [low] mid add [low] low 1]
        more? c do [atom [high] mid sub [high] high 1]

        <= [cond] low high
        && [cond] cond continue?
    ]
]

atom [binary-search target items] do [
    atom [low] 0
    atom [high] sub len items 1
    atom [continue?] true
    while && <= low high continue? do [
        atom [mid] div add low high 2

        atom [c] cmp mid target
        equal? c do [mid atom [continue?] false]
        less? c atom [low] add mid 1
        more? c atom [high] sub mid 1
    ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
    proj-rect [pr] proj-x proj-y
    unpack-color [pc] PROJ-COLOR
    fill-rect pr pc

    unpack-color [bc] BAR-COLOR
    fill-rect bar-rect bc

    for targets-pool do [
        target-rect [tr] it
        unpack-color [tc] TARGET-COLOR
        if !it.dead fill-rect tr tc
    ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
    add [x] x y
    print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functionnal...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
    add [x] x y
    print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
    add [x] x y
    print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[vs]

atom [test] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functionnal way for the bros:]
atom [test x y]
    print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functionnal translate on the lower level?]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functionnal, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
    print [still true]
    break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
    sub n 1
    == n 0
    false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
    proc
    loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
    cmp [result] it to
    = error [[it] and [to] cannot be the same values; please try another combination.]
    > for-
    < for+
]
atom [for-] do [
    proc
    sub [it] 1
    cmp it to
    != for it to proc
]
atom [for+] do [
    proc
    add [it] 1
    cmp it to
    != for it to proc
]
atom [for-each items proc] do [
    get-len [len] items
    for 0 len proc
]
atom [while proc] do [
    atom [while?] true
    atom [label] while?
    while-arg
]
atom [while-arg] do [
    proc
    if label while-arg []
]

[But functionnal may actually come out of it as well...]
atom [+ x y] do [
    add [x] x y
    x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
    add [x] x y
    x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
    proc
    next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
    proc
    next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
    x
    add [x] x y
]
+ + 1 2 3
[Should I consider functionnal again?]

[Wait, no. Shit gets fucked up.]
atom [x] + 1 2 atom [y] 3 do [
    x
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    + 1 2
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        x
        add [x] x y
    ]
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        1
        add [x] x y
    ]
    add [x] x y
]
[Maybe if I made [x] and [y] local to the procedure?]

atom [add-all x y] do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
]
add-all 1 2 3 []
atom [x] 1 atom [y] 2 do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
] 3 []
atom [x] 1 atom [y] 2 add-all x 3 []
[Hm. Does it really work like that?]

[More functionnal]
let [x y] 1 2
atom [x] 1 atom [y] 2

[Should be equivalent?]
atom [func x y] []
atom [func] do [let [x y]]

[Maybe it's that simple?]
atom [atom name value] push-key name value atoms
[But any more than, and we're implementing stuff.]

[Functionnal again]
atom [+ x y] do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
+ + 1 2 + 3 4
atom [x] + 1 2 atom [y] + 3 4 do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        1 2
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        3 4
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
[Is it impossible? Well whatever. I can tell already: the hoops you have to jump through to get this
behavior is insane. I will probably still try to make this work, but the procedural way is far
better. You know, left-to-right and infix is just more elegant.]

chain 1 + 2 + 3 + 4 as [test]
print _ [outputs 10]
print test [outputs 10]
[I mean look at this! It's fucking beautiful!]

[Rust syntax]
atom [let name] []
atom [= value] atom [name] value
atom [;] atom [name] []
let [test_val] = 2 ;
[Well, "Rust" syntax.]

[Delete]
atom [delete name] atom name []

[I don't think this language should have something like function overloading.]

[Maybe I could have a [type] [Single] that can only be called once, and once done, it will be
removed from the list of variables?]

[If each variable has the following values:]

struct [atom] [
    name value before after
]

[where [name] is of course the symbol of the [atom], then [value] is the what it returns, or the
pointer to the value in memory. What if there was [before] and [after], where [before] is code that
gets executed before the value is called, while [after] is code executed after it's called. So like,
in [before] we could have a macro that sets up the arguments of the procedure, then adds the [value]
after the declarations? And in [after], I could have some RAII clean up? I think I'm unto something,
but the idea needs polishing.]

[Btw, if I do [before] and [after], I could probably do this:]
type [+] [
    before atom [x] prev 1
    after atom [y] next 1
]
atom [+] add [_] x y
1 + 2 print _
[I'm not sure where I'm going with this, frankly.]

[Maybe the entire program is actually a list of tokens that can change itself.]
1 2 3 print get 1 program
[outputs 2?]

[Or maybe...]
atom [+] add #-1 #1
1 + 2
[where #n is a relative value? But how do [add] work then?]

[I really need to start working on the implementation. There's only so much I can do with only
theory, and so little technical knowledge.]

[I know that, eventually, everything becomes [hex []], and then gets executed. But how does it do
it? *Sigh*]

[I feel like python will be more useful for learning how to write this programming language than
Rust or C...]

[Is this programming language becoming too complicated, like LISP nowadays?]

[I should stick with the S Expressions. Adding anything else is bloat.]

[Btw, the model where we do [add #-1 #1] is interesting but stupid, because what is [add] defined
as? There is still a lesson here though. Just need to find out which.]

[Maybe I shouldn't have a hex procedure? Maybe numbers simply get hexecuted (?) when 32 bits have be
gathered? Maybe numbers are just functions that reduce to themselves in binary format?]

[I think I should just use hexadecimal for all number types. Like what, is anyone going to use my
programming language expect me? And little endian too. Of course that would mean I need to get used
to hexadecimal, and convert it off the top of my head, but otherwise, I should try it and see how it
works.]

[Incidentally, in regards to trying out things, I think the 3 space indent is bad. I tried it for
some C code, and while it isn't as noticeable for small procedures, for larger ones, 3 spaces just
feels wrong. Not to mention, 4 spaces is byte aligned.]

[I think I might replace every instance of [atom] with [macro], because that's what they are. But I
don't know. [atom] sounds real nice.]

[If I write]
mov x0 [str]
[should x0 now have the utf-8 value of [str]? I feel like yes... But that would mean that mov isn't
a parameterless macro... Though.]

[This blows. I found out that the way an instruction is encoded is not necessarily byte aligned, an
so I will find it difficult to write the most basic macro...]

[And now chatGPT tells me that not every instruction is 32 bits. This is going to be so difficult.]

[Oh hey there, I didn't see you. So after giving RISC-V's specification a look I saw that unlike
arm64, the opcode is the smallest value, and the destination register is the thing that follows. So
I think I'm going to try and run the programming language on a RISC-V platform. This is of course
far harder than it sounds, but no harm in trying.]

[The idea about abandonning [hex []] is no longer realistic. To begin with, opcodes are not byte
aligned, whether on arm64 or RISC-V. So I'll instead have something call [bin []].]

[Damn, I don't think I could even do something like [[mov] -> 000000] because, we do do know that
[x1] will be a fixed size, but not the number that follows.]

[I am a little conflicted now: in [foo] could just be a function pointer, and you call the pointer
by putting parentheses after it. This is elegant, and I like it. Question is, how do I replicate the
behavior? Do I just quote it? But then, how is it different from a normal string? How do I, for
example, [printf] a function pointer? Damn, this is tough.]

[Ok this is something that might give LISP edge: by typing [func], you get the function pointer, by
typing [(func arg1 arg2)], call the function. But man, this sucks, because I build this whole idea
over the premise that the LISP model is imperfect. I can cede just yet...]

[I figured it out, if every value in LISP returns a pointer by default, then you would have to call
variables as well (even more parentheses; heck no!). And in C, you constanly reference and
dereference a variable, which is the equivalent of quoting and unquoting, but with a different
syntax. Not to mention you don't really have symbols. In which case, I still need to figure out the
tug of war between symbols, pointers and values.]


