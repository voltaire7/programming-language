[Model 1 - S Expressions]
atom [a] 2
atom [a] [This is a string.]
atom [b] do [print a]
list [b] [print a]
list [c] [
    print a
    print ++ a a
]
atom [add x y] + x y
add 1 2

[Model 2 - Omnifix Expressions];
atom [a] [This is also a string.]
[b] atom [And this as well.]
[c] [And this.] atom
list [d] [print a]
[This gets printed.] print
a print
print b

[Fib à la Haskell]
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
fib = 1 : 1 : zipWith (+) fib (tail fib)
print (fib 1000)

[Fib à la Model 1]
atom [fib n] cond [
    = n 0 0
    = n 1 1
    true + fib - n 1 fib - n 2
]
atom [fib n] ? | = n 0 = n 1 n + fib - n 1 fib - n 2
atom [fib] : : 1 1 zipWith [+] fib tail fib
print fib 1000

[Fib à la Model 2];
[fib] list [dup = 0 ? [] [dup = 1 ? [] [dub dup - 1 swap - 2 fib swap fib +]]]
[fib] list [d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +]]
[list [fib] [1 : 1 : fib fib tail zipWith [+]] ;[Probably doesn't work...]];
1000 fib print
1000 dup = 0 ? [] [dup = 1 ? [] [dub - 1 swap - 2 fib swap fib +]] print
1000 d d = 0 s = 1 | ? [] [d - 1 s - 2 fib s fib +] print

[Interesting fact about Model 1]
atom [list x y] atom x do y

[So yeah, I'm sticking with Model 1. Kinda sucks for Model 2. Had high hopes for it.]

[Oh shit, comment function:]
atom [comment x y] y
+ comment [This is ignored.] 1 2
[Shit, it's just the KI combinators... Or yay?]

[Maybe in path ./src/]
::modules:fib 1000
[[::] could be [..]?]

[Maybe also a function called alter?]
atom [alter old new] todo

[Also todo from Rust.]
atom [todo] panic [Not implemented yet.]
list [panic msg] [
    eprint msg
    exit 1
]

[Rules instead of types?]
rule [a] [i32]
atom [a] 35

[Model 3 - Procedures]
list [x] [push 1 push 2 add]

[On second thought... I don't really need a Model 3. I can make Model 1 both functional and
procedural. I think that's the best, yeah. The question is how do I keep the abstraction to a
minimum.]

[Model 1 vs Scheme]
atom [fib n]
    ? | = n 0 = n 1
        n
        + fib - n 1 fib - n 2

(define (fib n)
    (if (or (= n 0) (= n 1))
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

[A procedural programming language with functional caracteristics.]

[Converted jai code]
atom [render] do [
    fill-rect proj-rect proj-x proj-y unpack-color PROJ-COLOR
    fill-rect bar-rect unpack-color BAR-COLOR
    for targets-pool if !it.dead fill-rect target-rect it unpack-color TARGET-COLOR
]

[Other shit]
atom [test] do [
    print [Hello, World!]

    if true
        print [yes]
        print [no]

    loop print [loops forever]
    for 0 10 print format [prints 10 time. this is [i]]
    while condition [you know.]

    [<3]
]

[Procedural vs functional]
atom [main] do [
    add [x] 1 2
    eq [y] x 3
    if y print [truth] print [falsehood]
]
atom [main] do [
    if eq 3 add 1 2
        print [truth]
        print [falsehood]
]

[Declarative wins character count. But you don't have to declare variables in imperative.
Food for thought. Nevermind. You still have to name them. Wait, you can reuse the name? Fuck, I
don't know!]

[More complex procedure]
atom [complex x y z] do [
    format x [Hello [y], my name is [z]]
    print x
]
atom [complex x y z] do [
    atom x format [Hello [y], my name is [z]]
    print x
]

[Holy fuck! Procedural actually beats functional... I know this is an edge case, but if there's a
lot of mutable state in your app, it could benefit from it.]

[I certainly like the limited indentation of procedural programming. As well as how it's read
left-to-right. Damn, I'm stuck.]

complex [a] [John] [Jane]

[Fib procedural]
atom [fib] do [
    : [x] 1 1
    tail [y] fib:x
    zipWith [y] [+] fib:x fib:y
    : [x] x y
]
atom [fib out init] do [
    : out init out
    tail [t] out
    zipWith [z] [+] out t
    : [out] out z
    fib
]
atom [fib] : : 1 1 zipWith [+] fib tail fib

[This might be the best I can do right now. No, this may be impossible without functions returning
values.]

[Adding something to PATH; importing.]
atom [core] usr:name:local:lang:core

[Recursion]
atom [recur] do [
    print [do stuff...]
    > bool a b
    if bool recur print [all good]
]

[Then again...]
atom [number] 123
atom [string] [Hello, World!]
atom [say-hello] print string

atom [add-num] add [n] number 321
add-num
print add-num:n
[or]
atom [add-num n] add n number 321
add-num [n]
print n

[What differenciates a variable and a procedure?]

atom [swap x y] do [
    atom [temp] x
    atom x y
    atom y temp
]
atom [x] 1
atom [y] 2
swap [x] [y]

atom [binary-search result target items] do [
    atom [low] 0
    len [high] items
    sub [high] high 1
    <= [cond] low high
    atom [continue?] true
    while cond do [
        add [mid] low high
        div [mid] mid 2

        cmp [c] mid target
        equal? c do [atom result mid atom [continue?] false]
        less? c do [atom [low] mid add [low] low 1]
        more? c do [atom [high] mid sub [high] high 1]

        <= [cond] low high
        && [cond] cond continue?
    ]
]

atom [binary-search target items] do [
    atom [low] 0
    atom [high] sub len items 1
    atom [continue?] true
    while && <= low high continue? do [
        atom [mid] div add low high 2

        atom [c] cmp mid target
        equal? c do [mid atom [continue?] false]
        less? c atom [low] add mid 1
        more? c atom [high] sub mid 1
    ]
]

[I think I should stick with the imperative + declarative styles, make them work together.]

[Problem is that declarative does not function the same way as assembly. I don't like the
inconsistency... But then again, why does [atom] sometimes define procedures, sometimes variables?
Not that is not very consistent.]

atom [render] do [
    proj-rect [pr] proj-x proj-y
    unpack-color [pc] PROJ-COLOR
    fill-rect pr pc

    unpack-color [bc] BAR-COLOR
    fill-rect bar-rect bc

    for targets-pool do [
        target-rect [tr] it
        unpack-color [tc] TARGET-COLOR
        if !it.dead fill-rect tr tc
    ]
]

[Procedural is almost always more verbose. Thought I was onto something for a second there.]

[Also, I'm not doing [list] anymore: unnecessary.]

[Holy fucking shit]
atom [add-print x y] do [
    add [x] x y
    print x
]
add-print 1 2
[becomes]
atom [x] 1
atom [y] 2
add [x] x y
print x

[It might be possible to make it as tacit as functional...]

[Every procedure should have an opposite that reverse a change.]
undo
for 2 undo

[Most elegant?]
atom [func] do [todo x y]
atom [x y] 1 2
func [becomes] todo x y

[Also, [atom [] do []] may not be possible... Because do is executed during asignment.]

[Maybe...]
atom [test-func] reduce [
    print [Somthing]
]
[This might the best.]
atom [say-hello] [print [Hello, World!]]
[There's some polishing required here...]

[Wait no! [print] does do [reduce], it just doesn't execute, because [atom] returns nothing!]
[God, I'm so smart.]

[LOL]

[Wait... but that means that means that arithmetic operations don't get precalculated?]

atom [calculate] do [
    add [x] x y
    print x
]

atom [x y] 1 2 calculate
atom [x y] 1 2 do [
    add [x] x y
    print x
]

[Actually, [do] should be completely lazy, otherwise it fucks everything up. Like, how do you reduce
two add operations into one? You can't. And you shouldn't. This is an assembly-like programming
language. Most things are arithmetic.]

[You can do eager evaluation as follows:]
add [temp] 1 2
add [CONSTANT] temp 3

atom [calculate] print CONSTANT
calculate
[will print [6]]

[Seems to work for now. It's like python for now, where it's not actually a constant, but I don't
know... I could add a [rule] to make them throw and [error] when trying to call [atom] on a
pre-assigned constant?]

[I shouldn't shy away from the [proc arg1 arg2] format. It's more tacit, and more consistent with
the intrinsics.]

atom [test x y] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[vs]

atom [test] do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]
atom [x y] 1 2
test
[reduces to]
atom [x y] 1 2 do [
    add [z] x y
    format [f] [[x] + [y] = [z]]
    print f
]

[Honestly, both are very elegant. But the most tacit one is... fucking neither! Damn. They are both
the same exact character count...]

[Still, I will stick with the second one. You only have to define a procedure once. And once you do,
you can call it as many times as you want.]

[Also, functional way for the bros:]
atom [test x y]
    print format [f] [[x] + [y] = [add x y]]
test 1 2
[reduces to]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]

[Fuck, it's still so much nicer...]

[But how does functional translate on the lower level?]
atom [x] 1 atom [y] 2
    print format [[x] + [y] = [add x y]]
[becomes]
mov [x1] 1
mov [x2] 2
add [x1] x1 x2
[string manipulation magic]
[syscall to print]

[The thing about functional, it that you don't need to name value. Everything is chained. But can't
I do that with procedural as well? Pretty sure.]
<= 1 0 true? print [yes] false? print [no]

[I can even have ifs]
<= 1 0 if print [yes] print [no]
[Holy fuck, prefix procedures look infix!]

[I don't care if it's worse. It's closer to how computers work. I will make it work. Someway,
somehow.]

[Also, [env] needs to get worked, to make it so calling a library procedure doesn't fuck up the
[control flow] of a local procedure. Put another way, [cond] should be local.]

[I keep getting ideas...]
atom [break] atom [continue-loop?] false
while do [
    print [still true]
    break
]

[Chaining operations]
atom [chain x] []
atom [+ y] add x y

chain 1 + 2 + 3
atom [x] 1 [] add [x] x 2 add [x] x 3

[This is so cool...]

[Lemme try some tail optimized recursion.]
atom [func n] do [
    sub n 1
    == n 0
    false? func n
]

[When a procedure interacs with the left hand side of the code, it's a procedure, but when it
interacs with the right hand side, it's a macro. But macros are also procedures, only procedures
that write code. That's why the programming language has this weird way of processing, where if the
code wants to interact with code from the left, it has to do so through pointers, while with code on
the right, it's just text that has yet to be converted into data or other code.]

[Inline assign]
atom [as symbol] atom symbol out
chain 1 + 2 as [result]
print result
import [numpy] as [np]
[^ a funny]

[I don't think I should abuse it like this but it's interesting to think about.]
atom [if val1] []
atom [== val2] cmp [bool] val1 val2
atom [then proc] eq? proc
atom [else proc] ne? proc
if 1 == 0 then print [equal] else print [!equal]
[[then] and [else] could be intrinsics]

[Sometimes my genius is... it's almost frightening.]

[Loops should be like this:]
loop print [loops forever]
repeat 10 print [loops 10 times]
for 0 10 print [loops starting at 0, until 10 is reached]
for-each [0 1 2] print it
while print [loops until [while?] becomes false]
[[repeat] and [for] need a variable to keeps track of the count, so there's no need to define a
value for [it].]

[Here are some definitions for the loops]
atom [loop proc] do [
    proc
    loop proc
]
atom [repeat to proc] for 0 n proc
atom [for it to proc] do [
    cmp [result] it to
    = error [[it] and [to] cannot be the same values; please try another combination.]
    > for-
    < for+
]
atom [for-] do [
    proc
    sub [it] 1
    cmp it to
    != for it to proc
]
atom [for+] do [
    proc
    add [it] 1
    cmp it to
    != for it to proc
]
atom [for-each items proc] do [
    get-len [len] items
    for 0 len proc
]
atom [while proc] do [
    atom [while?] true
    atom [label] while?
    while-arg
]
atom [while-arg] do [
    proc
    if label while-arg []
]

[But functional may actually come out of it as well...]
atom [+ x y] do [
    add [x] x y
    x
]
+ + 1 2 3
atom [x] + atom [y] 1 do [
    add [x] x y
    x
] 2 3
[Seriously, what does [atom [proc] do []]?]

[I need a better understanding of assembly to figure this out.]

[Wait does this mean this is valid?]
atom [apply proc] proc
apply add [x] x y

[So these should also be equivalent]
atom [proc] do [] proc
atom [proc] [] do proc
[One way or another, something will be loaded from memory, and that sonething will be executed.]

[Also]
atom [join proc next] do [
    proc
    next
]
join add [x] x y join add [x] x y []
atom [join proc next] join proc join proc join proc []
join add [x] x y
atom [proc] add [x] x y atom [next] join proc 
[What the fuck am I doing?]

[I'll try again]
atom [join proc next] do [
    proc
    next
]
atom [thing] join proc1 join proc2 join proc3 []
[This is what I had in mind. I don't know how it's better than do [] though...]

[I'm conflicted about this...]
atom [+ x y] do [
    x
    add [x] x y
]
+ + 1 2 3
[Should I consider functional again?]

[Wait, no. Shit gets fucked up.]
atom [x] + 1 2 atom [y] 3 do [
    x
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    + 1 2
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        x
        add [x] x y
    ]
    add [x] x y
]
atom [x] + 1 2 atom [y] 3 do [
    atom [x] 1 atom [y] 2 do [
        1
        add [x] x y
    ]
    add [x] x y
]
[Maybe if I made [x] and [y] local to the procedure?]

atom [add-all x y] do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
]
add-all 1 2 3 []
atom [x] 1 atom [y] 2 do [
    == y []
    false? do [
        add [x] x y
        add-all x
    ]
] 3 []
atom [x] 1 atom [y] 2 add-all x 3 []
[Hm. Does it really work like that?]

[More functional]
let [x y] 1 2
atom [x] 1 atom [y] 2

[Should be equivalent?]
atom [func x y] []
atom [func] do [let [x y]]

[Maybe it's that simple?]
atom [atom name value] push-key name value atoms
[But any more than, and we're implementing stuff.]

[Functional again]
atom [+ x y] do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
+ + 1 2 + 3 4
atom [x] + 1 2 atom [y] + 3 4 do [
    x y
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        x y
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
atom [x] + 1 2 atom [y] + 3 4 do [
    atom [x] 1 atom [y] 2 do [
        1 2
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    atom [x] 3 atom [y] 4 do [
        3 4
        proc? [x] atom [x] _
        proc? [y] atom [y] _
        add [_] x y
    ]
    proc? [x] atom [x] _
    proc? [y] atom [y] _
    add [_] x y
]
[Is it impossible? Well whatever. I can tell already: the hoops you have to jump through to get this
behavior is insane. I will probably still try to make this work, but the procedural way is far
better. You know, left-to-right and infix is just more elegant.]

chain 1 + 2 + 3 + 4 as [test]
print _ [outputs 10]
print test [outputs 10]
[I mean look at this! It's fucking beautiful!]

[Rust syntax]
atom [let name] []
atom [= value] atom [name] value
atom [;] atom [name] []
let [test_val] = 2 ;
[Well, "Rust" syntax.]

[Delete]
atom [delete name] atom name []

[I don't think this language should have something like function overloading.]

[Maybe I could have a [type] [Single] that can only be called once, and once done, it will be
removed from the list of variables?]

[If each variable has the following values:]

struct [atom] [
    name value before after
]

[where [name] is of course the symbol of the [atom], then [value] is the what it returns, or the
pointer to the value in memory. What if there was [before] and [after], where [before] is code that
gets executed before the value is called, while [after] is code executed after it's called. So like,
in [before] we could have a macro that sets up the arguments of the procedure, then adds the [value]
after the declarations? And in [after], I could have some RAII clean up? I think I'm unto something,
but the idea needs polishing.]

[Btw, if I do [before] and [after], I could probably do this:]
type [+] [
    before atom [x] prev 1
    after atom [y] next 1
]
atom [+] add [_] x y
1 + 2 print _
[I'm not sure where I'm going with this, frankly.]

[Maybe the entire program is actually a list of tokens that can change itself.]
1 2 3 print get 1 program
[outputs 2?]

[Or maybe...]
atom [+] add #-1 #1
1 + 2
[where #n is a relative value? But how do [add] work then?]

[I really need to start working on the implementation. There's only so much I can do with only
theory, and so little technical knowledge.]

[I know that, eventually, everything becomes [hex []], and then gets executed. But how does it do
it? *Sigh*]

[I feel like python will be more useful for learning how to write this programming language than
Rust or C...]

[Is this programming language becoming too complicated, like LISP nowadays?]

[I should stick with the S Expressions. Adding anything else is bloat.]

[Btw, the model where we do [add #-1 #1] is interesting but stupid, because what is [add] defined
as? There is still a lesson here though. Just need to find out which.]

[Maybe I shouldn't have a hex procedure? Maybe numbers simply get hexecuted (?) when 32 bits have be
gathered? Maybe numbers are just functions that reduce to themselves in binary format?]

[I think I should just use hexadecimal for all number types. Like what, is anyone going to use my
programming language expect me? And little endian too. Of course that would mean I need to get used
to hexadecimal, and convert it off the top of my head, but otherwise, I should try it and see how it
works.]

[Incidentally, in regards to trying out things, I think the 3 space indent is bad. I tried it for
some C code, and while it isn't as noticeable for small procedures, for larger ones, 3 spaces just
feels wrong. Not to mention, 4 spaces is byte aligned.]

[I think I might replace every instance of [atom] with [macro], because that's what they are. But I
don't know. [atom] sounds real nice.]

[If I write]
mov x0 [str]
[should x0 now have the utf-8 value of [str]? I feel like yes... But that would mean that mov isn't
a parameterless macro... Though.]

[This blows. I found out that the way an instruction is encoded is not necessarily byte aligned, an
so I will find it difficult to write the most basic macro...]

[And now chatGPT tells me that not every instruction is 32 bits. This is going to be so difficult.]

[Oh hey there, I didn't see you. So after giving RISC-V's specification a look I saw that unlike
arm64, the opcode is the smallest value, and the destination register is the thing that follows. So
I think I'm going to try and run the programming language on a RISC-V platform. This is of course
far harder than it sounds, but no harm in trying.]

[The idea about abandonning [hex []] is no longer realistic. To begin with, opcodes are not byte
aligned, whether on arm64 or RISC-V. So I'll instead have something call [bin []].]

[Damn, I don't think I could even do something like [[mov] -> 000000] because, we do do know that
[x1] will be a fixed size, but not the number that follows.]

[I am a little conflicted now: in [foo] could just be a function pointer, and you call the pointer
by putting parentheses after it. This is elegant, and I like it. Question is, how do I replicate the
behavior? Do I just quote it? But then, how is it different from a normal string? How do I, for
example, [printf] a function pointer? Damn, this is tough.]

[Ok this is something that might give LISP edge: by typing [func], you get the function pointer, by
typing [(func arg1 arg2)], call the function. But man, this sucks, because I build this whole idea
over the premise that the LISP model is imperfect. I can cede just yet...]

[I figured it out, if every value in LISP returns a pointer by default, then you would have to call
variables as well (even more parentheses; heck no!). And in C, you constanly reference and
dereference a variable, which is the equivalent of quoting and unquoting, but with a different
syntax. Not to mention you don't really have symbols. In which case, I still need to figure out the
tug of war between symbols, pointers and values.]

[Iteration may actually be better than recursion... I mean, in assembly you have branch and branch
with link; so while you usually do recursion, it's not really the same.]

[More details about eager vs lazy.]
chain 1 + 2 + 3 + 4 as [val]
macro [val] do [chain 1 + 2 + 3 + 4]
[The first one is eager because the program takes those additions and executes them left-to-right;
the second one is lazy because [macro] gets executed, but not the arguments, since they are absorbed
into the procedure call.]

[I've been getting pretty decent at the CLI, but doing so, I question having to put [] around every
thing that isn't a function or procedure call. Maybe I should follow LISP in this?]

[Another reason why I shouldn't do [import] and instead just reference a file like a script is that
I want the compiler to be single pass, but doing it otherwise would be complicated.]

[Okay, so big problem for procedural:]
atom [add x y z] todo
[How do I define it?]
atom [add x y z]
    atom x + y z
[Like this? Do you see the problem? Thing is, I'm trying to merge [add] and store instructions into
the same thing, but they are not the same thing. The solution could be as follows:]
atom [+ x] do [
    add x0 _ x1
    store x0 [_]
]
[where everything returns to [_]. Only the instructions themselves will keep use the old format, the
rest will behave much like functional, but still left-to-right.]

[But then again...]
atom [+ x] atom [_] add _ x

[It's important I get this right, because if I don't, the programming language may be dog shit.]

[Maybe everything that hasn't been defined yet evaluates to itself, quoted. So that's how I could do
numbers.]

[I might want to create a proper proper LISP first using my low level model, just to get the hand of
it.]

[Perhaps...]
atom [recursive-proc x y] do [
    todo x y
    goto [recursive-proc]
]
[that way, there is no need to redefine [x] and [y] since they are already defined.]

[[before] and [after] may be too much. An [env] should only have [symbol], [value] and [size].]

[Do I really need dependent types? Is there no better way to check for correctness?]
atom [val x] do [
    < x 0 true? error [cannot be negative]
    todo
]
val -1
[The linter should be smart enough to tell that this will always throw, and warn you of it. No need
for types; they are too complicated anyway.]

[I am all the more motivated to create a LISP, because of this:]
(define func (lambda (a) (display a)))
[Because it's eager loaded, lambda executes, creates a procedure, and returns the pointer to it.]
(func "Hello, World!")
(func func) [outputs something like 0x20D1A5BC]
[Holy fuck, is this elegant...]

[Maybe]
atom [func] lambda [a] print a
func at [func]
[outputs something like 0x20D1A5BC]
func do [func] [Hello, World!]

[In LISP, you have special notation for quoting, but everything else is call by value or call a
procedure. In my language, lists are quoted by default, and if a procedure has args, they are called
by default, when not quoted. But that was the funcionnal one. What about procedural?]

atom [func] lambda [a] print a
[Does not work because [lambda] is lazy. And procedures shouldn't be able to returns things.]
lambda [a] print a as [func]
[I think this works, but should I?]

[Once again, functional is making a comeback.]
[Also, I really need to figure out how to lazy [print]...]

[Okay, lazy vs eager eval really fucks me up, because you have to mix them up, right?]
atom [test] do [
    other-func lambda [x] x
    print _
]
[Does lambda create a new procedure everytime [test] is called?]

atom [func] lambda [x y] todo
[[lambda] is eager, but todo is not? What is the logic behind that?]
lambda [x y] todo as [func]
[More ugly but makes more sense. Maybe I already found the answer; and I'm just being stupid:]
lambda [x] x
atom [test] do [
    other-func _
    print _
]
[I guess it is still better than LISP, since I doesn't have some arbitrary procedures that lazy
instead of the eager default.]

[I should drop the eager function as arguments, or whatever. Doesn't make sense with new model:]
atom [func x y z] do [
    print x
    print y
    print z
]
func [add] 1 2
[becomes]
do [add] 1 2
[wait no... I have to rework [do []] if I do that...]

[I should consider it seriously still... The biggest problem is [atom] and it's implementation.]
[Maybe [list] will make a comeback? Nevermind again. There is simply no way of doing this without
having non-quoted lists.]

[Ok, let's think. Because I think I am unto something.]
[Still a comment/string]
(define [name] 5)
(print name) [outputs [pointer] so bad]
(print (name)) [outputs [value] so good]

[Ok, now without parentheses, or less.]
[Comment]
define [name] 5
print name [outputs [value] so good]
print ptr-to name [outputs [pointer] so good]
[problem is: should it be eager or lazy]

[cannot be eager]
define [func x y] do []

[this can]
define [func] lambda [x y] [print x print y]
func 1 2
[becomes]
let [x y] 1 2 do [print x print y]
[but should I?]

[what about]
define [func x y] ()
[yeah, I've got nothing. I thought I was unto something last night; something to do with parentheses
to be used for eager loading, but I don't remember what.]

[wait no, the lisp example works because the [value] of [name] is a pointer to a pointer!]
[damn, I went through this train of thought a while ago...]

[In any case...]
atom [atom symbol return] do [
    ch symbol len > 1
    then do [
        car symbol as [name]
        cdr symbol as [params]
        atom name lambda params return
    ]
    else append env symbol return
]
[but it has to be lazy, otherwise [then do []] will get evaluated.]
[god this shit is confusing]

[maybe...]
atom [then x] if _ x []
atom [else x] if _ [] x

[it should be lazy, but then I can't do [lambda]...]

[optionnal []?]
define name 3
atom [define x y] do [
    quoted? x atom x y
    else atom quote x y
]
[something like that?]

[it would be a bad practice though, but would make the all variables are quoted if undefined work.]

[Hmm, if I do this...]
atom [items] [ 1 2 3 ]
[This would be a 5 [strings] or [u8] pointers, and the atom macro would see that the first pointer
points to a value representing a array oppening, and then do the magic.]

[Man... What the first macro takes the rest of the programming language as parameters? I think I had
this idea before, but I would love to see this work!]
+ 1 2 - 3 4
[[+] takes the first two values, then the rest; since it knows it only need two values, it simply
executes [eval] or something like that, then [eval] executes the rest accordingly. If it's a
[string], it calls eval on the next value; so on.]

[Again, infix syntax, but not really.]
atom [| x y] x _ y
quote name | atom [John Doe]
[Basically piping, but dummer. Equivalent:]
quote name atom _ [John Doe]
[This is not valid...]
atom quote name [John Doe]
[Since there are only side-effects.]
[Also, I guess [x] is the first argument, while [y] is the rest of the application?]

[Okay, listen.]
atom [proc1] do [
    get args 1 as arg1
    print arg1
]
[because [args] is the rest of the application. So you can just index into it like some ordinary
array. I love this!]
[In fact, I can probably still do this:]
atom [proc1 x y z] do []
[equivalent]
atom [proc1] do [
    get args 0 as x
    get args 1 as y
    get args 2 as z
]
[Like bro, this is more elegant than anything I've come up with before!]

[Holy fuck.]
print [test]
print [test again]
[Usually, when you call a procedure, the things get put in the stack, but because the procedure
you're calling is the one calling the next procedure, you fix most problems with recursion just like
that!]

calculate bottom top = sum $ filter (\x -> mod x 2 == 0) [bottom..top]
[suppose...]
atom [calculate bottom top] do [filter []]

[I don't really like this]
1 + 1 print _
1 + 1 dbg
[I probably won't keep debug, idk]

[Functional won't die]
atom [print x] do [
    quote? x
        then write x
        else do [
            x args
            print _
        ]
]
[so]
print + 1 2 [outputs 3]

[the beauty of this language is that anything is permissible]
[the ugliness of this language is that anything is permissible]

atom [+ x y] do [
    num? x else do [x args as x]
    num? y else do [x args as y]
    + x y
]
print + * 1 2 - 3 4

[I don't think I have to check for variables though?]
atom [name] [Joe]
print name
[Damn, I don't know!]

[btw, just remembered that I still don't know how to do [atom [] do []], at least not elegantly.]

[in [bc] you can do [sqrt(2)] and the result is [1], but with [sqrt(2.0000000000)] and the result is
[1.4142135623]; very interesting.]

[The reason why [+ + 1 2 + 3 4] will never be possible is because in [+ a b], [a] and [b] will have
to be argumentless functions that always return the same thing, which is obviously not procedural.]

[Then again... Yeah, functional will never die. Anyway, can't way to finally put this project into
motion.]

[*Sigh*... Maybe I should add types... Otherwise, it becomes such a pain in the ass.]
1.2 + 5 print _
[How is [+] supposed to know if 1.2 is a float without specifying it...? [+float] maybe?
[float-add]?]

[Maybe I will have types, but they are not user declared?]

atom [func x] fn [
    print x
]
[[fn] is eager, compiles the quoted code and returns pointer to it?]
atom [val1] [func]
[[val1] = symbol to function.]
do val1 1 [outputs [1]]
atom [val2] func 2 [outputs [2]]
[[val2] = [] because [func] got evaluated, and returned nothing?]

fn [x] [print x] as [func]
[more standard lambda?]

[still, I could make it so [atom] always evaluates the value, it's just that if it's a variable,
then the variables value will get assigned to [_]?]

[maybe I could consider this:]
atom var [this is a string]
atom [var] [print [this is code]]
[...but I already decided not to do this. If I do, the floodgates will open...]

[btw, [let]]
let [
    a 2
    b 5
] []
atom [let x y] fn [
    count x as x-len
    for 0 x-len [
        get x it as [x0]
        += [it] 1 get x it as [x1]
        atom x0 x1
    ]
    do y
    x-len / 2 pop _
]
[maybe a way to do scoping?]
[nvm, can't define global variables this way.]
[wait, not [pop 3] but reverse of [for]?]

[right, almost forgot, if [fn] or whatever compile completely, we would need to compile the program
supposing that we can stand long load times, since once the procedures have been assigned, and
therefore compiled, they will run like it's a binary. food for thought.]

[Perhaps this is the only overloading I need?]
2 + 2 [integer addition]
2.0 + 2.0 [floating point addition]
[you would need to keep track of what value is what type yourself. The programming language doesn't
do it for you.]
2 + 2.0 [float added to int; fucks shit up]
[also, I guess imaginary and complex numbers are kind of the same as integers, so you just need to
keep track of that yourself as well.]
[there's also this]
2u64 + 2 [but maybe not? since temporary storage is like fixed size, but then again, it's also just
a pointer... idk]
[anyway, I should first try to avoid metadata like the plague, and see what happens.]

func 1 2 as [val e]
[multiple assignement?]

1 > 0
    then print [is bigger]
    else print [is smaller]
[^ this may be impossible, since [get args 1]]
atom [then x] [
    [insert branching logic]
        x args
]
[since args is just a pointer, and the [x] in the assignement move the pointer right, you can just
do this.]
[still, it might be useful to have something like this:]
1 > 0 ?
    print [is bigger]
    print [is smaller]
[to prevent else from executing. idk.]
[wait, shit. I remember now why I had to quote [x]: how do I know the args of [print] shouldn't be
executed?]
1 > 0
    then [print [is bigger]]
    else [print [is smaller]]

[btw, this may be possible:]
atom [func x] [
    do-shit x
    x args
]
1 func [+] 2 print _
[nice.]

[I'm still debating variable and procedure assignement.]
proc [x y] [x + y print _] as [add-show]
[^ this works, but it's ugly.]
atom [func x y] + x y
[doesn't work because of lazy vs eager.]

[i think this is the best:]
atom a 2                            [value of 2]
atom str [this is a string]         [pointer to string]
atom func' func                     [same pointer]
atom [hello x y] [print [hello, world]] [compile procedure, [hello] now has the pointer to it.]

[but that opens so many doors, and closes a few.]
atom [+= val n] [
    n + val as val
]
[or maybe it doesn't close doors?]

[i should really consider this]
let [a 1 b 2]
[idk in what form though.]

[Wait a second...]
atom [func x y] fn [print [thing]]
[this may be possible if [fn] moves [args] to the right.]
[not very useful, though, since [fn] can't return anything...]

[still can't do this though]
0 then print x
[[print] needs to be evaled to move [args]]

[Sometimes, it's just ugly. I don't think I should go to such lengths just to avoid
[proc [] [] as [f]]]
[Death to syntaxic sugar!]
[Also, quoting non-evaulated strings is just better. No suprise there.]

[I could do this, though it's ugly.]
0 then 1 print x
[where]
proc [skip f] [
    [branching logic]
        f args
    += args skip
] as [then]
[could be worse]

[Remember to implement flipjump in the language.]

[I guess it's also a bit like vertical align: it's ugly but objectively better...]

[maybe I could have [proc] and [item]?]

[I doubt I could compile a procedure using the C interpreter, but I could probably do a scuffed
variant, one that write C code to a file, compiles it and then executes the binary.]

[I should have donut shaped code that prints donut as a demo.]

[My [env] stack should have standard CRUD operations, plus upsert.]

[I should make [bin-exec] as small as possible, i.e. ignore all the characters other than 0 and 1.]

[I realized something.]
2 print _ [outputs 2]
item [a] 2
a + 2 print _ [panic at a, because it is treating [a] as a procedure pointer.]
ch a + 2 print _ [outputs 4]
[guess [ch] makes a comeback.]
[btw, would've been classy is it was called [return] instead of [ch], but it's too long, and it
doesn't make sense in a lot of situations.]

[I should consider making numbers not special. So the simplicity is taken to the extreme. Like
functional, it needs testing.]

[Also, experiment with tabs for vertical align.]

[Should do tetris in C, then in this language.]

[I should mention, this language is procedural, yet it is still takes inspiration from lambda
calculus.]

[Don't forget to experiment with spaced variable names. I doubt I will actually use it in
production, but I want to see what it would look like.]

[btw, the way procedure calls are done, allows infinite recursion.]

[When I finally figure out how vim works, I will make Control+S wall.]

[Maybe [return] could assign the [_] of the outside scope!]

[Damn, procedure definition may be easier than I anticipated!]

[Should have procedures to manually push or pop a env.]

[1.0 will only release at the end of my life, after I will have thoroughly tested the language.]

[Recursion doesn't really work.]
proc [] [
    func
] as [func]
[How is it supposed to know that it's called [func]?]

[Probably will have to use [goto]]
proc [] [
    label [start]
    do-stuff
    goto start
] as [func]

proc [label] [
    item [start] position
]
proc [start] [
    item [position] start
] as goto
[I heard that [goto] is, like, literally Hitler, but this is the cleanest way to do recursion,
without doing recursion.]
[We're getting further and further away from functional programming...]

[I'm curious, just how different will the implementation turn out to be?]

[Wait, couldn't I just use [goto]? no need for procedures and all that – yeah, this language is
getting worse by the second.]

[If you want to redefine [eval] and use the new one, you can only do so by calling it on a [Quote].]
proc [code] [
    [do-things]
] as [eval]
eval [print [Hello, World!]]
[or]
read-file [main.txt] eval _
[You know what? The procedure notation is growing on me. I don't know how to feel.]

[Oh shit, I might have to manually [free] strings like in C, if I really don't want metadata...]

[Maybe I should use [mark] instead of [label]?]

proc [e] [
    print [%s\n] e
    exit 1
] as [error]
[where [e] is a pointer to a string. It has a unique id and error message!]
item [index-out-of-bounds] [Index %i is larger than the maximum %i\n]
throw index-out-of-bounds
[wait no]
proc [e] [
    item [err] e
] as [throw]
[It should do something like assigning to the super env. Like [return] but for errors, and instead
of using [_], we use [err] or [e].]

[Holy!]
item [code] [
    print [hello\n]
]
do code
[This looks good!]

[Recursive printing?]
item [x] [%\n]
print [%s] x 5
[prints [5\n]]

[I think I should really make separate procedures for [insert] and [update]...]

[Damn, I'm seriously considering adding metadata...]
1 + 1 print _ [Can't even do that!]
[Adding metadata would be exceedingly simple: just another field in [Entry].]
[... Yeah, I going to do it – Or at least try it, the same way I tried upsert.]
[maybe [let] for upsert, and [set] for update? Also, I could make it so both are insert in there is
no existing variable in either self or super?]
[No, there would be two upsert, but they behave differently: one first checks if a variable exists
anywhere, the other calls upsert immediately.]

[Perhaps I'm giving myself too much of a headache?]
item-in 1 [a] 42
[^ this assigns one layer higher.]

[what if [meta] is just a string to for code to be executed?]

[I shouldn't forget to implement library like numpy, sciki-learn, tensorflow, pyplot, pandas,
matplotlib, lodash; maybe some minimal js frameworks like htmx or alpine.js; i don't know. Anything
that seems pertinent. Oh and also things like SDL2 and/or raylib]

[I don't think I will do this:]
item [name] [World]
print [Hello, [name]!\n]
[Too much nesting.]
print [Hello, %!\n] name
[better]

[maybe a procedure [do-here] that doesn't push another environment?]

[Do I really need a [meta]? The only reason you might want it is because floats are weird, that and
nicer syntax. If you really cave in and add them, a lot of other doors open, which should remain
closed...]
1 + 1 print [%i] _
[^ this is equivalent to the earlier code; and it's what I do in C. This isn't Hitler or anything.]
[My goal is to make the compiler as small as possible, while still having the performance of C, and
the capabilities of Scheme. I should hold myself to higher standards.]
[This will be really awkward when I do decide to add metadata...]

[I need a [format] procedure for [print]. And I need to malloc and copy a string. I can't print
character by character, since when I encounter an error, it will have printed until the error.
Still, I makes it harder when you don't know the final size of it. Maybe malloc every time I
encounter a %?]

[I will probably put something like as an example, but I want to put it here because of how nice it
look.]
proc [x y] [
    print [Hello, World!\n]
] as [proc]

proc [name] [
    print [Hello, %!\n] name
] as [greet]
greet [World]

print greet [
    will output:
    [parse copy-token item [name] _ print [Hello, %!\n] name]
    and maybe:
    [iter [k] keys [parse copy-token item k _] free keys print [Hello, %!\n] name]
    also [do-here] to evaluate iter block without creating a new environment – or maybe I should
    instead do [item-in]?
]
[How many programming languages can you do that in? I mean the [item k _]; in C you could create a
hashmap, but I this language this is the default. I like.]

[[parse] and [copy-token] and the like should only be usable in a higher scope. Otherwise, things
get really messy. Further experimentation is needed.]

[Maybe I can have two different [do]?]
item [do] [stuff...]
do []
[^ need to do this to see changes.]
item 1 [do] [stuff as well...]
[the change is immediately noticeable, since the rest of the code is executed using this [do].]

[As scuffed as procedures are now, I can't make them in another way without adding metadata, but
adding metadata is worthless since I eventually plan to compile these things.]

[The more I think about, the more difficult compiled symbolic programming sounds. I suppose that why
it hasn't been done yet, in the straightforward I'm trying to do it, I mean. Or has it. Probably
some LISP dialect.]

[Fuck it. I want to simulate compiled procedures. I don't want to write [do] everytime, so I will
use metadata, but only for this specific case; and then, I will naturally remove it once I can
compile them. The only other alternative to using [do] is to write C files, compile them and run
them from the CLI – something I want to absolutely avoid.]

[I don't just want to make the interpreter as small as possible; I want to follow the unix
philosophy in general.]

[Damn, I make a lot of typos.]

[Wait...]
for 0 10 print [%i\n] it
[this could work because [for] remembers the start of [print]; once [print] finished executing,
[for] continues executing, and returns the pointer back to the start of [print].]
[I should really consider it, so I can avoid nesting as much as possible.]

[For using the REPL of this programming language like a shell, I would need a way to import binaries
and call them.]
load-bin [/usr/bin/]
bc [-e sqrt(121)]
[this should print 11]
[although, I might need quotation like in the shell]
bc [-e 'sqrt(121)']
[maybe I can also load individual binaries or entire folder accordingly]

[Do I say S-Statements instead of S-Expressions?]

[Just found out about realloc. Should use it to concatenate strings.]

[Shit, how do I malloc?]
item str [hello]
item-at 0 str [H]
print str [outputs Hello]
[Maybe it's no that difficult?]

[Man, being able to define procedures opens so many doors!]

[I can make a [format] procedure with the new concat function.]

[I should be [get] and [set]]
item [str] [Hello]
get 1 str print [%c\n] _ [outputs 'e']
set 1 str [E] print str [outputs 'HEllo']

[Should I have a special syntax for characters?]
[or maybe]
item [char] [x]
[if the value is a single character long, it just interprets it as a char? No need for malloc?]

[Still, I would have to be mindful when implementing string manipulation.]

[Wait a second...]
proc [] [
    + 1 repeat _ [parse 2] do
] as [?]
5 == 5 ? [] []
[^ an interesting way to implement if statements.]

[Numbers have to be treated specially, otherwise...]
item [a] 1 [throws error, undefined symbol]

[Should I make it so that [return] pops the scope?]
proc [i list len] [
    for [n] list [
        ch n == i ? [return 3 n] [++ len]
    ]
]
[Maybe something similar for [continue]? Like, it's equivalent to [goto 0], or something?]
[Perhaps break as well, but it returns nothing?]

[I'm starting to think that i need special notation for char.]
item [c] 'c'
[^ the string [c] is equal to the char 'c']
[I could make it so a string of length 1 becomes a character automatically, but right now, I don't
know.]
char [a] item [a] _
[^ maybe?]

[Just realized that my language simulates function currying.]

[For [do-here], I don't need anything special; just don't create a new [env], change the [start] and
[end] positions.]
proc [x y] [
    do-here func x y
] as [func]
func 1 2
[First call creates a new [env] because of [do], second+ calls do not.]

[Btw, [type?] is impossible.]

[Everything I say here will probably change once I actually compile the procedures, but whatever.]

[There no point to [then]/[else]]
1 ? [print 1] []
1 then [print 1]
[^ same length]
[I would have to rename [then] to something shorter.]

[Wait, [del] instead of [delete]]

[Create new scope should always be opt-in. So there should be a [do []] inside of all procedures.]

[I will probably have to figure out how to make procedures reference eachother.]

[Perhaps it should just be in [proc] that things are compiled, but everywhere. Like, every statement
is compiled first, then executed. [proc] just makes it so that every statement in the block is
compiled ahead-of-time.]

[Maybe I could take this to my advantage?]
for [][][] [
    print [Hello\n]
]
[you know, how quotes don't check if there're a space at the end?]

[What if the procedure needs the inputs as strings or to invalidate inputs depending on type? Then
you you the arguments to be assigned strings, and the procedures calls inside will manipulate those
string into the desired data.]

[I might need a macro key word that goes does process the parameters.]

syscall 4 [] [is good idea because:]
proc [] [
    syscall 4
] as [write]
write [1 [Hello, World!] 14]

[With my design, even when compiled, [1 + 2 + 3] is too instruction heavy.]
1 + 2 + 3
[is equivalent to ]
[atoi on '1', load into register x0]
[atoi on '2', load into register x1]
add x0, x0, x1
[logic for computing hash]
str x0, [memory location]
[repeat for '3']
[lots of unnecessary steps...]

[Wait]
proc [fd buf n] [
    syscall 4 [fd buf n]
] as [write]
item [str] [Hello, World!\n]
strlen str
write 1 str _
[[write] should not take a variable number of arguments.]

[Yeah, I'm not doing [+=]. Too confusing.]
+= x 2
[or]
+= [x] 2
[? Both are valid and invalid. I don't like it.]
[Well, in any case, it should be easy to define, if you insist on having it.]

[I wasn't initially interested in [defer], but after seeing an example of how [free] could have a
lot of repetition, I reconsidered it. I should try it, at least.]

[Man, I really dug myself in a hole with 64 bit unions. Now I have not way of doing [strcpy], or
whatever.]

[I guess this is a solution.]
load 1 str
stor 1 str 'c'

[I guess, it's also a [goto] vs [defer] thing. Though, people will absolutely hate [goto],
no doubt.]

[It should be the interpreter itself that assigns [_] at the end of a procedure call. The procedure
itself should not concern itself with that.]

[I should figure out how to stuff on the stack... for procedure calls and such.]

[[free] should keep track of what was freed and what wasn't. Avoid double free, basically. I mean,
[free] isn't actually a syscall, apparently. Let's take advantage of that.]
[Then again, it's also an overhead...]


